From 4fd03f26aa1c2ddef24b2c4f8d1a10c96fbf7f40 Mon Sep 17 00:00:00 2001
From: Rob Clark <robclark@freedesktop.org>
Date: Thu, 29 Aug 2013 17:24:33 -0400
Subject: [PATCH 17/17] freedreno: updates for msm drm/kms driver

There where some small API tweaks in libdrm_freedreno to enable support
for msm drm/kms driver.

Signed-off-by: Rob Clark <robclark@freedesktop.org>
---
 src/gallium/drivers/freedreno/a2xx/fd2_emit.c      |  4 +--
 src/gallium/drivers/freedreno/a2xx/fd2_gmem.c      |  6 ++---
 src/gallium/drivers/freedreno/a3xx/fd3_emit.c      | 14 +++++------
 src/gallium/drivers/freedreno/a3xx/fd3_gmem.c      |  8 +++---
 src/gallium/drivers/freedreno/a3xx/fd3_program.c   |  4 +--
 src/gallium/drivers/freedreno/freedreno_draw.c     |  2 +-
 src/gallium/drivers/freedreno/freedreno_resource.c | 18 ++++++++++++--
 src/gallium/drivers/freedreno/freedreno_util.h     | 29 +++++++++++++++-------
 8 files changed, 55 insertions(+), 30 deletions(-)

diff --git a/src/gallium/drivers/freedreno/a2xx/fd2_emit.c b/src/gallium/drivers/freedreno/a2xx/fd2_emit.c
index b03390e..35511ba 100644
--- a/src/gallium/drivers/freedreno/a2xx/fd2_emit.c
+++ b/src/gallium/drivers/freedreno/a2xx/fd2_emit.c
@@ -137,7 +137,7 @@ emit_texture(struct fd_ringbuffer *ring, struct fd_context *ctx,
 	OUT_RING(ring, 0x00010000 + (0x6 * const_idx));
 
 	OUT_RING(ring, sampler->tex0 | view->tex0);
-	OUT_RELOC(ring, view->tex_resource->bo, 0, view->fmt);
+	OUT_RELOC(ring, view->tex_resource->bo, 0, view->fmt, 0);
 	OUT_RING(ring, view->tex2);
 	OUT_RING(ring, sampler->tex3 | view->tex3);
 	OUT_RING(ring, sampler->tex4);
@@ -171,7 +171,7 @@ fd2_emit_vertex_bufs(struct fd_ringbuffer *ring, uint32_t val,
 	OUT_RING(ring, (0x1 << 16) | (val & 0xffff));
 	for (i = 0; i < n; i++) {
 		struct fd_resource *rsc = fd_resource(vbufs[i].prsc);
-		OUT_RELOC(ring, rsc->bo, vbufs[i].offset, 3);
+		OUT_RELOC(ring, rsc->bo, vbufs[i].offset, 3, 0);
 		OUT_RING (ring, vbufs[i].size);
 	}
 }
diff --git a/src/gallium/drivers/freedreno/a2xx/fd2_gmem.c b/src/gallium/drivers/freedreno/a2xx/fd2_gmem.c
index 93695bc..89f5a4d 100644
--- a/src/gallium/drivers/freedreno/a2xx/fd2_gmem.c
+++ b/src/gallium/drivers/freedreno/a2xx/fd2_gmem.c
@@ -70,7 +70,7 @@ emit_gmem2mem_surf(struct fd_ringbuffer *ring, uint32_t base,
 	OUT_PKT3(ring, CP_SET_CONSTANT, 5);
 	OUT_RING(ring, CP_REG(REG_A2XX_RB_COPY_CONTROL));
 	OUT_RING(ring, 0x00000000);             /* RB_COPY_CONTROL */
-	OUT_RELOC(ring, rsc->bo, 0, 0);         /* RB_COPY_DEST_BASE */
+	OUT_RELOCW(ring, rsc->bo, 0, 0, 0);     /* RB_COPY_DEST_BASE */
 	OUT_RING(ring, rsc->pitch >> 5);        /* RB_COPY_DEST_PITCH */
 	OUT_RING(ring,                          /* RB_COPY_DEST_INFO */
 			A2XX_RB_COPY_DEST_INFO_FORMAT(fd2_pipe2color(psurf->format)) |
@@ -199,7 +199,7 @@ emit_mem2gmem_surf(struct fd_ringbuffer *ring, uint32_t base,
 			A2XX_SQ_TEX_0_CLAMP_Z(SQ_TEX_WRAP) |
 			A2XX_SQ_TEX_0_PITCH(rsc->pitch));
 	OUT_RELOC(ring, rsc->bo, 0,
-			fd2_pipe2surface(psurf->format) | 0x800);
+			fd2_pipe2surface(psurf->format) | 0x800, 0);
 	OUT_RING(ring, A2XX_SQ_TEX_2_WIDTH(psurf->width - 1) |
 			A2XX_SQ_TEX_2_HEIGHT(psurf->height - 1));
 	OUT_RING(ring, 0x01000000 | // XXX
@@ -241,7 +241,7 @@ fd2_emit_tile_mem2gmem(struct fd_context *ctx, uint32_t xoff, uint32_t yoff,
 	y0 = ((float)yoff) / ((float)pfb->height);
 	y1 = ((float)yoff + bin_h) / ((float)pfb->height);
 	OUT_PKT3(ring, CP_MEM_WRITE, 9);
-	OUT_RELOC(ring, fd_resource(fd2_ctx->solid_vertexbuf)->bo, 0x60, 0);
+	OUT_RELOC(ring, fd_resource(fd2_ctx->solid_vertexbuf)->bo, 0x60, 0, 0);
 	OUT_RING(ring, fui(x0));
 	OUT_RING(ring, fui(y0));
 	OUT_RING(ring, fui(x1));
diff --git a/src/gallium/drivers/freedreno/a3xx/fd3_emit.c b/src/gallium/drivers/freedreno/a3xx/fd3_emit.c
index 5ffd561..5e58618 100644
--- a/src/gallium/drivers/freedreno/a3xx/fd3_emit.c
+++ b/src/gallium/drivers/freedreno/a3xx/fd3_emit.c
@@ -81,7 +81,7 @@ fd3_emit_constant(struct fd_ringbuffer *ring,
 	if (prsc) {
 		struct fd_bo *bo = fd_resource(prsc)->bo;
 		OUT_RELOC(ring, bo, offset,
-				CP_LOAD_STATE_1_STATE_TYPE(ST_CONSTANTS));
+				CP_LOAD_STATE_1_STATE_TYPE(ST_CONSTANTS), 0);
 	} else {
 		OUT_RING(ring, CP_LOAD_STATE_1_EXT_SRC_ADDR(0) |
 				CP_LOAD_STATE_1_STATE_TYPE(ST_CONSTANTS));
@@ -212,7 +212,7 @@ emit_textures(struct fd_ringbuffer *ring,
 	for (i = 0; i < tex->num_textures; i++) {
 		struct fd3_pipe_sampler_view *view =
 				fd3_pipe_sampler_view(tex->textures[i]);
-		OUT_RELOC(ring, view->tex_resource->bo, 0, 0);
+		OUT_RELOC(ring, view->tex_resource->bo, 0, 0, 0);
 		/* I think each entry is a ptr to mipmap level.. for now, just
 		 * pad w/ null's until I get around to actually implementing
 		 * mipmap support..
@@ -296,7 +296,7 @@ fd3_emit_gmem_restore_tex(struct fd_ringbuffer *ring, struct pipe_surface *psurf
 			CP_LOAD_STATE_0_NUM_UNIT(1));
 	OUT_RING(ring, CP_LOAD_STATE_1_STATE_TYPE(ST_CONSTANTS) |
 			CP_LOAD_STATE_1_EXT_SRC_ADDR(0));
-	OUT_RELOC(ring, rsc->bo, 0, 0);
+	OUT_RELOC(ring, rsc->bo, 0, 0, 0);
 }
 
 void
@@ -322,7 +322,7 @@ fd3_emit_vertex_bufs(struct fd_ringbuffer *ring,
 				COND(switchnext, A3XX_VFD_FETCH_INSTR_0_SWITCHNEXT) |
 				A3XX_VFD_FETCH_INSTR_0_INDEXCODE(i) |
 				A3XX_VFD_FETCH_INSTR_0_STEPRATE(1));
-		OUT_RELOC(ring, rsc->bo, vbufs[i].offset, 0);
+		OUT_RELOC(ring, rsc->bo, vbufs[i].offset, 0, 0);
 
 		OUT_PKT0(ring, REG_A3XX_VFD_DECODE_INSTR(i), 1);
 		OUT_RING(ring, A3XX_VFD_DECODE_INSTR_CONSTFILL |
@@ -481,12 +481,12 @@ fd3_emit_restore(struct fd_context *ctx)
 
 	OUT_PKT0(ring, REG_A3XX_SP_VS_PVT_MEM_CTRL_REG, 3);
 	OUT_RING(ring, 0x08000001);                  /* SP_VS_PVT_MEM_CTRL_REG */
-	OUT_RELOC(ring, fd3_ctx->vs_pvt_mem, 0, 0);  /* SP_VS_PVT_MEM_ADDR_REG */
+	OUT_RELOC(ring, fd3_ctx->vs_pvt_mem, 0,0,0); /* SP_VS_PVT_MEM_ADDR_REG */
 	OUT_RING(ring, 0x00000000);                  /* SP_VS_PVT_MEM_SIZE_REG */
 
 	OUT_PKT0(ring, REG_A3XX_SP_FS_PVT_MEM_CTRL_REG, 3);
 	OUT_RING(ring, 0x08000001);                  /* SP_FS_PVT_MEM_CTRL_REG */
-	OUT_RELOC(ring, fd3_ctx->fs_pvt_mem, 0, 0);  /* SP_FS_PVT_MEM_ADDR_REG */
+	OUT_RELOC(ring, fd3_ctx->fs_pvt_mem, 0,0,0); /* SP_FS_PVT_MEM_ADDR_REG */
 	OUT_RING(ring, 0x00000000);                  /* SP_FS_PVT_MEM_SIZE_REG */
 
 	OUT_PKT0(ring, REG_A3XX_PC_VERTEX_REUSE_BLOCK_CNTL, 1);
@@ -549,7 +549,7 @@ fd3_emit_restore(struct fd_context *ctx)
 	OUT_RING(ring, 0x00000001);        /* UCHE_CACHE_MODE_CONTROL_REG */
 
 	OUT_PKT0(ring, REG_A3XX_VSC_SIZE_ADDRESS, 1);
-	OUT_RELOC(ring, fd3_ctx->vsc_size_mem, 0, 0); /* VSC_SIZE_ADDRESS */
+	OUT_RELOC(ring, fd3_ctx->vsc_size_mem, 0, 0, 0); /* VSC_SIZE_ADDRESS */
 
 	OUT_PKT0(ring, REG_A3XX_GRAS_CL_CLIP_CNTL, 1);
 	OUT_RING(ring, 0x00000000);                  /* GRAS_CL_CLIP_CNTL */
diff --git a/src/gallium/drivers/freedreno/a3xx/fd3_gmem.c b/src/gallium/drivers/freedreno/a3xx/fd3_gmem.c
index b9d0580..8d2df47 100644
--- a/src/gallium/drivers/freedreno/a3xx/fd3_gmem.c
+++ b/src/gallium/drivers/freedreno/a3xx/fd3_gmem.c
@@ -89,7 +89,7 @@ emit_mrt(struct fd_ringbuffer *ring, unsigned nr_bufs,
 		if (bin_w || (i >= nr_bufs)) {
 			OUT_RING(ring, A3XX_RB_MRT_BUF_BASE_COLOR_BUF_BASE(base));
 		} else {
-			OUT_RELOCS(ring, res->bo, 0, 0, -1);
+			OUT_RELOCW(ring, res->bo, 0, 0, -1);
 		}
 
 		OUT_PKT0(ring, REG_A3XX_SP_FS_IMAGE_OUTPUT_REG(i), 1);
@@ -116,7 +116,7 @@ emit_gmem2mem_surf(struct fd_ringbuffer *ring,
 	OUT_RING(ring, A3XX_RB_COPY_CONTROL_MSAA_RESOLVE(MSAA_ONE) |
 			A3XX_RB_COPY_CONTROL_MODE(mode) |
 			A3XX_RB_COPY_CONTROL_GMEM_BASE(base));
-	OUT_RELOCS(ring, rsc->bo, 0, 0, -1);    /* RB_COPY_DEST_BASE */
+	OUT_RELOCW(ring, rsc->bo, 0, 0, -1);    /* RB_COPY_DEST_BASE */
 	OUT_RING(ring, A3XX_RB_COPY_DEST_PITCH_PITCH(rsc->pitch * rsc->cpp));
 	OUT_RING(ring, A3XX_RB_COPY_DEST_INFO_TILE(LINEAR) |
 			A3XX_RB_COPY_DEST_INFO_FORMAT(fd3_pipe2color(psurf->format)) |
@@ -272,7 +272,7 @@ fd3_emit_tile_mem2gmem(struct fd_context *ctx, uint32_t xoff, uint32_t yoff,
 	y1 = ((float)yoff + bin_h) / ((float)pfb->height);
 
 	OUT_PKT3(ring, CP_MEM_WRITE, 5);
-	OUT_RELOC(ring, fd_resource(fd3_ctx->blit_texcoord_vbuf)->bo, 0, 0);
+	OUT_RELOC(ring, fd_resource(fd3_ctx->blit_texcoord_vbuf)->bo, 0, 0, 0);
 	OUT_RING(ring, fui(x0));
 	OUT_RING(ring, fui(y0));
 	OUT_RING(ring, fui(x1));
@@ -395,7 +395,7 @@ update_vsc_pipe(struct fd_context *ctx)
 			A3XX_VSC_PIPE_CONFIG_Y(0) |
 			A3XX_VSC_PIPE_CONFIG_W(gmem->nbins_x) |
 			A3XX_VSC_PIPE_CONFIG_H(gmem->nbins_y));
-	OUT_RELOC(ring, bo, 0, 0);              /* VSC_PIPE[0].DATA_ADDRESS */
+	OUT_RELOC(ring, bo, 0, 0, 0);           /* VSC_PIPE[0].DATA_ADDRESS */
 	OUT_RING(ring, fd_bo_size(bo) - 32);    /* VSC_PIPE[0].DATA_LENGTH */
 
 	for (i = 1; i < 8; i++) {
diff --git a/src/gallium/drivers/freedreno/a3xx/fd3_program.c b/src/gallium/drivers/freedreno/a3xx/fd3_program.c
index 259c2dd..c6c51b1 100644
--- a/src/gallium/drivers/freedreno/a3xx/fd3_program.c
+++ b/src/gallium/drivers/freedreno/a3xx/fd3_program.c
@@ -320,7 +320,7 @@ fd3_program_emit(struct fd_ringbuffer *ring,
 	OUT_PKT0(ring, REG_A3XX_SP_VS_OBJ_OFFSET_REG, 2);
 	OUT_RING(ring, A3XX_SP_VS_OBJ_OFFSET_REG_CONSTOBJECTOFFSET(0) |
 			A3XX_SP_VS_OBJ_OFFSET_REG_SHADEROBJOFFSET(0));
-	OUT_RELOC(ring, vp->bo, 0, 0);    /* SP_VS_OBJ_START_REG */
+	OUT_RELOC(ring, vp->bo, 0, 0, 0);  /* SP_VS_OBJ_START_REG */
 #endif
 
 	OUT_PKT0(ring, REG_A3XX_SP_FS_LENGTH_REG, 1);
@@ -345,7 +345,7 @@ fd3_program_emit(struct fd_ringbuffer *ring,
 	OUT_PKT0(ring, REG_A3XX_SP_FS_OBJ_OFFSET_REG, 2);
 	OUT_RING(ring, A3XX_SP_FS_OBJ_OFFSET_REG_CONSTOBJECTOFFSET(128) |
 			A3XX_SP_FS_OBJ_OFFSET_REG_SHADEROBJOFFSET(128 - fp->instrlen));
-	OUT_RELOC(ring, fp->bo, 0, 0);    /* SP_FS_OBJ_START_REG */
+	OUT_RELOC(ring, fp->bo, 0, 0, 0);  /* SP_FS_OBJ_START_REG */
 #endif
 
 	OUT_PKT0(ring, REG_A3XX_SP_FS_FLAT_SHAD_MODE_REG_0, 2);
diff --git a/src/gallium/drivers/freedreno/freedreno_draw.c b/src/gallium/drivers/freedreno/freedreno_draw.c
index d4f8d34..4a98ab4 100644
--- a/src/gallium/drivers/freedreno/freedreno_draw.c
+++ b/src/gallium/drivers/freedreno/freedreno_draw.c
@@ -104,7 +104,7 @@ fd_draw_emit(struct fd_context *ctx, const struct pipe_draw_info *info)
 			src_sel, idx_type, IGNORE_VISIBILITY));
 	OUT_RING(ring, info->count);       /* NumIndices */
 	if (info->indexed) {
-		OUT_RELOC(ring, idx_bo, idx_offset, 0);
+		OUT_RELOC(ring, idx_bo, idx_offset, 0, 0);
 		OUT_RING (ring, idx_size);
 	}
 }
diff --git a/src/gallium/drivers/freedreno/freedreno_resource.c b/src/gallium/drivers/freedreno/freedreno_resource.c
index 1b1eaa5..3e051ea 100644
--- a/src/gallium/drivers/freedreno/freedreno_resource.c
+++ b/src/gallium/drivers/freedreno/freedreno_resource.c
@@ -59,6 +59,9 @@ fd_resource_transfer_unmap(struct pipe_context *pctx,
 		struct pipe_transfer *ptrans)
 {
 	struct fd_context *ctx = fd_context(pctx);
+	struct fd_resource *rsc = fd_resource(ptrans->resource);
+	if (!(ptrans->usage & PIPE_TRANSFER_UNSYNCHRONIZED))
+		fd_bo_cpu_fini(rsc->bo);
 	pipe_resource_reference(&ptrans->resource, NULL);
 	util_slab_free(&ctx->transfer_pool, ptrans);
 }
@@ -74,12 +77,13 @@ fd_resource_transfer_map(struct pipe_context *pctx,
 	struct fd_resource *rsc = fd_resource(prsc);
 	struct pipe_transfer *ptrans = util_slab_alloc(&ctx->transfer_pool);
 	enum pipe_format format = prsc->format;
+	uint32_t op = 0;
 	char *buf;
 
 	if (!ptrans)
 		return NULL;
 
-	/* util_slap_alloc() doesn't zero: */
+	/* util_slab_alloc() doesn't zero: */
 	memset(ptrans, 0, sizeof(*ptrans));
 
 	pipe_resource_reference(&ptrans->resource, prsc);
@@ -90,7 +94,8 @@ fd_resource_transfer_map(struct pipe_context *pctx,
 	ptrans->layer_stride = ptrans->stride;
 
 	/* some state trackers (at least XA) don't do this.. */
-	fd_resource_transfer_flush_region(pctx, ptrans, box);
+	if (!(usage & PIPE_TRANSFER_FLUSH_EXPLICIT))
+		fd_resource_transfer_flush_region(pctx, ptrans, box);
 
 	buf = fd_bo_map(rsc->bo);
 	if (!buf) {
@@ -98,6 +103,15 @@ fd_resource_transfer_map(struct pipe_context *pctx,
 		return NULL;
 	}
 
+	if (usage & PIPE_TRANSFER_READ)
+		op |= DRM_FREEDRENO_PREP_READ;
+
+	if (usage & PIPE_TRANSFER_WRITE)
+		op |= DRM_FREEDRENO_PREP_WRITE;
+
+	if (!(usage & PIPE_TRANSFER_UNSYNCHRONIZED))
+		fd_bo_cpu_prep(rsc->bo, ctx->screen->pipe, op);
+
 	*pptrans = ptrans;
 
 	return buf +
diff --git a/src/gallium/drivers/freedreno/freedreno_util.h b/src/gallium/drivers/freedreno/freedreno_util.h
index 9f10686..7bbbe80 100644
--- a/src/gallium/drivers/freedreno/freedreno_util.h
+++ b/src/gallium/drivers/freedreno/freedreno_util.h
@@ -104,25 +104,36 @@ OUT_RING(struct fd_ringbuffer *ring, uint32_t data)
 
 static inline void
 OUT_RELOC(struct fd_ringbuffer *ring, struct fd_bo *bo,
-		uint32_t offset, uint32_t or)
+		uint32_t offset, uint32_t or, int32_t shift)
 {
 	if (LOG_DWORDS) {
-		DBG("ring[%p]: OUT_RELOC  %04x:  %p+%u", ring,
-				(uint32_t)(ring->cur - ring->last_start), bo, offset);
+		DBG("ring[%p]: OUT_RELOC   %04x:  %p+%u << %d", ring,
+				(uint32_t)(ring->cur - ring->last_start), bo, offset, shift);
 	}
-	fd_ringbuffer_emit_reloc(ring, bo, offset, or);
+	fd_ringbuffer_reloc(ring, &(struct fd_reloc){
+		.bo = bo,
+		.flags = FD_RELOC_READ,
+		.offset = offset,
+		.or = or,
+		.shift = shift,
+	});
 }
 
-/* shifted reloc: */
 static inline void
-OUT_RELOCS(struct fd_ringbuffer *ring, struct fd_bo *bo,
+OUT_RELOCW(struct fd_ringbuffer *ring, struct fd_bo *bo,
 		uint32_t offset, uint32_t or, int32_t shift)
 {
 	if (LOG_DWORDS) {
-		DBG("ring[%p]: OUT_RELOCS  %04x:  %p+%u << %d", ring,
+		DBG("ring[%p]: OUT_RELOC   %04x:  %p+%u << %d", ring,
 				(uint32_t)(ring->cur - ring->last_start), bo, offset, shift);
 	}
-	fd_ringbuffer_emit_reloc_shift(ring, bo, offset, or, shift);
+	fd_ringbuffer_reloc(ring, &(struct fd_reloc){
+		.bo = bo,
+		.flags = FD_RELOC_READ | FD_RELOC_WRITE,
+		.offset = offset,
+		.or = or,
+		.shift = shift,
+	});
 }
 
 static inline void BEGIN_RING(struct fd_ringbuffer *ring, uint32_t ndwords)
@@ -155,7 +166,7 @@ OUT_IB(struct fd_ringbuffer *ring, struct fd_ringmarker *start,
 		struct fd_ringmarker *end)
 {
 	OUT_PKT3(ring, CP_INDIRECT_BUFFER_PFD, 2);
-	fd_ringbuffer_emit_reloc_ring(ring, start);
+	fd_ringbuffer_emit_reloc_ring(ring, start, end);
 	OUT_RING(ring, fd_ringmarker_dwords(start, end));
 }
 
-- 
1.8.4.2

