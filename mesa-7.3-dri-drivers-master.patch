diff --git a/src/mesa/drivers/dri/common/dri_util.h b/src/mesa/drivers/dri/common/dri_util.h
index c6781f1..c95a5c8 100644
--- a/src/mesa/drivers/dri/common/dri_util.h
+++ b/src/mesa/drivers/dri/common/dri_util.h
@@ -1,25 +1,3 @@
-/* $XFree86: xc/lib/GL/dri/dri_util.h,v 1.1 2002/02/22 21:32:52 dawes Exp $ */
-/**
- * \file dri_util.h
- * DRI utility functions definitions.
- *
- * This module acts as glue between GLX and the actual hardware driver.  A DRI
- * driver doesn't really \e have to use any of this - it's optional.  But, some
- * useful stuff is done here that otherwise would have to be duplicated in most
- * drivers.
- * 
- * Basically, these utility functions take care of some of the dirty details of
- * screen initialization, context creation, context binding, DRM setup, etc.
- *
- * These functions are compiled into each DRI driver so libGL.so knows nothing
- * about them.
- *
- * \sa dri_util.c.
- * 
- * \author Kevin E. Martin <kevin@precisioninsight.com>
- * \author Brian Paul <brian@precisioninsight.com>
- */
-
 /*
  * Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
  * All Rights Reserved.
@@ -45,6 +23,26 @@
  * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
+/**
+ * \file dri_util.h
+ * DRI utility functions definitions.
+ *
+ * This module acts as glue between GLX and the actual hardware driver.  A DRI
+ * driver doesn't really \e have to use any of this - it's optional.  But, some
+ * useful stuff is done here that otherwise would have to be duplicated in most
+ * drivers.
+ * 
+ * Basically, these utility functions take care of some of the dirty details of
+ * screen initialization, context creation, context binding, DRM setup, etc.
+ *
+ * These functions are compiled into each DRI driver so libGL.so knows nothing
+ * about them.
+ *
+ * \sa dri_util.c.
+ * 
+ * \author Kevin E. Martin <kevin@precisioninsight.com>
+ * \author Brian Paul <brian@precisioninsight.com>
+ */
 
 #ifndef _DRI_UTIL_H_
 #define _DRI_UTIL_H_
diff --git a/src/mesa/drivers/dri/common/drirenderbuffer.c b/src/mesa/drivers/dri/common/drirenderbuffer.c
index b99bf20..15af991 100644
--- a/src/mesa/drivers/dri/common/drirenderbuffer.c
+++ b/src/mesa/drivers/dri/common/drirenderbuffer.c
@@ -209,6 +209,8 @@ driUpdateFramebufferSize(GLcontext *ctx, const __DRIdrawablePrivate *dPriv)
    struct gl_framebuffer *fb = (struct gl_framebuffer *) dPriv->driverPrivate;
    if (fb && (dPriv->w != fb->Width || dPriv->h != fb->Height)) {
       ctx->Driver.ResizeBuffers(ctx, fb, dPriv->w, dPriv->h);
+      /* if the driver needs the hw lock for ResizeBuffers, the drawable
+         might have changed again by now */
       assert(fb->Width == dPriv->w);
       assert(fb->Height == dPriv->h);
    }
diff --git a/src/mesa/drivers/dri/common/extension_helper.h b/src/mesa/drivers/dri/common/extension_helper.h
index b977ebf..0d641f2 100644
--- a/src/mesa/drivers/dri/common/extension_helper.h
+++ b/src/mesa/drivers/dri/common/extension_helper.h
@@ -119,9 +119,10 @@ static const char ActiveTextureARB_names[] =
     "";
 #endif
 
-#if defined(need_GL_EXT_framebuffer_blit)
+#if defined(need_GL_ARB_framebuffer_object) || defined(need_GL_EXT_framebuffer_blit)
 static const char BlitFramebufferEXT_names[] = 
     "iiiiiiiiii\0" /* Parameter signature */
+    "glBlitFramebuffer\0"
     "glBlitFramebufferEXT\0"
     "";
 #endif
@@ -433,17 +434,18 @@ static const char Color4ubVertex3fvSUN_names[] =
     "";
 #endif
 
-#if defined(need_GL_EXT_texture_array)
+#if defined(need_GL_ARB_framebuffer_object) || defined(need_GL_EXT_texture_array)
 static const char FramebufferTextureLayerEXT_names[] = 
     "iiiii\0" /* Parameter signature */
+    "glFramebufferTextureLayer\0"
     "glFramebufferTextureLayerEXT\0"
     "";
 #endif
 
 #if defined(need_GL_SGIX_list_priority)
-static const char GetListParameterivSGIX_names[] = 
+static const char GetListParameterfvSGIX_names[] = 
     "iip\0" /* Parameter signature */
-    "glGetListParameterivSGIX\0"
+    "glGetListParameterfvSGIX\0"
     "";
 #endif
 
@@ -777,6 +779,13 @@ static const char VertexAttribs4fvNV_names[] =
     "";
 #endif
 
+#if defined(need_GL_NV_vertex_array_range)
+static const char VertexArrayRangeNV_names[] = 
+    "ip\0" /* Parameter signature */
+    "glVertexArrayRangeNV\0"
+    "";
+#endif
+
 #if defined(need_GL_SGIX_fragment_lighting)
 static const char FragmentLightiSGIX_names[] = 
     "iii\0" /* Parameter signature */
@@ -946,9 +955,10 @@ static const char VertexAttribs3fvNV_names[] =
     "";
 #endif
 
-#if defined(need_GL_EXT_framebuffer_object)
+#if defined(need_GL_ARB_framebuffer_object) || defined(need_GL_EXT_framebuffer_object)
 static const char GenerateMipmapEXT_names[] = 
     "i\0" /* Parameter signature */
+    "glGenerateMipmap\0"
     "glGenerateMipmapEXT\0"
     "";
 #endif
@@ -1077,13 +1087,6 @@ static const char AreTexturesResident_names[] =
     "";
 #endif
 
-#if defined(need_GL_EXT_framebuffer_object)
-static const char IsRenderbufferEXT_names[] = 
-    "i\0" /* Parameter signature */
-    "glIsRenderbufferEXT\0"
-    "";
-#endif
-
 #if defined(need_GL_VERSION_2_0) || defined(need_GL_ATI_separate_stencil)
 static const char StencilOpSeparate_names[] = 
     "iiii\0" /* Parameter signature */
@@ -1171,9 +1174,10 @@ static const char TexCoord2fNormal3fVertex3fSUN_names[] =
     "";
 #endif
 
-#if defined(need_GL_EXT_framebuffer_object)
+#if defined(need_GL_ARB_framebuffer_object) || defined(need_GL_EXT_framebuffer_object)
 static const char RenderbufferStorageEXT_names[] = 
     "iiii\0" /* Parameter signature */
+    "glRenderbufferStorage\0"
     "glRenderbufferStorageEXT\0"
     "";
 #endif
@@ -1364,9 +1368,10 @@ static const char SpriteParameterfvSGIX_names[] =
     "";
 #endif
 
-#if defined(need_GL_EXT_framebuffer_object)
+#if defined(need_GL_ARB_framebuffer_object) || defined(need_GL_EXT_framebuffer_object)
 static const char CheckFramebufferStatusEXT_names[] = 
     "i\0" /* Parameter signature */
+    "glCheckFramebufferStatus\0"
     "glCheckFramebufferStatusEXT\0"
     "";
 #endif
@@ -1554,13 +1559,6 @@ static const char FragmentLightivSGIX_names[] =
     "";
 #endif
 
-#if defined(need_GL_EXT_framebuffer_object)
-static const char DeleteRenderbuffersEXT_names[] = 
-    "ip\0" /* Parameter signature */
-    "glDeleteRenderbuffersEXT\0"
-    "";
-#endif
-
 #if defined(need_GL_EXT_pixel_transform)
 static const char PixelTransformParameterfvEXT_names[] = 
     "iip\0" /* Parameter signature */
@@ -1621,9 +1619,10 @@ static const char WindowPos2dMESA_names[] =
     "";
 #endif
 
-#if defined(need_GL_EXT_framebuffer_object)
+#if defined(need_GL_ARB_framebuffer_object) || defined(need_GL_EXT_framebuffer_object)
 static const char FramebufferTexture3DEXT_names[] = 
     "iiiiii\0" /* Parameter signature */
+    "glFramebufferTexture3D\0"
     "glFramebufferTexture3DEXT\0"
     "";
 #endif
@@ -1673,10 +1672,11 @@ static const char IndexFuncEXT_names[] =
     "";
 #endif
 
-#if defined(need_GL_SGIX_list_priority)
-static const char GetListParameterfvSGIX_names[] = 
-    "iip\0" /* Parameter signature */
-    "glGetListParameterfvSGIX\0"
+#if defined(need_GL_ARB_framebuffer_object) || defined(need_GL_EXT_framebuffer_object)
+static const char FramebufferTexture2DEXT_names[] = 
+    "iiiii\0" /* Parameter signature */
+    "glFramebufferTexture2D\0"
+    "glFramebufferTexture2DEXT\0"
     "";
 #endif
 
@@ -1763,13 +1763,6 @@ static const char DeleteFencesNV_names[] =
     "";
 #endif
 
-#if defined(need_GL_SGIX_polynomial_ffd)
-static const char DeformationMap3dSGIX_names[] = 
-    "iddiiddiiddiip\0" /* Parameter signature */
-    "glDeformationMap3dSGIX\0"
-    "";
-#endif
-
 #if defined(need_GL_VERSION_2_0)
 static const char IsShader_names[] = 
     "i\0" /* Parameter signature */
@@ -1894,6 +1887,13 @@ static const char MatrixIndexuivARB_names[] =
     "";
 #endif
 
+#if defined(need_GL_ARB_framebuffer_object)
+static const char RenderbufferStorageMultisample_names[] = 
+    "iiiii\0" /* Parameter signature */
+    "glRenderbufferStorageMultisample\0"
+    "";
+#endif
+
 #if defined(need_GL_EXT_coordinate_frame)
 static const char Tangent3sEXT_names[] = 
     "iii\0" /* Parameter signature */
@@ -1944,9 +1944,10 @@ static const char VertexAttrib2dvNV_names[] =
     "";
 #endif
 
-#if defined(need_GL_EXT_framebuffer_object)
+#if defined(need_GL_ARB_framebuffer_object) || defined(need_GL_EXT_framebuffer_object)
 static const char FramebufferRenderbufferEXT_names[] = 
     "iiii\0" /* Parameter signature */
+    "glFramebufferRenderbuffer\0"
     "glFramebufferRenderbufferEXT\0"
     "";
 #endif
@@ -1973,9 +1974,10 @@ static const char SetFenceNV_names[] =
     "";
 #endif
 
-#if defined(need_GL_EXT_framebuffer_object)
+#if defined(need_GL_ARB_framebuffer_object) || defined(need_GL_EXT_framebuffer_object)
 static const char FramebufferTexture1DEXT_names[] = 
     "iiiii\0" /* Parameter signature */
+    "glFramebufferTexture1D\0"
     "glFramebufferTexture1DEXT\0"
     "";
 #endif
@@ -2105,9 +2107,10 @@ static const char Tangent3fvEXT_names[] =
     "";
 #endif
 
-#if defined(need_GL_EXT_framebuffer_object)
+#if defined(need_GL_ARB_framebuffer_object) || defined(need_GL_EXT_framebuffer_object)
 static const char BindFramebufferEXT_names[] = 
     "ii\0" /* Parameter signature */
+    "glBindFramebuffer\0"
     "glBindFramebufferEXT\0"
     "";
 #endif
@@ -2488,9 +2491,10 @@ static const char MapParameterivNV_names[] =
     "";
 #endif
 
-#if defined(need_GL_EXT_framebuffer_object)
+#if defined(need_GL_ARB_framebuffer_object) || defined(need_GL_EXT_framebuffer_object)
 static const char GenRenderbuffersEXT_names[] = 
     "ip\0" /* Parameter signature */
+    "glGenRenderbuffers\0"
     "glGenRenderbuffersEXT\0"
     "";
 #endif
@@ -2952,9 +2956,10 @@ static const char WindowPos2ivMESA_names[] =
     "";
 #endif
 
-#if defined(need_GL_EXT_framebuffer_object)
+#if defined(need_GL_ARB_framebuffer_object) || defined(need_GL_EXT_framebuffer_object)
 static const char IsFramebufferEXT_names[] = 
     "i\0" /* Parameter signature */
+    "glIsFramebuffer\0"
     "glIsFramebufferEXT\0"
     "";
 #endif
@@ -3125,13 +3130,6 @@ static const char ReplacementCodeuiSUN_names[] =
     "";
 #endif
 
-#if defined(need_GL_EXT_framebuffer_object)
-static const char FramebufferTexture2DEXT_names[] = 
-    "iiiii\0" /* Parameter signature */
-    "glFramebufferTexture2DEXT\0"
-    "";
-#endif
-
 #if defined(need_GL_NV_vertex_program)
 static const char VertexAttribPointerNV_names[] = 
     "iiiip\0" /* Parameter signature */
@@ -3139,13 +3137,21 @@ static const char VertexAttribPointerNV_names[] =
     "";
 #endif
 
-#if defined(need_GL_EXT_framebuffer_object)
+#if defined(need_GL_ARB_framebuffer_object) || defined(need_GL_EXT_framebuffer_object)
 static const char GetFramebufferAttachmentParameterivEXT_names[] = 
     "iiip\0" /* Parameter signature */
+    "glGetFramebufferAttachmentParameteriv\0"
     "glGetFramebufferAttachmentParameterivEXT\0"
     "";
 #endif
 
+#if defined(need_GL_EXT_pixel_transform)
+static const char PixelTransformParameterfEXT_names[] = 
+    "iif\0" /* Parameter signature */
+    "glPixelTransformParameterfEXT\0"
+    "";
+#endif
+
 #if defined(need_GL_VERSION_1_3)
 static const char MultiTexCoord4dvARB_names[] = 
     "ip\0" /* Parameter signature */
@@ -3264,9 +3270,10 @@ static const char VertexAttrib3fvARB_names[] =
     "";
 #endif
 
-#if defined(need_GL_EXT_framebuffer_object)
+#if defined(need_GL_ARB_framebuffer_object) || defined(need_GL_EXT_framebuffer_object)
 static const char DeleteFramebuffersEXT_names[] = 
     "ip\0" /* Parameter signature */
+    "glDeleteFramebuffers\0"
     "glDeleteFramebuffersEXT\0"
     "";
 #endif
@@ -3360,9 +3367,10 @@ static const char GetPixelTexGenParameterfvSGIS_names[] =
     "";
 #endif
 
-#if defined(need_GL_EXT_framebuffer_object)
+#if defined(need_GL_ARB_framebuffer_object) || defined(need_GL_EXT_framebuffer_object)
 static const char GenFramebuffersEXT_names[] = 
     "ip\0" /* Parameter signature */
+    "glGenFramebuffers\0"
     "glGenFramebuffersEXT\0"
     "";
 #endif
@@ -3374,10 +3382,10 @@ static const char GetProgramParameterdvNV_names[] =
     "";
 #endif
 
-#if defined(need_GL_EXT_pixel_transform)
-static const char PixelTransformParameterfEXT_names[] = 
-    "iif\0" /* Parameter signature */
-    "glPixelTransformParameterfEXT\0"
+#if defined(need_GL_SGIX_instruments)
+static const char PollInstrumentsSGIX_names[] = 
+    "p\0" /* Parameter signature */
+    "glPollInstrumentsSGIX\0"
     "";
 #endif
 
@@ -3709,9 +3717,10 @@ static const char MultiDrawArraysEXT_names[] =
     "";
 #endif
 
-#if defined(need_GL_EXT_framebuffer_object)
+#if defined(need_GL_ARB_framebuffer_object) || defined(need_GL_EXT_framebuffer_object)
 static const char BindRenderbufferEXT_names[] = 
     "ii\0" /* Parameter signature */
+    "glBindRenderbuffer\0"
     "glBindRenderbufferEXT\0"
     "";
 #endif
@@ -4530,6 +4539,13 @@ static const char Minmax_names[] =
     "";
 #endif
 
+#if defined(need_GL_SGIX_polynomial_ffd)
+static const char DeformationMap3dSGIX_names[] = 
+    "iddiiddiiddiip\0" /* Parameter signature */
+    "glDeformationMap3dSGIX\0"
+    "";
+#endif
+
 #if defined(need_GL_VERSION_1_4) || defined(need_GL_EXT_fog_coord)
 static const char FogCoorddvEXT_names[] = 
     "p\0" /* Parameter signature */
@@ -4605,10 +4621,11 @@ static const char WeightdvARB_names[] =
     "";
 #endif
 
-#if defined(need_GL_SGIX_instruments)
-static const char PollInstrumentsSGIX_names[] = 
-    "p\0" /* Parameter signature */
-    "glPollInstrumentsSGIX\0"
+#if defined(need_GL_ARB_framebuffer_object) || defined(need_GL_EXT_framebuffer_object)
+static const char DeleteRenderbuffersEXT_names[] = 
+    "ip\0" /* Parameter signature */
+    "glDeleteRenderbuffers\0"
+    "glDeleteRenderbuffersEXT\0"
     "";
 #endif
 
@@ -4684,9 +4701,10 @@ static const char MultiTexCoord2fvARB_names[] =
     "";
 #endif
 
-#if defined(need_GL_EXT_framebuffer_object)
+#if defined(need_GL_ARB_framebuffer_object) || defined(need_GL_EXT_framebuffer_object)
 static const char GetRenderbufferParameterivEXT_names[] = 
     "iip\0" /* Parameter signature */
+    "glGetRenderbufferParameteriv\0"
     "glGetRenderbufferParameterivEXT\0"
     "";
 #endif
@@ -4742,6 +4760,13 @@ static const char Tangent3svEXT_names[] =
     "";
 #endif
 
+#if defined(need_GL_SGIX_list_priority)
+static const char GetListParameterivSGIX_names[] = 
+    "iip\0" /* Parameter signature */
+    "glGetListParameterivSGIX\0"
+    "";
+#endif
+
 #if defined(need_GL_VERSION_1_5) || defined(need_GL_ARB_vertex_buffer_object)
 static const char BindBufferARB_names[] = 
     "ii\0" /* Parameter signature */
@@ -4823,10 +4848,11 @@ static const char FragmentMaterialivSGIX_names[] =
     "";
 #endif
 
-#if defined(need_GL_NV_vertex_array_range)
-static const char VertexArrayRangeNV_names[] = 
-    "ip\0" /* Parameter signature */
-    "glVertexArrayRangeNV\0"
+#if defined(need_GL_ARB_framebuffer_object) || defined(need_GL_EXT_framebuffer_object)
+static const char IsRenderbufferEXT_names[] = 
+    "i\0" /* Parameter signature */
+    "glIsRenderbuffer\0"
+    "glIsRenderbufferEXT\0"
     "";
 #endif
 
@@ -4892,6 +4918,32 @@ static const struct dri_extension_function GL_ARB_draw_buffers_functions[] = {
 };
 #endif
 
+#if defined(need_GL_ARB_framebuffer_object)
+static const struct dri_extension_function GL_ARB_framebuffer_object_functions[] = {
+    { BlitFramebufferEXT_names, BlitFramebufferEXT_remap_index, -1 },
+    { FramebufferTextureLayerEXT_names, FramebufferTextureLayerEXT_remap_index, -1 },
+    { GenerateMipmapEXT_names, GenerateMipmapEXT_remap_index, -1 },
+    { RenderbufferStorageEXT_names, RenderbufferStorageEXT_remap_index, -1 },
+    { CheckFramebufferStatusEXT_names, CheckFramebufferStatusEXT_remap_index, -1 },
+    { FramebufferTexture3DEXT_names, FramebufferTexture3DEXT_remap_index, -1 },
+    { FramebufferTexture2DEXT_names, FramebufferTexture2DEXT_remap_index, -1 },
+    { RenderbufferStorageMultisample_names, RenderbufferStorageMultisample_remap_index, -1 },
+    { FramebufferRenderbufferEXT_names, FramebufferRenderbufferEXT_remap_index, -1 },
+    { FramebufferTexture1DEXT_names, FramebufferTexture1DEXT_remap_index, -1 },
+    { BindFramebufferEXT_names, BindFramebufferEXT_remap_index, -1 },
+    { GenRenderbuffersEXT_names, GenRenderbuffersEXT_remap_index, -1 },
+    { IsFramebufferEXT_names, IsFramebufferEXT_remap_index, -1 },
+    { GetFramebufferAttachmentParameterivEXT_names, GetFramebufferAttachmentParameterivEXT_remap_index, -1 },
+    { DeleteFramebuffersEXT_names, DeleteFramebuffersEXT_remap_index, -1 },
+    { GenFramebuffersEXT_names, GenFramebuffersEXT_remap_index, -1 },
+    { BindRenderbufferEXT_names, BindRenderbufferEXT_remap_index, -1 },
+    { DeleteRenderbuffersEXT_names, DeleteRenderbuffersEXT_remap_index, -1 },
+    { GetRenderbufferParameterivEXT_names, GetRenderbufferParameterivEXT_remap_index, -1 },
+    { IsRenderbufferEXT_names, IsRenderbufferEXT_remap_index, -1 },
+    { NULL, 0, 0 }
+};
+#endif
+
 #if defined(need_GL_ARB_matrix_palette)
 static const struct dri_extension_function GL_ARB_matrix_palette_functions[] = {
     { MatrixIndexusvARB_names, MatrixIndexusvARB_remap_index, -1 },
@@ -5319,22 +5371,22 @@ static const struct dri_extension_function GL_EXT_framebuffer_blit_functions[] =
 #if defined(need_GL_EXT_framebuffer_object)
 static const struct dri_extension_function GL_EXT_framebuffer_object_functions[] = {
     { GenerateMipmapEXT_names, GenerateMipmapEXT_remap_index, -1 },
-    { IsRenderbufferEXT_names, IsRenderbufferEXT_remap_index, -1 },
     { RenderbufferStorageEXT_names, RenderbufferStorageEXT_remap_index, -1 },
     { CheckFramebufferStatusEXT_names, CheckFramebufferStatusEXT_remap_index, -1 },
-    { DeleteRenderbuffersEXT_names, DeleteRenderbuffersEXT_remap_index, -1 },
     { FramebufferTexture3DEXT_names, FramebufferTexture3DEXT_remap_index, -1 },
+    { FramebufferTexture2DEXT_names, FramebufferTexture2DEXT_remap_index, -1 },
     { FramebufferRenderbufferEXT_names, FramebufferRenderbufferEXT_remap_index, -1 },
     { FramebufferTexture1DEXT_names, FramebufferTexture1DEXT_remap_index, -1 },
     { BindFramebufferEXT_names, BindFramebufferEXT_remap_index, -1 },
     { GenRenderbuffersEXT_names, GenRenderbuffersEXT_remap_index, -1 },
     { IsFramebufferEXT_names, IsFramebufferEXT_remap_index, -1 },
-    { FramebufferTexture2DEXT_names, FramebufferTexture2DEXT_remap_index, -1 },
     { GetFramebufferAttachmentParameterivEXT_names, GetFramebufferAttachmentParameterivEXT_remap_index, -1 },
     { DeleteFramebuffersEXT_names, DeleteFramebuffersEXT_remap_index, -1 },
     { GenFramebuffersEXT_names, GenFramebuffersEXT_remap_index, -1 },
     { BindRenderbufferEXT_names, BindRenderbufferEXT_remap_index, -1 },
+    { DeleteRenderbuffersEXT_names, DeleteRenderbuffersEXT_remap_index, -1 },
     { GetRenderbufferParameterivEXT_names, GetRenderbufferParameterivEXT_remap_index, -1 },
+    { IsRenderbufferEXT_names, IsRenderbufferEXT_remap_index, -1 },
     { NULL, 0, 0 }
 };
 #endif
@@ -5415,8 +5467,8 @@ static const struct dri_extension_function GL_EXT_paletted_texture_functions[] =
 #if defined(need_GL_EXT_pixel_transform)
 static const struct dri_extension_function GL_EXT_pixel_transform_functions[] = {
     { PixelTransformParameterfvEXT_names, PixelTransformParameterfvEXT_remap_index, -1 },
-    { PixelTransformParameteriEXT_names, PixelTransformParameteriEXT_remap_index, -1 },
     { PixelTransformParameterfEXT_names, PixelTransformParameterfEXT_remap_index, -1 },
+    { PixelTransformParameteriEXT_names, PixelTransformParameteriEXT_remap_index, -1 },
     { PixelTransformParameterivEXT_names, PixelTransformParameterivEXT_remap_index, -1 },
     { NULL, 0, 0 }
 };
@@ -5716,8 +5768,8 @@ static const struct dri_extension_function GL_NV_register_combiners2_functions[]
 
 #if defined(need_GL_NV_vertex_array_range)
 static const struct dri_extension_function GL_NV_vertex_array_range_functions[] = {
-    { FlushVertexArrayRangeNV_names, FlushVertexArrayRangeNV_remap_index, -1 },
     { VertexArrayRangeNV_names, VertexArrayRangeNV_remap_index, -1 },
+    { FlushVertexArrayRangeNV_names, FlushVertexArrayRangeNV_remap_index, -1 },
     { NULL, 0, 0 }
 };
 #endif
@@ -5946,11 +5998,11 @@ static const struct dri_extension_function GL_SGIX_instruments_functions[] = {
 #if defined(need_GL_SGIX_list_priority)
 static const struct dri_extension_function GL_SGIX_list_priority_functions[] = {
     { ListParameterfSGIX_names, ListParameterfSGIX_remap_index, -1 },
-    { GetListParameterivSGIX_names, GetListParameterivSGIX_remap_index, -1 },
     { GetListParameterfvSGIX_names, GetListParameterfvSGIX_remap_index, -1 },
     { ListParameteriSGIX_names, ListParameteriSGIX_remap_index, -1 },
     { ListParameterfvSGIX_names, ListParameterfvSGIX_remap_index, -1 },
     { ListParameterivSGIX_names, ListParameterivSGIX_remap_index, -1 },
+    { GetListParameterivSGIX_names, GetListParameterivSGIX_remap_index, -1 },
     { NULL, 0, 0 }
 };
 #endif
@@ -5965,9 +6017,9 @@ static const struct dri_extension_function GL_SGIX_pixel_texture_functions[] = {
 #if defined(need_GL_SGIX_polynomial_ffd)
 static const struct dri_extension_function GL_SGIX_polynomial_ffd_functions[] = {
     { LoadIdentityDeformationMapSGIX_names, LoadIdentityDeformationMapSGIX_remap_index, -1 },
-    { DeformationMap3dSGIX_names, DeformationMap3dSGIX_remap_index, -1 },
     { DeformSGIX_names, DeformSGIX_remap_index, -1 },
     { DeformationMap3fSGIX_names, DeformationMap3fSGIX_remap_index, -1 },
+    { DeformationMap3dSGIX_names, DeformationMap3dSGIX_remap_index, -1 },
     { NULL, 0, 0 }
 };
 #endif
diff --git a/src/mesa/drivers/dri/common/utils.c b/src/mesa/drivers/dri/common/utils.c
index 30c860b..6b44ed9 100644
--- a/src/mesa/drivers/dri/common/utils.c
+++ b/src/mesa/drivers/dri/common/utils.c
@@ -179,13 +179,18 @@ driGetRendererString( char * buffer, const char * hardware_name,
 
 
 
+#define need_GL_ARB_draw_buffers
 #define need_GL_ARB_multisample
+#define need_GL_ARB_texture_compression
 #define need_GL_ARB_transpose_matrix
+#define need_GL_ARB_vertex_buffer_object
 #define need_GL_ARB_window_pos
 #define need_GL_EXT_compiled_vertex_array
+#define need_GL_EXT_multi_draw_arrays
 #define need_GL_EXT_polygon_offset
 #define need_GL_EXT_texture_object
 #define need_GL_EXT_vertex_array
+#define need_GL_IBM_multimode_draw_arrays
 #define need_GL_MESA_window_pos
 
 /* These are needed in *all* drivers because Mesa internally implements
@@ -198,14 +203,19 @@ driGetRendererString( char * buffer, const char * hardware_name,
 #include "extension_helper.h"
 
 static const struct dri_extension all_mesa_extensions[] = {
+   { "GL_ARB_draw_buffers",          GL_ARB_draw_buffers_functions },
    { "GL_ARB_multisample",           GL_ARB_multisample_functions },
+   { "GL_ARB_texture_compression",   GL_ARB_texture_compression_functions },
    { "GL_ARB_transpose_matrix",      GL_ARB_transpose_matrix_functions },
+   { "GL_ARB_vertex_buffer_object",  GL_ARB_vertex_buffer_object_functions},
    { "GL_ARB_window_pos",            GL_ARB_window_pos_functions },
    { "GL_EXT_blend_func_separate",   GL_EXT_blend_func_separate_functions },
    { "GL_EXT_compiled_vertex_array", GL_EXT_compiled_vertex_array_functions },
+   { "GL_EXT_multi_draw_arrays",     GL_EXT_multi_draw_arrays_functions },
    { "GL_EXT_polygon_offset",        GL_EXT_polygon_offset_functions },
    { "GL_EXT_texture_object",        GL_EXT_texture_object_functions },
    { "GL_EXT_vertex_array",          GL_EXT_vertex_array_functions },
+   { "GL_IBM_multimode_draw_arrays", GL_IBM_multimode_draw_arrays_functions },
    { "GL_MESA_window_pos",           GL_MESA_window_pos_functions },
    { "GL_NV_vertex_program",         GL_NV_vertex_program_functions },
    { NULL,                           NULL }
@@ -310,8 +320,10 @@ void driInitSingleExtension( GLcontext * ctx,
 	     */
 	    offset = _glapi_add_dispatch( functions, parameter_signature );
 	    if (offset == -1) {
+#if 0 /* this causes noise with egl */
 		fprintf(stderr, "DISPATCH ERROR! _glapi_add_dispatch failed "
 			"to add %s!\n", functions[0]);
+#endif
 	    }
 	    else if (ext->functions[i].remap_index != -1) {
 		driDispatchRemapTable[ ext->functions[i].remap_index ] = 
@@ -504,6 +516,9 @@ GLboolean driClipRectToFramebuffer( const GLframebuffer *buffer,
  *                      \c GLX_SWAP_UNDEFINED_OML.  See the
  *                      GLX_OML_swap_method extension spec for more details.
  * \param num_db_modes  Number of entries in \c db_modes.
+ * \param msaa_samples  Array of msaa sample count. 0 represents a visual
+ *                      without a multisample buffer.
+ * \param num_msaa_modes Number of entries in \c msaa_samples.
  * \param visType       GLX visual type.  Usually either \c GLX_TRUE_COLOR or
  *                      \c GLX_DIRECT_COLOR.
  * 
@@ -523,7 +538,8 @@ __DRIconfig **
 driCreateConfigs(GLenum fb_format, GLenum fb_type,
 		 const uint8_t * depth_bits, const uint8_t * stencil_bits,
 		 unsigned num_depth_stencil_bits,
-		 const GLenum * db_modes, unsigned num_db_modes)
+		 const GLenum * db_modes, unsigned num_db_modes,
+	 	 const u_int8_t * msaa_samples, unsigned num_msaa_modes)
 {
    static const uint8_t bits_table[4][4] = {
      /* R  G  B  A */
@@ -583,9 +599,7 @@ driCreateConfigs(GLenum fb_format, GLenum fb_type,
    int index;
    __DRIconfig **configs, **c;
    __GLcontextModes *modes;
-   unsigned i;
-   unsigned j;
-   unsigned k;
+   unsigned i, j, k, h;
    unsigned num_modes;
    unsigned num_accum_bits = 2;
 
@@ -658,7 +672,7 @@ driCreateConfigs(GLenum fb_format, GLenum fb_type,
 	 break;
    }
 
-   num_modes = num_depth_stencil_bits * num_db_modes * num_accum_bits;
+   num_modes = num_depth_stencil_bits * num_db_modes * num_accum_bits * num_msaa_modes;
    configs = _mesa_calloc((num_modes + 1) * sizeof *configs);
    if (configs == NULL)
        return NULL;
@@ -666,66 +680,72 @@ driCreateConfigs(GLenum fb_format, GLenum fb_type,
     c = configs;
     for ( k = 0 ; k < num_depth_stencil_bits ; k++ ) {
 	for ( i = 0 ; i < num_db_modes ; i++ ) {
-	    for ( j = 0 ; j < num_accum_bits ; j++ ) {
-		*c = _mesa_malloc (sizeof **c);
-		modes = &(*c)->modes;
-		c++;
-
-		memset(modes, 0, sizeof *modes);
-		modes->redBits   = bits[0];
-		modes->greenBits = bits[1];
-		modes->blueBits  = bits[2];
-		modes->alphaBits = bits[3];
-		modes->redMask   = masks[0];
-		modes->greenMask = masks[1];
-		modes->blueMask  = masks[2];
-		modes->alphaMask = masks[3];
-		modes->rgbBits   = modes->redBits + modes->greenBits
-		    + modes->blueBits + modes->alphaBits;
-
-		modes->accumRedBits   = 16 * j;
-		modes->accumGreenBits = 16 * j;
-		modes->accumBlueBits  = 16 * j;
-		modes->accumAlphaBits = (masks[3] != 0) ? 16 * j : 0;
-		modes->visualRating = (j == 0) ? GLX_NONE : GLX_SLOW_CONFIG;
-
-		modes->stencilBits = stencil_bits[k];
-		modes->depthBits = depth_bits[k];
-
-		modes->transparentPixel = GLX_NONE;
-		modes->transparentRed = GLX_DONT_CARE;
-		modes->transparentGreen = GLX_DONT_CARE;
-		modes->transparentBlue = GLX_DONT_CARE;
-		modes->transparentAlpha = GLX_DONT_CARE;
-		modes->transparentIndex = GLX_DONT_CARE;
-		modes->visualType = GLX_DONT_CARE;
-		modes->renderType = GLX_RGBA_BIT;
-		modes->drawableType = GLX_WINDOW_BIT;
-		modes->rgbMode = GL_TRUE;
-
-		if ( db_modes[i] == GLX_NONE ) {
-		    modes->doubleBufferMode = GL_FALSE;
-		}
-		else {
-		    modes->doubleBufferMode = GL_TRUE;
-		    modes->swapMethod = db_modes[i];
-		}
-
-		modes->haveAccumBuffer = ((modes->accumRedBits +
+	    for ( h = 0 ; h < num_msaa_modes; h++ ) {
+	    	for ( j = 0 ; j < num_accum_bits ; j++ ) {
+		    *c = _mesa_malloc (sizeof **c);
+		    modes = &(*c)->modes;
+		    c++;
+
+		    memset(modes, 0, sizeof *modes);
+		    modes->redBits   = bits[0];
+		    modes->greenBits = bits[1];
+		    modes->blueBits  = bits[2];
+		    modes->alphaBits = bits[3];
+		    modes->redMask   = masks[0];
+		    modes->greenMask = masks[1];
+		    modes->blueMask  = masks[2];
+		    modes->alphaMask = masks[3];
+		    modes->rgbBits   = modes->redBits + modes->greenBits
+		    	+ modes->blueBits + modes->alphaBits;
+
+		    modes->accumRedBits   = 16 * j;
+		    modes->accumGreenBits = 16 * j;
+		    modes->accumBlueBits  = 16 * j;
+		    modes->accumAlphaBits = (masks[3] != 0) ? 16 * j : 0;
+		    modes->visualRating = (j == 0) ? GLX_NONE : GLX_SLOW_CONFIG;
+
+		    modes->stencilBits = stencil_bits[k];
+		    modes->depthBits = depth_bits[k];
+
+		    modes->transparentPixel = GLX_NONE;
+		    modes->transparentRed = GLX_DONT_CARE;
+		    modes->transparentGreen = GLX_DONT_CARE;
+		    modes->transparentBlue = GLX_DONT_CARE;
+		    modes->transparentAlpha = GLX_DONT_CARE;
+		    modes->transparentIndex = GLX_DONT_CARE;
+		    modes->visualType = GLX_DONT_CARE;
+		    modes->renderType = GLX_RGBA_BIT;
+		    modes->drawableType = GLX_WINDOW_BIT;
+		    modes->rgbMode = GL_TRUE;
+
+		    if ( db_modes[i] == GLX_NONE ) {
+		    	modes->doubleBufferMode = GL_FALSE;
+		    }
+		    else {
+		    	modes->doubleBufferMode = GL_TRUE;
+		    	modes->swapMethod = db_modes[i];
+		    }
+
+		    modes->samples = msaa_samples[h];
+		    modes->sampleBuffers = modes->samples ? 1 : 0;
+
+
+		    modes->haveAccumBuffer = ((modes->accumRedBits +
 					   modes->accumGreenBits +
 					   modes->accumBlueBits +
 					   modes->accumAlphaBits) > 0);
-		modes->haveDepthBuffer = (modes->depthBits > 0);
-		modes->haveStencilBuffer = (modes->stencilBits > 0);
-
-		modes->bindToTextureRgb = GL_TRUE;
-		modes->bindToTextureRgba = GL_TRUE;
-		modes->bindToMipmapTexture = GL_FALSE;
-		modes->bindToTextureTargets = modes->rgbMode ?
-		    __DRI_ATTRIB_TEXTURE_1D_BIT |
-		    __DRI_ATTRIB_TEXTURE_2D_BIT |
-		    __DRI_ATTRIB_TEXTURE_RECTANGLE_BIT :
-		    0;
+		    modes->haveDepthBuffer = (modes->depthBits > 0);
+		    modes->haveStencilBuffer = (modes->stencilBits > 0);
+
+		    modes->bindToTextureRgb = GL_TRUE;
+		    modes->bindToTextureRgba = GL_TRUE;
+		    modes->bindToMipmapTexture = GL_FALSE;
+		    modes->bindToTextureTargets = modes->rgbMode ?
+		    	__DRI_ATTRIB_TEXTURE_1D_BIT |
+		    	__DRI_ATTRIB_TEXTURE_2D_BIT |
+		    	__DRI_ATTRIB_TEXTURE_RECTANGLE_BIT :
+		    	0;
+		}
 	    }
 	}
     }
@@ -734,9 +754,10 @@ driCreateConfigs(GLenum fb_format, GLenum fb_type,
     return configs;
 }
 
-const __DRIconfig **driConcatConfigs(__DRIconfig **a, __DRIconfig **b)
+__DRIconfig **driConcatConfigs(__DRIconfig **a,
+			       __DRIconfig **b)
 {
-    const __DRIconfig **all;
+    __DRIconfig **all;
     int i, j, index;
 
     i = 0;
diff --git a/src/mesa/drivers/dri/common/utils.h b/src/mesa/drivers/dri/common/utils.h
index 0c974db..9e9e5bc 100644
--- a/src/mesa/drivers/dri/common/utils.h
+++ b/src/mesa/drivers/dri/common/utils.h
@@ -131,9 +131,11 @@ extern __DRIconfig **
 driCreateConfigs(GLenum fb_format, GLenum fb_type,
 		 const uint8_t * depth_bits, const uint8_t * stencil_bits,
 		 unsigned num_depth_stencil_bits,
-		 const GLenum * db_modes, unsigned num_db_modes);
+		 const GLenum * db_modes, unsigned num_db_modes,
+    		 const uint8_t * msaa_samples, unsigned num_msaa_modes);
 
-const __DRIconfig **driConcatConfigs(__DRIconfig **a, __DRIconfig **b);
+__DRIconfig **driConcatConfigs(__DRIconfig **a,
+			       __DRIconfig **b);
 
 int
 driGetConfigAttrib(const __DRIconfig *config,
diff --git a/src/mesa/drivers/dri/ffb/ffb_xmesa.c b/src/mesa/drivers/dri/ffb/ffb_xmesa.c
index 679f856..00bdcec 100644
--- a/src/mesa/drivers/dri/ffb/ffb_xmesa.c
+++ b/src/mesa/drivers/dri/ffb/ffb_xmesa.c
@@ -260,6 +260,8 @@ ffbCreateContext(const __GLcontextModes *mesaVis,
 	ctx->Const.MaxLineWidthAA = 1.0;
 	ctx->Const.LineWidthGranularity = 1.0;
 
+	ctx->Const.MaxDrawBuffers = 1;
+
 	/* Instead of having GCC emit these constants a zillion times
 	 * everywhere in the driver, put them here.
 	 */
@@ -626,6 +628,7 @@ ffbFillInModes( __DRIscreenPrivate *psp,
 
    uint8_t depth_bits_array[3];
    uint8_t stencil_bits_array[3];
+   uint8_t msaa_samples_array[1];
 
    depth_bits_array[0] = 0;
    depth_bits_array[1] = depth_bits;
@@ -639,6 +642,8 @@ ffbFillInModes( __DRIscreenPrivate *psp,
    stencil_bits_array[1] = 0;
    stencil_bits_array[2] = (stencil_bits == 0) ? 8 : stencil_bits;
 
+   msaa_samples_array[0] = 0;
+
    depth_buffer_factor = ((depth_bits != 0) || (stencil_bits != 0)) ? 3 : 1;
    back_buffer_factor  = (have_back_buffer) ? 3 : 1;
 
@@ -654,9 +659,10 @@ ffbFillInModes( __DRIscreenPrivate *psp,
    configs = driCreateConfigs(fb_format, fb_type,
 			      depth_bits_array, stencil_bits_array,
 			      depth_buffer_factor, back_buffer_modes,
-			      back_buffer_factor);
+			      back_buffer_factor,
+                               msaa_samples_array, 1);
    if (configs == NULL) {
-    fprintf(stderr, "[%s:%u] Error creating FBConfig!\n", __func__,
+      fprintf(stderr, "[%s:%u] Error creating FBConfig!\n", __func__,
               __LINE__);
       return NULL;
    }
diff --git a/src/mesa/drivers/dri/gamma/gamma_context.c b/src/mesa/drivers/dri/gamma/gamma_context.c
index c91bedc..b0ac299 100644
--- a/src/mesa/drivers/dri/gamma/gamma_context.c
+++ b/src/mesa/drivers/dri/gamma/gamma_context.c
@@ -133,6 +133,8 @@ GLboolean gammaCreateContext( const __GLcontextModes *glVisual,
    ctx->Const.MaxPointSizeAA = 16.0; 
    ctx->Const.PointSizeGranularity = 0.25;
 
+   ctx->Const.MaxDrawBuffers = 1;
+
    gmesa->texHeap = mmInit( 0, gmesa->gammaScreen->textureSize );
 
    make_empty_list(&gmesa->TexObjList);
diff --git a/src/mesa/drivers/dri/glcore/Makefile b/src/mesa/drivers/dri/glcore/Makefile
new file mode 100644
index 0000000..ac7e1de
--- /dev/null
+++ b/src/mesa/drivers/dri/glcore/Makefile
@@ -0,0 +1,84 @@
+# src/mesa/drivers/dri/glcore/Makefile
+
+TOP = ../../../../..
+include $(TOP)/configs/current
+
+LIBNAME = glcore_dri.so
+
+DRIVER_SOURCES = glcore_driver.c \
+		 $(TOP)/src/mesa/drivers/common/driverfuncs.c \
+		 ../common/dri_util.c
+
+C_SOURCES = \
+	$(DRIVER_SOURCES) \
+	$(DRI_SOURCES) 
+
+
+# Include directories
+INCLUDE_DIRS = \
+	-I. \
+	-I../common \
+	-I../dri_client \
+	-I../dri_client/imports \
+	-Iserver \
+	-I$(TOP)/include \
+	-I$(DRM_SOURCE_PATH)/shared-core \
+	-I$(TOP)/src/mesa \
+	-I$(TOP)/src/mesa/main \
+	-I$(TOP)/src/mesa/glapi \
+	-I$(TOP)/src/mesa/math \
+	-I$(TOP)/src/mesa/transform \
+	-I$(TOP)/src/mesa/shader \
+	-I$(TOP)/src/mesa/swrast \
+	-I$(TOP)/src/mesa/swrast_setup
+
+# Core Mesa objects
+MESA_MODULES = $(TOP)/src/mesa/libmesa.a
+
+# Libraries that the driver shared lib depends on
+LIB_DEPS = -lm -lpthread -lc
+# LIB_DEPS = -lGL -lm -lpthread -lc
+
+
+ASM_SOURCES = 
+
+OBJECTS = $(C_SOURCES:.c=.o) \
+	  $(ASM_SOURCES:.S=.o) 
+
+
+##### RULES #####
+
+.c.o:
+	$(CC) -c $(INCLUDE_DIRS) $(CFLAGS) $(DEFINES) $< -o $@
+
+.S.o:
+	$(CC) -c $(INCLUDE_DIRS) $(CFLAGS) $(DEFINES)  $< -o $@
+
+
+##### TARGETS #####
+
+default: depend $(TOP)/$(LIB_DIR)/$(LIBNAME)
+
+
+$(TOP)/$(LIB_DIR)/$(LIBNAME): $(OBJECTS) $(MESA_MODULES) $(WINOBJ) Makefile
+	CC="$(CC)" CXX="$(CXX)" $(TOP)/bin/mklib -o $(LIBNAME) -noprefix -install $(TOP)/$(LIB_DIR) \
+		$(OBJECTS) $(WINLIB) $(LIB_DEPS) $(WINOBJ) $(MESA_MODULES)
+
+
+depend: $(C_SOURCES) $(ASM_SOURCES)
+	rm -f depend
+	touch depend
+	$(MKDEP) $(MKDEP_OPTIONS) $(INCLUDE_DIRS) $(C_SOURCES) $(ASM_SOURCES) \
+		> /dev/null 
+
+
+# Emacs tags
+tags:
+	etags `find . -name \*.[ch]` `find ../include`
+
+
+clean:
+	-rm -f *.o server/*.o
+
+
+include depend
diff --git a/src/mesa/drivers/dri/i810/i810context.c b/src/mesa/drivers/dri/i810/i810context.c
index c281a49..6785655 100644
--- a/src/mesa/drivers/dri/i810/i810context.c
+++ b/src/mesa/drivers/dri/i810/i810context.c
@@ -63,11 +63,6 @@ SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "drirenderbuffer.h"
 #include "utils.h"
 
-#define need_GL_ARB_multisample
-#define need_GL_ARB_texture_compression
-#define need_GL_ARB_vertex_buffer_object
-#include "extension_helper.h"
-
 #ifndef I810_DEBUG
 int I810_DEBUG = (0);
 #endif
@@ -123,14 +118,11 @@ static void i810BufferSize(GLframebuffer *buffer, GLuint *width, GLuint *height)
  */
 const struct dri_extension card_extensions[] =
 {
-    { "GL_ARB_multisample",                GL_ARB_multisample_functions },
     { "GL_ARB_multitexture",               NULL },
-    { "GL_ARB_texture_compression",        GL_ARB_texture_compression_functions },
     { "GL_ARB_texture_env_add",            NULL },
     { "GL_ARB_texture_env_combine",        NULL },
     { "GL_ARB_texture_env_crossbar",       NULL },
     { "GL_ARB_texture_mirrored_repeat",    NULL },
-    { "GL_ARB_vertex_buffer_object",       GL_ARB_vertex_buffer_object_functions },
     { "GL_EXT_stencil_wrap",               NULL },
     { "GL_EXT_texture_edge_clamp",         NULL },
     { "GL_EXT_texture_env_combine",        NULL },
diff --git a/src/mesa/drivers/dri/i810/i810screen.c b/src/mesa/drivers/dri/i810/i810screen.c
index 48603f5..9a5a39c 100644
--- a/src/mesa/drivers/dri/i810/i810screen.c
+++ b/src/mesa/drivers/dri/i810/i810screen.c
@@ -77,6 +77,7 @@ i810FillInModes( __DRIscreenPrivate *psp,
 
     uint8_t depth_bits_array[2];
     uint8_t stencil_bits_array[2];
+    uint8_t msaa_samples_array[1];
 
     depth_bits_array[0] = depth_bits;
     depth_bits_array[1] = depth_bits;
@@ -88,13 +89,16 @@ i810FillInModes( __DRIscreenPrivate *psp,
     stencil_bits_array[0] = 0;
     stencil_bits_array[1] = (stencil_bits == 0) ? 8 : stencil_bits;
 
+    msaa_samples_array[0] = 0;
+
     depth_buffer_factor = ((depth_bits != 0) || (stencil_bits != 0)) ? 2 : 1;
     back_buffer_factor  = (have_back_buffer) ? 2 : 1;
 
     configs = driCreateConfigs(GL_RGB, GL_UNSIGNED_SHORT_5_6_5,
 			       depth_bits_array, stencil_bits_array,
 			       depth_buffer_factor,
-			       back_buffer_modes, back_buffer_factor);
+			       back_buffer_modes, back_buffer_factor,
+                               msaa_samples_array, 1);
     if (configs == NULL) {
 	fprintf( stderr, "[%s:%u] Error creating FBConfig!\n",
 		 __func__, __LINE__ );
diff --git a/src/mesa/drivers/dri/i915/Makefile b/src/mesa/drivers/dri/i915/Makefile
index 5858e0e..954a7e2 100644
--- a/src/mesa/drivers/dri/i915/Makefile
+++ b/src/mesa/drivers/dri/i915/Makefile
@@ -18,8 +18,9 @@ DRIVER_SOURCES = \
 	intel_regions.c \
 	intel_buffer_objects.c \
 	intel_batchbuffer.c \
+	intel_clear.c \
+	intel_extensions.c \
 	intel_mipmap_tree.c \
-	i915_tex_layout.c \
 	intel_tex_layout.c \
 	intel_tex_image.c \
 	intel_tex_subimage.c \
@@ -34,7 +35,9 @@ DRIVER_SOURCES = \
 	intel_pixel_read.c \
 	intel_buffers.c \
 	intel_blit.c \
+	intel_swapbuffers.c \
 	i915_tex.c \
+	i915_tex_layout.c \
 	i915_texstate.c \
 	i915_context.c \
 	i915_debug.c \
@@ -50,8 +53,7 @@ DRIVER_SOURCES = \
 	intel_span.c \
 	intel_state.c \
 	intel_tris.c \
-	intel_fbo.c \
-	intel_depthstencil.c
+	intel_fbo.c
 
 C_SOURCES = \
 	$(COMMON_SOURCES) \
diff --git a/src/mesa/drivers/dri/i915/i830_context.c b/src/mesa/drivers/dri/i915/i830_context.c
index 09b1ec9..9c540cb 100644
--- a/src/mesa/drivers/dri/i915/i830_context.c
+++ b/src/mesa/drivers/dri/i915/i830_context.c
@@ -73,6 +73,8 @@ i830CreateContext(const __GLcontextModes * mesaVis,
       return GL_FALSE;
    }
 
+   _math_matrix_ctr(&intel->ViewportMatrix);
+
    /* Initialize swrast, tnl driver tables: */
    intelInitSpanFuncs(ctx);
    intelInitTriFuncs(ctx);
@@ -97,6 +99,8 @@ i830CreateContext(const __GLcontextModes * mesaVis,
    ctx->Const.MaxTextureRectSize = (1 << 11);
    ctx->Const.MaxTextureUnits = I830_TEX_UNITS;
 
+   ctx->Const.MaxDrawBuffers = 1;
+
    _tnl_init_vertices(ctx, ctx->Const.MaxArrayLockSize + 12,
                       18 * sizeof(GLfloat));
 
diff --git a/src/mesa/drivers/dri/i915/i915_context.c b/src/mesa/drivers/dri/i915/i915_context.c
index 3d6af38..7549029 100644
--- a/src/mesa/drivers/dri/i915/i915_context.c
+++ b/src/mesa/drivers/dri/i915/i915_context.c
@@ -50,16 +50,6 @@
  * Mesa's Driver Functions
  ***************************************/
 
-static const struct dri_extension i915_extensions[] = {
-   {"GL_ARB_depth_texture", NULL},
-   {"GL_ARB_fragment_program", NULL},
-   {"GL_ARB_shadow", NULL},
-   {"GL_ARB_texture_non_power_of_two", NULL},
-   {"GL_ATI_texture_env_combine3",       NULL},
-   {"GL_EXT_shadow_funcs", NULL},
-   {NULL, NULL}
-};
-
 /* Override intel default.
  */
 static void
@@ -129,6 +119,8 @@ i915CreateContext(const __GLcontextModes * mesaVis,
       return GL_FALSE;
    }
 
+   _math_matrix_ctr(&intel->ViewportMatrix);
+
    /* Initialize swrast, tnl driver tables: */
    intelInitSpanFuncs(ctx);
    intelInitTriFuncs(ctx);
@@ -172,8 +164,7 @@ i915CreateContext(const __GLcontextModes * mesaVis,
 
    ctx->FragmentProgram._MaintainTexEnvProgram = GL_TRUE;
 
-   driInitExtensions(ctx, i915_extensions, GL_FALSE);
-
+   ctx->Const.MaxDrawBuffers = 1;
 
    _tnl_init_vertices(ctx, ctx->Const.MaxArrayLockSize + 12,
                       36 * sizeof(GLfloat));
diff --git a/src/mesa/drivers/dri/i915/i915_state.c b/src/mesa/drivers/dri/i915/i915_state.c
index a53f120..814fb59 100644
--- a/src/mesa/drivers/dri/i915/i915_state.c
+++ b/src/mesa/drivers/dri/i915/i915_state.c
@@ -41,6 +41,7 @@
 #include "intel_fbo.h"
 #include "intel_screen.h"
 #include "intel_batchbuffer.h"
+#include "intel_buffers.h"
 
 #include "i915_context.h"
 #include "i915_reg.h"
@@ -301,6 +302,65 @@ i915DepthMask(GLcontext * ctx, GLboolean flag)
       i915->state.Ctx[I915_CTXREG_LIS6] &= ~S6_DEPTH_WRITE_ENABLE;
 }
 
+
+
+/**
+ * Update the viewport transformation matrix.  Depends on:
+ *  - viewport pos/size
+ *  - depthrange
+ *  - window pos/size or FBO size
+ */
+void
+intelCalcViewport(GLcontext * ctx)
+{
+   struct intel_context *intel = intel_context(ctx);
+   const GLfloat *v = ctx->Viewport._WindowMap.m;
+   const GLfloat depthScale = 1.0F / ctx->DrawBuffer->_DepthMaxF;
+   GLfloat *m = intel->ViewportMatrix.m;
+   GLfloat yScale, yBias;
+
+   if (ctx->DrawBuffer->Name) {
+      /* User created FBO */
+      /* y=0=bottom */
+      yScale = 1.0;
+      yBias = 0.0;
+   }
+   else {
+      /* window buffer, y=0=top */
+      yScale = -1.0;
+      yBias = (intel->driDrawable) ? intel->driDrawable->h : 0.0F;
+   }
+
+   m[MAT_SX] = v[MAT_SX];
+   m[MAT_TX] = v[MAT_TX];
+
+   m[MAT_SY] = v[MAT_SY] * yScale;
+   m[MAT_TY] = v[MAT_TY] * yScale + yBias;
+
+   m[MAT_SZ] = v[MAT_SZ] * depthScale;
+   m[MAT_TZ] = v[MAT_TZ] * depthScale;
+}
+
+
+/** Called from ctx->Driver.Viewport() */
+static void
+i915Viewport(GLcontext * ctx,
+              GLint x, GLint y, GLsizei width, GLsizei height)
+{
+   intelCalcViewport(ctx);
+
+   intel_viewport(ctx, x, y, width, height);
+}
+
+
+/** Called from ctx->Driver.DepthRange() */
+static void
+i915DepthRange(GLcontext * ctx, GLclampd nearval, GLclampd farval)
+{
+   intelCalcViewport(ctx);
+}
+
+
 /* =============================================================
  * Polygon stipple
  *
@@ -964,6 +1024,8 @@ i915InitStateFunctions(struct dd_function_table *functions)
    functions->StencilFuncSeparate = i915StencilFuncSeparate;
    functions->StencilMaskSeparate = i915StencilMaskSeparate;
    functions->StencilOpSeparate = i915StencilOpSeparate;
+   functions->DepthRange = i915DepthRange;
+   functions->Viewport = i915Viewport;
 }
 
 
diff --git a/src/mesa/drivers/dri/i915/intel_state.c b/src/mesa/drivers/dri/i915/intel_state.c
deleted file mode 100644
index 4aa43e5..519672f
--- a/src/mesa/drivers/dri/i915/intel_state.c
+++ /dev/null
@@ -1,297 +0,0 @@
-/**************************************************************************
- * 
- * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
- * All Rights Reserved.
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- * 
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- * 
- **************************************************************************/
-
-
-#include "main/glheader.h"
-#include "main/context.h"
-#include "main/macros.h"
-#include "main/enums.h"
-#include "main/colormac.h"
-#include "main/dd.h"
-
-#include "intel_screen.h"
-#include "intel_context.h"
-#include "intel_fbo.h"
-#include "intel_regions.h"
-#include "swrast/swrast.h"
-
-int 
-intel_translate_shadow_compare_func( GLenum func )
-{
-   switch(func) {
-   case GL_NEVER: 
-       return COMPAREFUNC_ALWAYS; 
-   case GL_LESS: 
-       return COMPAREFUNC_LEQUAL; 
-   case GL_LEQUAL: 
-       return COMPAREFUNC_LESS;
-   case GL_GREATER: 
-       return COMPAREFUNC_GEQUAL; 
-   case GL_GEQUAL: 
-      return COMPAREFUNC_GREATER; 
-   case GL_NOTEQUAL: 
-      return COMPAREFUNC_EQUAL; 
-   case GL_EQUAL: 
-      return COMPAREFUNC_NOTEQUAL; 
-   case GL_ALWAYS: 
-       return COMPAREFUNC_NEVER; 
-   }
-
-   fprintf(stderr, "Unknown value in %s: %x\n", __FUNCTION__, func);
-   return COMPAREFUNC_NEVER; 
-}
-
-int
-intel_translate_compare_func(GLenum func)
-{
-   switch (func) {
-   case GL_NEVER:
-      return COMPAREFUNC_NEVER;
-   case GL_LESS:
-      return COMPAREFUNC_LESS;
-   case GL_LEQUAL:
-      return COMPAREFUNC_LEQUAL;
-   case GL_GREATER:
-      return COMPAREFUNC_GREATER;
-   case GL_GEQUAL:
-      return COMPAREFUNC_GEQUAL;
-   case GL_NOTEQUAL:
-      return COMPAREFUNC_NOTEQUAL;
-   case GL_EQUAL:
-      return COMPAREFUNC_EQUAL;
-   case GL_ALWAYS:
-      return COMPAREFUNC_ALWAYS;
-   }
-
-   fprintf(stderr, "Unknown value in %s: %x\n", __FUNCTION__, func);
-   return COMPAREFUNC_ALWAYS;
-}
-
-int
-intel_translate_stencil_op(GLenum op)
-{
-   switch (op) {
-   case GL_KEEP:
-      return STENCILOP_KEEP;
-   case GL_ZERO:
-      return STENCILOP_ZERO;
-   case GL_REPLACE:
-      return STENCILOP_REPLACE;
-   case GL_INCR:
-      return STENCILOP_INCRSAT;
-   case GL_DECR:
-      return STENCILOP_DECRSAT;
-   case GL_INCR_WRAP:
-      return STENCILOP_INCR;
-   case GL_DECR_WRAP:
-      return STENCILOP_DECR;
-   case GL_INVERT:
-      return STENCILOP_INVERT;
-   default:
-      return STENCILOP_ZERO;
-   }
-}
-
-int
-intel_translate_blend_factor(GLenum factor)
-{
-   switch (factor) {
-   case GL_ZERO:
-      return BLENDFACT_ZERO;
-   case GL_SRC_ALPHA:
-      return BLENDFACT_SRC_ALPHA;
-   case GL_ONE:
-      return BLENDFACT_ONE;
-   case GL_SRC_COLOR:
-      return BLENDFACT_SRC_COLR;
-   case GL_ONE_MINUS_SRC_COLOR:
-      return BLENDFACT_INV_SRC_COLR;
-   case GL_DST_COLOR:
-      return BLENDFACT_DST_COLR;
-   case GL_ONE_MINUS_DST_COLOR:
-      return BLENDFACT_INV_DST_COLR;
-   case GL_ONE_MINUS_SRC_ALPHA:
-      return BLENDFACT_INV_SRC_ALPHA;
-   case GL_DST_ALPHA:
-      return BLENDFACT_DST_ALPHA;
-   case GL_ONE_MINUS_DST_ALPHA:
-      return BLENDFACT_INV_DST_ALPHA;
-   case GL_SRC_ALPHA_SATURATE:
-      return BLENDFACT_SRC_ALPHA_SATURATE;
-   case GL_CONSTANT_COLOR:
-      return BLENDFACT_CONST_COLOR;
-   case GL_ONE_MINUS_CONSTANT_COLOR:
-      return BLENDFACT_INV_CONST_COLOR;
-   case GL_CONSTANT_ALPHA:
-      return BLENDFACT_CONST_ALPHA;
-   case GL_ONE_MINUS_CONSTANT_ALPHA:
-      return BLENDFACT_INV_CONST_ALPHA;
-   }
-
-   fprintf(stderr, "Unknown value in %s: %x\n", __FUNCTION__, factor);
-   return BLENDFACT_ZERO;
-}
-
-int
-intel_translate_logic_op(GLenum opcode)
-{
-   switch (opcode) {
-   case GL_CLEAR:
-      return LOGICOP_CLEAR;
-   case GL_AND:
-      return LOGICOP_AND;
-   case GL_AND_REVERSE:
-      return LOGICOP_AND_RVRSE;
-   case GL_COPY:
-      return LOGICOP_COPY;
-   case GL_COPY_INVERTED:
-      return LOGICOP_COPY_INV;
-   case GL_AND_INVERTED:
-      return LOGICOP_AND_INV;
-   case GL_NOOP:
-      return LOGICOP_NOOP;
-   case GL_XOR:
-      return LOGICOP_XOR;
-   case GL_OR:
-      return LOGICOP_OR;
-   case GL_OR_INVERTED:
-      return LOGICOP_OR_INV;
-   case GL_NOR:
-      return LOGICOP_NOR;
-   case GL_EQUIV:
-      return LOGICOP_EQUIV;
-   case GL_INVERT:
-      return LOGICOP_INV;
-   case GL_OR_REVERSE:
-      return LOGICOP_OR_RVRSE;
-   case GL_NAND:
-      return LOGICOP_NAND;
-   case GL_SET:
-      return LOGICOP_SET;
-   default:
-      return LOGICOP_SET;
-   }
-}
-
-
-static void
-intelClearColor(GLcontext * ctx, const GLfloat color[4])
-{
-   struct intel_context *intel = intel_context(ctx);
-   GLubyte clear[4];
-
-   CLAMPED_FLOAT_TO_UBYTE(clear[0], color[0]);
-   CLAMPED_FLOAT_TO_UBYTE(clear[1], color[1]);
-   CLAMPED_FLOAT_TO_UBYTE(clear[2], color[2]);
-   CLAMPED_FLOAT_TO_UBYTE(clear[3], color[3]);
-
-   /* compute both 32 and 16-bit clear values */
-   intel->ClearColor8888 = INTEL_PACKCOLOR8888(clear[0], clear[1],
-                                               clear[2], clear[3]);
-   intel->ClearColor565 = INTEL_PACKCOLOR565(clear[0], clear[1], clear[2]);
-}
-
-
-/**
- * Update the viewport transformation matrix.  Depends on:
- *  - viewport pos/size
- *  - depthrange
- *  - window pos/size or FBO size
- */
-static void
-intelCalcViewport(GLcontext * ctx)
-{
-   struct intel_context *intel = intel_context(ctx);
-   const GLfloat *v = ctx->Viewport._WindowMap.m;
-   const GLfloat depthScale = 1.0F / ctx->DrawBuffer->_DepthMaxF;
-   GLfloat *m = intel->ViewportMatrix.m;
-   GLfloat yScale, yBias;
-
-   if (ctx->DrawBuffer->Name) {
-      /* User created FBO */
-      struct intel_renderbuffer *irb
-         = intel_renderbuffer(ctx->DrawBuffer->_ColorDrawBuffers[0]);
-      if (irb && !irb->RenderToTexture) {
-         /* y=0=top */
-         yScale = -1.0;
-         yBias = irb->Base.Height;
-      }
-      else {
-         /* y=0=bottom */
-         yScale = 1.0;
-         yBias = 0.0;
-      }
-   }
-   else {
-      /* window buffer, y=0=top */
-      yScale = -1.0;
-      yBias = (intel->driDrawable) ? intel->driDrawable->h : 0.0F;
-   }
-
-   m[MAT_SX] = v[MAT_SX];
-   m[MAT_TX] = v[MAT_TX];
-
-   m[MAT_SY] = v[MAT_SY] * yScale;
-   m[MAT_TY] = v[MAT_TY] * yScale + yBias;
-
-   m[MAT_SZ] = v[MAT_SZ] * depthScale;
-   m[MAT_TZ] = v[MAT_TZ] * depthScale;
-}
-
-static void
-intelViewport(GLcontext * ctx,
-              GLint x, GLint y, GLsizei width, GLsizei height)
-{
-   intelCalcViewport(ctx);
-
-   intel_viewport(ctx, x, y, width, height);
-}
-
-static void
-intelDepthRange(GLcontext * ctx, GLclampd nearval, GLclampd farval)
-{
-   intelCalcViewport(ctx);
-}
-
-/* Fallback to swrast for select and feedback.
- */
-static void
-intelRenderMode(GLcontext * ctx, GLenum mode)
-{
-   struct intel_context *intel = intel_context(ctx);
-   FALLBACK(intel, INTEL_FALLBACK_RENDERMODE, (mode != GL_RENDER));
-}
-
-
-void
-intelInitStateFuncs(struct dd_function_table *functions)
-{
-   functions->RenderMode = intelRenderMode;
-   functions->Viewport = intelViewport;
-   functions->DepthRange = intelDepthRange;
-   functions->ClearColor = intelClearColor;
-}
diff --git a/src/mesa/drivers/dri/i965/Makefile b/src/mesa/drivers/dri/i965/Makefile
index 37a470f..2934414 100644
--- a/src/mesa/drivers/dri/i965/Makefile
+++ b/src/mesa/drivers/dri/i965/Makefile
@@ -9,9 +9,10 @@ DRIVER_SOURCES = \
 	intel_blit.c \
 	intel_buffer_objects.c \
 	intel_buffers.c \
+	intel_clear.c \
 	intel_context.c \
 	intel_decode.c \
-	intel_depthstencil.c \
+	intel_extensions.c \
 	intel_fbo.c \
 	intel_mipmap_tree.c \
 	intel_regions.c \
@@ -22,6 +23,7 @@ DRIVER_SOURCES = \
 	intel_pixel_copy.c \
 	intel_pixel_draw.c \
 	intel_state.c \
+	intel_swapbuffers.c \
 	intel_tex.c \
 	intel_tex_copy.c \
 	intel_tex_format.c \
@@ -49,7 +51,6 @@ DRIVER_SOURCES = \
 	brw_gs.c \
 	brw_gs_emit.c \
 	brw_gs_state.c \
-	brw_metaops.c \
 	brw_misc_state.c \
 	brw_program.c \
 	brw_queryobj.c \
diff --git a/src/mesa/drivers/dri/i965/brw_cc.c b/src/mesa/drivers/dri/i965/brw_cc.c
index fa8121e..8237016 100644
--- a/src/mesa/drivers/dri/i965/brw_cc.c
+++ b/src/mesa/drivers/dri/i965/brw_cc.c
@@ -83,59 +83,60 @@ struct brw_cc_unit_key {
 static void
 cc_unit_populate_key(struct brw_context *brw, struct brw_cc_unit_key *key)
 {
-   struct gl_stencil_attrib *stencil = brw->attribs.Stencil;
+   GLcontext *ctx = &brw->intel.ctx;
+   const unsigned back = ctx->Stencil._BackFace;
 
    memset(key, 0, sizeof(*key));
 
-   key->stencil = stencil->Enabled;
-   key->stencil_two_side = stencil->_TestTwoSide;
+   key->stencil = ctx->Stencil.Enabled;
+   key->stencil_two_side = ctx->Stencil._TestTwoSide;
 
    if (key->stencil) {
-      key->stencil_func[0] = stencil->Function[0];
-      key->stencil_fail_op[0] = stencil->FailFunc[0];
-      key->stencil_pass_depth_fail_op[0] = stencil->ZFailFunc[0];
-      key->stencil_pass_depth_pass_op[0] = stencil->ZPassFunc[0];
-      key->stencil_ref[0] = stencil->Ref[0];
-      key->stencil_write_mask[0] = stencil->WriteMask[0];
-      key->stencil_test_mask[0] = stencil->ValueMask[0];
+      key->stencil_func[0] = ctx->Stencil.Function[0];
+      key->stencil_fail_op[0] = ctx->Stencil.FailFunc[0];
+      key->stencil_pass_depth_fail_op[0] = ctx->Stencil.ZFailFunc[0];
+      key->stencil_pass_depth_pass_op[0] = ctx->Stencil.ZPassFunc[0];
+      key->stencil_ref[0] = ctx->Stencil.Ref[0];
+      key->stencil_write_mask[0] = ctx->Stencil.WriteMask[0];
+      key->stencil_test_mask[0] = ctx->Stencil.ValueMask[0];
    }
    if (key->stencil_two_side) {
-      key->stencil_func[1] = stencil->Function[1];
-      key->stencil_fail_op[1] = stencil->FailFunc[1];
-      key->stencil_pass_depth_fail_op[1] = stencil->ZFailFunc[1];
-      key->stencil_pass_depth_pass_op[1] = stencil->ZPassFunc[1];
-      key->stencil_ref[1] = stencil->Ref[1];
-      key->stencil_write_mask[1] = stencil->WriteMask[1];
-      key->stencil_test_mask[1] = stencil->ValueMask[1];
+      key->stencil_func[1] = ctx->Stencil.Function[back];
+      key->stencil_fail_op[1] = ctx->Stencil.FailFunc[back];
+      key->stencil_pass_depth_fail_op[1] = ctx->Stencil.ZFailFunc[back];
+      key->stencil_pass_depth_pass_op[1] = ctx->Stencil.ZPassFunc[back];
+      key->stencil_ref[1] = ctx->Stencil.Ref[back];
+      key->stencil_write_mask[1] = ctx->Stencil.WriteMask[back];
+      key->stencil_test_mask[1] = ctx->Stencil.ValueMask[back];
    }
 
-   if (brw->attribs.Color->_LogicOpEnabled)
-      key->logic_op = brw->attribs.Color->LogicOp;
+   if (ctx->Color._LogicOpEnabled)
+      key->logic_op = ctx->Color.LogicOp;
    else
       key->logic_op = GL_COPY;
 
-   key->color_blend = brw->attribs.Color->BlendEnabled;
+   key->color_blend = ctx->Color.BlendEnabled;
    if (key->color_blend) {
-      key->blend_eq_rgb = brw->attribs.Color->BlendEquationRGB;
-      key->blend_eq_a = brw->attribs.Color->BlendEquationA;
-      key->blend_src_rgb = brw->attribs.Color->BlendSrcRGB;
-      key->blend_dst_rgb = brw->attribs.Color->BlendDstRGB;
-      key->blend_src_a = brw->attribs.Color->BlendSrcA;
-      key->blend_dst_a = brw->attribs.Color->BlendDstA;
+      key->blend_eq_rgb = ctx->Color.BlendEquationRGB;
+      key->blend_eq_a = ctx->Color.BlendEquationA;
+      key->blend_src_rgb = ctx->Color.BlendSrcRGB;
+      key->blend_dst_rgb = ctx->Color.BlendDstRGB;
+      key->blend_src_a = ctx->Color.BlendSrcA;
+      key->blend_dst_a = ctx->Color.BlendDstA;
    }
 
-   key->alpha_enabled = brw->attribs.Color->AlphaEnabled;
+   key->alpha_enabled = ctx->Color.AlphaEnabled;
    if (key->alpha_enabled) {
-      key->alpha_func = brw->attribs.Color->AlphaFunc;
-      key->alpha_ref = brw->attribs.Color->AlphaRef;
+      key->alpha_func = ctx->Color.AlphaFunc;
+      key->alpha_ref = ctx->Color.AlphaRef;
    }
 
-   key->dither = brw->attribs.Color->DitherFlag;
+   key->dither = ctx->Color.DitherFlag;
 
-   key->depth_test = brw->attribs.Depth->Test;
+   key->depth_test = ctx->Depth.Test;
    if (key->depth_test) {
-      key->depth_func = brw->attribs.Depth->Func;
-      key->depth_write = brw->attribs.Depth->Mask;
+      key->depth_func = ctx->Depth.Func;
+      key->depth_write = ctx->Depth.Mask;
    }
 }
 
diff --git a/src/mesa/drivers/dri/i965/brw_clip.c b/src/mesa/drivers/dri/i965/brw_clip.c
index 38d8b70..5cffceb 100644
--- a/src/mesa/drivers/dri/i965/brw_clip.c
+++ b/src/mesa/drivers/dri/i965/brw_clip.c
@@ -145,14 +145,14 @@ static void upload_clip_prog(struct brw_context *brw)
    /* CACHE_NEW_VS_PROG */
    key.attrs = brw->vs.prog_data->outputs_written;
    /* _NEW_LIGHT */
-   key.do_flat_shading = (brw->attribs.Light->ShadeModel == GL_FLAT);
+   key.do_flat_shading = (ctx->Light.ShadeModel == GL_FLAT);
    /* _NEW_TRANSFORM */
-   key.nr_userclip = brw_count_bits(brw->attribs.Transform->ClipPlanesEnabled);
+   key.nr_userclip = brw_count_bits(ctx->Transform.ClipPlanesEnabled);
    key.clip_mode = BRW_CLIPMODE_NORMAL;
 
    /* _NEW_POLYGON */
    if (key.primitive == GL_TRIANGLES) {
-      if (brw->attribs.Polygon->CullFaceMode == GL_FRONT_AND_BACK) 
+      if (ctx->Polygon.CullFaceMode == GL_FRONT_AND_BACK) 
 	 key.clip_mode = BRW_CLIPMODE_REJECT_ALL;
       else {
 	 GLuint fill_front = CLIP_CULL;
@@ -160,44 +160,44 @@ static void upload_clip_prog(struct brw_context *brw)
 	 GLuint offset_front = 0;
 	 GLuint offset_back = 0;
 
-	 if (!brw->attribs.Polygon->CullFlag ||
-	     brw->attribs.Polygon->CullFaceMode != GL_FRONT) {
-	    switch (brw->attribs.Polygon->FrontMode) {
+	 if (!ctx->Polygon.CullFlag ||
+	     ctx->Polygon.CullFaceMode != GL_FRONT) {
+	    switch (ctx->Polygon.FrontMode) {
 	    case GL_FILL: 
 	       fill_front = CLIP_FILL; 
 	       offset_front = 0;
 	       break;
 	    case GL_LINE:
 	       fill_front = CLIP_LINE;
-	       offset_front = brw->attribs.Polygon->OffsetLine;
+	       offset_front = ctx->Polygon.OffsetLine;
 	       break;
 	    case GL_POINT:
 	       fill_front = CLIP_POINT;
-	       offset_front = brw->attribs.Polygon->OffsetPoint;
+	       offset_front = ctx->Polygon.OffsetPoint;
 	       break;
 	    }
 	 }
 
-	 if (!brw->attribs.Polygon->CullFlag ||
-	     brw->attribs.Polygon->CullFaceMode != GL_BACK) {
-	    switch (brw->attribs.Polygon->BackMode) {
+	 if (!ctx->Polygon.CullFlag ||
+	     ctx->Polygon.CullFaceMode != GL_BACK) {
+	    switch (ctx->Polygon.BackMode) {
 	    case GL_FILL: 
 	       fill_back = CLIP_FILL; 
 	       offset_back = 0;
 	       break;
 	    case GL_LINE:
 	       fill_back = CLIP_LINE;
-	       offset_back = brw->attribs.Polygon->OffsetLine;
+	       offset_back = ctx->Polygon.OffsetLine;
 	       break;
 	    case GL_POINT:
 	       fill_back = CLIP_POINT;
-	       offset_back = brw->attribs.Polygon->OffsetPoint;
+	       offset_back = ctx->Polygon.OffsetPoint;
 	       break;
 	    }
 	 }
 
-	 if (brw->attribs.Polygon->BackMode != GL_FILL ||
-	     brw->attribs.Polygon->FrontMode != GL_FILL) {
+	 if (ctx->Polygon.BackMode != GL_FILL ||
+	     ctx->Polygon.FrontMode != GL_FILL) {
 	    key.do_unfilled = 1;
 
 	    /* Most cases the fixed function units will handle.  Cases where
@@ -207,17 +207,17 @@ static void upload_clip_prog(struct brw_context *brw)
 
 	    if (offset_back || offset_front) {
 	       /* _NEW_POLYGON, _NEW_BUFFERS */
-	       key.offset_units = brw->attribs.Polygon->OffsetUnits * brw->intel.polygon_offset_scale;
-	       key.offset_factor = brw->attribs.Polygon->OffsetFactor * ctx->DrawBuffer->_MRD;
+	       key.offset_units = ctx->Polygon.OffsetUnits * brw->intel.polygon_offset_scale;
+	       key.offset_factor = ctx->Polygon.OffsetFactor * ctx->DrawBuffer->_MRD;
 	    }
 
-	    switch (brw->attribs.Polygon->FrontFace) {
+	    switch (ctx->Polygon.FrontFace) {
 	    case GL_CCW:
 	       key.fill_ccw = fill_front;
 	       key.fill_cw = fill_back;
 	       key.offset_ccw = offset_front;
 	       key.offset_cw = offset_back;
-	       if (brw->attribs.Light->Model.TwoSide &&
+	       if (ctx->Light.Model.TwoSide &&
 		   key.fill_cw != CLIP_CULL) 
 		  key.copy_bfc_cw = 1;
 	       break;
@@ -226,7 +226,7 @@ static void upload_clip_prog(struct brw_context *brw)
 	       key.fill_ccw = fill_back;
 	       key.offset_cw = offset_front;
 	       key.offset_ccw = offset_back;
-	       if (brw->attribs.Light->Model.TwoSide &&
+	       if (ctx->Light.Model.TwoSide &&
 		   key.fill_ccw != CLIP_CULL) 
 		  key.copy_bfc_ccw = 1;
 	       break;
diff --git a/src/mesa/drivers/dri/i965/brw_clip_line.c b/src/mesa/drivers/dri/i965/brw_clip_line.c
index c45d48d..d830e49 100644
--- a/src/mesa/drivers/dri/i965/brw_clip_line.c
+++ b/src/mesa/drivers/dri/i965/brw_clip_line.c
@@ -181,34 +181,54 @@ static void clip_and_emit_line( struct brw_clip_compile *c )
 	 brw_DP4(p, vec4(c->reg.dp1), deref_4f(vtx1, c->offset[VERT_RESULT_HPOS]), c->reg.plane_equation);
 	 is_negative = brw_IF(p, BRW_EXECUTE_1);
 	 {
-	    brw_ADD(p, c->reg.t, c->reg.dp1, negate(c->reg.dp0));
-	    brw_math_invert(p, c->reg.t, c->reg.t);
-	    brw_MUL(p, c->reg.t, c->reg.t, c->reg.dp1);
-
-	    brw_CMP(p, vec1(brw_null_reg()), BRW_CONDITIONAL_G, c->reg.t, c->reg.t1 );
-	    brw_MOV(p, c->reg.t1, c->reg.t);
-	    brw_set_predicate_control(p, BRW_PREDICATE_NONE);
+             /*
+              * Both can be negative on GM965/G965 due to RHW workaround
+              * if so, this object should be rejected.
+              */
+             if (!BRW_IS_G4X(p->brw)) {
+                 brw_CMP(p, vec1(brw_null_reg()), BRW_CONDITIONAL_LE, c->reg.dp0, brw_imm_f(0.0));
+                 is_neg2 = brw_IF(p, BRW_EXECUTE_1);
+                 {
+                     brw_clip_kill_thread(c);
+                 }
+                 brw_ENDIF(p, is_neg2);
+             }
+
+             brw_ADD(p, c->reg.t, c->reg.dp1, negate(c->reg.dp0));
+             brw_math_invert(p, c->reg.t, c->reg.t);
+             brw_MUL(p, c->reg.t, c->reg.t, c->reg.dp1);
+
+             brw_CMP(p, vec1(brw_null_reg()), BRW_CONDITIONAL_G, c->reg.t, c->reg.t1 );
+             brw_MOV(p, c->reg.t1, c->reg.t);
+             brw_set_predicate_control(p, BRW_PREDICATE_NONE);
 	 } 
 	 is_negative = brw_ELSE(p, is_negative);
 	 {
-	    /* Coming back in.  We know that both cannot be negative
-	     * because the line would have been culled in that case.
-	     */
+             /* Coming back in.  We know that both cannot be negative
+              * because the line would have been culled in that case.
+              */
+
+             /* If both are positive, do nothing */
+             /* Only on GM965/G965 */
+             if (!BRW_IS_G4X(p->brw)) {
+                 brw_CMP(p, vec1(brw_null_reg()), BRW_CONDITIONAL_L, c->reg.dp0, brw_imm_f(0.0));
+                 is_neg2 = brw_IF(p, BRW_EXECUTE_1);
+             }
 
-	    /* If both are positive, do nothing */
-             brw_CMP(p, vec1(brw_null_reg()), BRW_CONDITIONAL_L, c->reg.dp0, brw_imm_f(0.0));
-             is_neg2 = brw_IF(p, BRW_EXECUTE_1);
              {
-		brw_ADD(p, c->reg.t, c->reg.dp0, negate(c->reg.dp1));
-		brw_math_invert(p, c->reg.t, c->reg.t);
-		brw_MUL(p, c->reg.t, c->reg.t, c->reg.dp0);
-
-		brw_CMP(p, vec1(brw_null_reg()), BRW_CONDITIONAL_G, c->reg.t, c->reg.t0 );
-		brw_MOV(p, c->reg.t0, c->reg.t);
-		brw_set_predicate_control(p, BRW_PREDICATE_NONE);
-	     }
-	     brw_ENDIF(p, is_neg2);
-	 }
+                 brw_ADD(p, c->reg.t, c->reg.dp0, negate(c->reg.dp1));
+                 brw_math_invert(p, c->reg.t, c->reg.t);
+                 brw_MUL(p, c->reg.t, c->reg.t, c->reg.dp0);
+
+                 brw_CMP(p, vec1(brw_null_reg()), BRW_CONDITIONAL_G, c->reg.t, c->reg.t0 );
+                 brw_MOV(p, c->reg.t0, c->reg.t);
+                 brw_set_predicate_control(p, BRW_PREDICATE_NONE);
+             }
+
+             if (!BRW_IS_G4X(p->brw)) {
+                 brw_ENDIF(p, is_neg2);
+             }
+         }
 	 brw_ENDIF(p, is_negative);	 
       }
       brw_ENDIF(p, plane_active);
diff --git a/src/mesa/drivers/dri/i965/brw_clip_tri.c b/src/mesa/drivers/dri/i965/brw_clip_tri.c
index 1dbba37..7fd37bd 100644
--- a/src/mesa/drivers/dri/i965/brw_clip_tri.c
+++ b/src/mesa/drivers/dri/i965/brw_clip_tri.c
@@ -455,6 +455,8 @@ static void brw_clip_test( struct brw_clip_compile *c )
     struct brw_indirect vt2 = brw_indirect(2, 0);
 
     struct brw_compile *p = &c->func;
+    struct brw_instruction *is_outside;
+    struct brw_reg tmp0 = c->reg.loopcount; /* handy temporary */
 
     brw_MOV(p, get_addr_reg(vt0), brw_address(c->reg.vertex[0]));
     brw_MOV(p, get_addr_reg(vt1), brw_address(c->reg.vertex[1]));
@@ -462,53 +464,87 @@ static void brw_clip_test( struct brw_clip_compile *c )
     brw_MOV(p, v0, deref_4f(vt0, c->offset[VERT_RESULT_HPOS]));
     brw_MOV(p, v1, deref_4f(vt1, c->offset[VERT_RESULT_HPOS]));
     brw_MOV(p, v2, deref_4f(vt2, c->offset[VERT_RESULT_HPOS]));
+    brw_AND(p, c->reg.planemask, c->reg.planemask, brw_imm_ud(~0x3f));
 
     /* test nearz, xmin, ymin plane */
-    brw_CMP(p, t1, BRW_CONDITIONAL_LE, negate(v0), get_element(v0, 3)); 
+    /* clip.xyz < -clip.w */
+    brw_CMP(p, t1, BRW_CONDITIONAL_L, v0, negate(get_element(v0, 3))); 
     brw_set_predicate_control(p, BRW_PREDICATE_NONE);
-    brw_CMP(p, t2, BRW_CONDITIONAL_LE, negate(v1), get_element(v1, 3)); 
+    brw_CMP(p, t2, BRW_CONDITIONAL_L, v1, negate(get_element(v1, 3))); 
     brw_set_predicate_control(p, BRW_PREDICATE_NONE);
-    brw_CMP(p, t3, BRW_CONDITIONAL_LE, negate(v2), get_element(v2, 3)); 
+    brw_CMP(p, t3, BRW_CONDITIONAL_L, v2, negate(get_element(v2, 3))); 
     brw_set_predicate_control(p, BRW_PREDICATE_NONE);
+
+    /* All vertices are outside of a plane, rejected */
+    brw_AND(p, t, t1, t2);
+    brw_AND(p, t, t, t3);
+    brw_OR(p, tmp0, get_element(t, 0), get_element(t, 1));
+    brw_OR(p, tmp0, tmp0, get_element(t, 2));
+    brw_set_conditionalmod(p, BRW_CONDITIONAL_NZ);
+    brw_AND(p, brw_null_reg(), tmp0, brw_imm_ud(0x1));
+    is_outside = brw_IF(p, BRW_EXECUTE_1);
+    {
+        brw_clip_kill_thread(c);
+    }
+    brw_ENDIF(p, is_outside);
+    brw_set_predicate_control(p, BRW_PREDICATE_NONE);
+
+    /* some vertices are inside a plane, some are outside,need to clip */
     brw_XOR(p, t, t1, t2);
     brw_XOR(p, t1, t2, t3);
     brw_OR(p, t, t, t1);
-
-    brw_CMP(p, brw_null_reg(), BRW_CONDITIONAL_NZ, 
-	    get_element(t, 0), brw_imm_ud(0));
+    brw_AND(p, t, t, brw_imm_ud(0x1));
+    brw_CMP(p, brw_null_reg(), BRW_CONDITIONAL_NZ,
+            get_element(t, 0), brw_imm_ud(0));
     brw_OR(p, c->reg.planemask, c->reg.planemask, brw_imm_ud((1<<5)));
     brw_set_predicate_control(p, BRW_PREDICATE_NONE);
-    brw_CMP(p, brw_null_reg(), BRW_CONDITIONAL_NZ, 
-	    get_element(t, 1), brw_imm_ud(0));
+    brw_CMP(p, brw_null_reg(), BRW_CONDITIONAL_NZ,
+            get_element(t, 1), brw_imm_ud(0));
     brw_OR(p, c->reg.planemask, c->reg.planemask, brw_imm_ud((1<<3)));
     brw_set_predicate_control(p, BRW_PREDICATE_NONE);
-    brw_CMP(p, brw_null_reg(), BRW_CONDITIONAL_NZ, 
-	    get_element(t, 2), brw_imm_ud(0));
+    brw_CMP(p, brw_null_reg(), BRW_CONDITIONAL_NZ,
+            get_element(t, 2), brw_imm_ud(0));
     brw_OR(p, c->reg.planemask, c->reg.planemask, brw_imm_ud((1<<1)));
     brw_set_predicate_control(p, BRW_PREDICATE_NONE);
 
     /* test farz, xmax, ymax plane */
-    brw_CMP(p, t1, BRW_CONDITIONAL_L, v0, get_element(v0, 3)); 
+    /* clip.xyz > clip.w */
+    brw_CMP(p, t1, BRW_CONDITIONAL_G, v0, get_element(v0, 3)); 
     brw_set_predicate_control(p, BRW_PREDICATE_NONE);
-    brw_CMP(p, t2, BRW_CONDITIONAL_L, v1, get_element(v1, 3)); 
+    brw_CMP(p, t2, BRW_CONDITIONAL_G, v1, get_element(v1, 3)); 
     brw_set_predicate_control(p, BRW_PREDICATE_NONE);
-    brw_CMP(p, t3, BRW_CONDITIONAL_L, v2, get_element(v2, 3)); 
+    brw_CMP(p, t3, BRW_CONDITIONAL_G, v2, get_element(v2, 3)); 
     brw_set_predicate_control(p, BRW_PREDICATE_NONE);
 
+    /* All vertices are outside of a plane, rejected */
+    brw_AND(p, t, t1, t2);
+    brw_AND(p, t, t, t3);
+    brw_OR(p, tmp0, get_element(t, 0), get_element(t, 1));
+    brw_OR(p, tmp0, tmp0, get_element(t, 2));
+    brw_set_conditionalmod(p, BRW_CONDITIONAL_NZ);
+    brw_AND(p, brw_null_reg(), tmp0, brw_imm_ud(0x1));
+    is_outside = brw_IF(p, BRW_EXECUTE_1);
+    {
+        brw_clip_kill_thread(c);
+    }
+    brw_ENDIF(p, is_outside);
+    brw_set_predicate_control(p, BRW_PREDICATE_NONE);
+
+    /* some vertices are inside a plane, some are outside,need to clip */
     brw_XOR(p, t, t1, t2);
     brw_XOR(p, t1, t2, t3);
     brw_OR(p, t, t, t1);
-
-    brw_CMP(p, brw_null_reg(), BRW_CONDITIONAL_NZ, 
-	    get_element(t, 0), brw_imm_ud(0));
+    brw_AND(p, t, t, brw_imm_ud(0x1));
+    brw_CMP(p, brw_null_reg(), BRW_CONDITIONAL_NZ,
+            get_element(t, 0), brw_imm_ud(0));
     brw_OR(p, c->reg.planemask, c->reg.planemask, brw_imm_ud((1<<4)));
     brw_set_predicate_control(p, BRW_PREDICATE_NONE);
-    brw_CMP(p, brw_null_reg(), BRW_CONDITIONAL_NZ, 
-	    get_element(t, 1), brw_imm_ud(0));
+    brw_CMP(p, brw_null_reg(), BRW_CONDITIONAL_NZ,
+            get_element(t, 1), brw_imm_ud(0));
     brw_OR(p, c->reg.planemask, c->reg.planemask, brw_imm_ud((1<<2)));
     brw_set_predicate_control(p, BRW_PREDICATE_NONE);
-    brw_CMP(p, brw_null_reg(), BRW_CONDITIONAL_NZ, 
-	    get_element(t, 2), brw_imm_ud(0));
+    brw_CMP(p, brw_null_reg(), BRW_CONDITIONAL_NZ,
+            get_element(t, 2), brw_imm_ud(0));
     brw_OR(p, c->reg.planemask, c->reg.planemask, brw_imm_ud((1<<0)));
     brw_set_predicate_control(p, BRW_PREDICATE_NONE);
 
diff --git a/src/mesa/drivers/dri/i965/brw_context.c b/src/mesa/drivers/dri/i965/brw_context.c
index d7a2bd9..d96ff29 100644
--- a/src/mesa/drivers/dri/i965/brw_context.c
+++ b/src/mesa/drivers/dri/i965/brw_context.c
@@ -76,30 +76,6 @@ static void brwInitDriverFunctions( struct dd_function_table *functions )
    functions->Viewport = intel_viewport;
 }
 
-
-static void brw_init_attribs( struct brw_context *brw )
-{
-   GLcontext *ctx = &brw->intel.ctx;
-
-   brw->attribs.Color = &ctx->Color;
-   brw->attribs.Depth = &ctx->Depth;
-   brw->attribs.Fog = &ctx->Fog;
-   brw->attribs.Hint = &ctx->Hint;
-   brw->attribs.Light = &ctx->Light;
-   brw->attribs.Line = &ctx->Line;
-   brw->attribs.Point = &ctx->Point;
-   brw->attribs.Polygon = &ctx->Polygon;
-   brw->attribs.Scissor = &ctx->Scissor;
-   brw->attribs.Stencil = &ctx->Stencil;
-   brw->attribs.Texture = &ctx->Texture;
-   brw->attribs.Transform = &ctx->Transform;
-   brw->attribs.Viewport = &ctx->Viewport;
-   brw->attribs.VertexProgram = &ctx->VertexProgram;
-   brw->attribs.FragmentProgram = &ctx->FragmentProgram;
-   brw->attribs.PolygonStipple = &ctx->PolygonStipple[0];
-}
-
-
 GLboolean brwCreateContext( const __GLcontextModes *mesaVis,
 			    __DRIcontextPrivate *driContextPriv,
 			    void *sharedContextPrivate)
@@ -135,21 +111,21 @@ GLboolean brwCreateContext( const __GLcontextModes *mesaVis,
                                      ctx->Const.MaxTextureImageUnits);
    ctx->Const.MaxVertexTextureImageUnits = 0; /* no vertex shader textures */
 
-   /* Advertise the full hardware capabilities.  The new memory
-    * manager should cope much better with overload situations:
+   /* Mesa limits textures to 4kx4k; it would be nice to fix that someday
     */
-   ctx->Const.MaxTextureLevels = 12;
+   ctx->Const.MaxTextureLevels = 13;
    ctx->Const.Max3DTextureLevels = 9;
    ctx->Const.MaxCubeTextureLevels = 12;
-   ctx->Const.MaxTextureRectSize = (1<<11);
+   ctx->Const.MaxTextureRectSize = (1<<12);
    
    /* if conformance mode is set, swrast can handle any size AA point */
    ctx->Const.MaxPointSizeAA = 255.0;
 
+   /* We want the GLSL compiler to emit code that uses condition codes */
+   ctx->Shader.EmitCondCodes = GL_TRUE;
+
 /*    ctx->Const.MaxNativeVertexProgramTemps = 32; */
 
-   brw_init_attribs( brw );
-   brw_init_metaops( brw );
    brw_init_state( brw );
 
    brw->state.dirty.mesa = ~0;
diff --git a/src/mesa/drivers/dri/i965/brw_context.h b/src/mesa/drivers/dri/i965/brw_context.h
index 5d3f99e..a43fc40 100644
--- a/src/mesa/drivers/dri/i965/brw_context.h
+++ b/src/mesa/drivers/dri/i965/brw_context.h
@@ -131,7 +131,6 @@ struct brw_context;
 #define BRW_NEW_WM_INPUT_DIMENSIONS     0x100
 #define BRW_NEW_INPUT_VARYING           0x200
 #define BRW_NEW_PSP                     0x800
-#define BRW_NEW_METAOPS                 0x1000
 #define BRW_NEW_FENCE                   0x2000
 #define BRW_NEW_INDICES			0x4000
 #define BRW_NEW_VERTICES		0x8000
@@ -164,7 +163,7 @@ struct brw_vertex_program {
 
 struct brw_fragment_program {
    struct gl_fragment_program program;
-   GLuint id;
+   GLuint id;  /**< serial no. to identify frag progs, never re-used */
 };
 
 
@@ -303,26 +302,6 @@ struct brw_cache {
 };
 
 
-
-struct brw_state_pointers {
-   struct gl_colorbuffer_attrib	*Color;
-   struct gl_depthbuffer_attrib	*Depth;
-   struct gl_fog_attrib		*Fog;
-   struct gl_hint_attrib	*Hint;
-   struct gl_light_attrib	*Light;
-   struct gl_line_attrib	*Line;
-   struct gl_point_attrib	*Point;
-   struct gl_polygon_attrib	*Polygon;
-   GLuint                       *PolygonStipple;
-   struct gl_scissor_attrib	*Scissor;
-   struct gl_stencil_attrib	*Stencil;
-   struct gl_texture_attrib	*Texture;
-   struct gl_transform_attrib	*Transform;
-   struct gl_viewport_attrib	*Viewport;
-   struct gl_vertex_program_state *VertexProgram; 
-   struct gl_fragment_program_state *FragmentProgram;
-};
-
 /* Considered adding a member to this struct to document which flags
  * an update might raise so that ordering of the state atoms can be
  * checked or derived at runtime.  Dropped the idea in favor of having
@@ -439,8 +418,8 @@ struct brw_context
       struct brw_tracked_state **atoms;
       GLuint nr_atoms;
 
-      GLuint nr_draw_regions;
-      struct intel_region *draw_regions[MAX_DRAW_BUFFERS];
+      GLuint nr_color_regions;
+      struct intel_region *color_regions[MAX_DRAW_BUFFERS];
       struct intel_region *depth_region;
 
       /**
@@ -457,7 +436,6 @@ struct brw_context
       int validated_bo_count;
    } state;
 
-   struct brw_state_pointers attribs;
    struct brw_cache cache;
    struct brw_cached_batch_item *cached_batch_items;
 
@@ -491,28 +469,6 @@ struct brw_context
       unsigned int offset;
    } ib;
 
-   struct {
-      /* Will be allocated on demand if needed.   
-       */
-      struct brw_state_pointers attribs;
-      struct gl_vertex_program *vp;
-      struct gl_fragment_program *fp, *fp_tex;
-
-      struct gl_buffer_object *vbo;
-
-      struct intel_region *saved_draw_region;
-      GLuint saved_nr_draw_regions;
-      struct intel_region *saved_depth_region;
-
-      GLuint restore_draw_buffers[MAX_DRAW_BUFFERS];
-      GLuint restore_num_draw_buffers;
-
-      struct gl_fragment_program *restore_fp;
-      
-      GLboolean active;
-   } metaops;
-
-
    /* Active vertex program: 
     */
    const struct gl_vertex_program *vertex_program;
@@ -703,13 +659,6 @@ void brw_FrameBufferTexInit( struct brw_context *brw,
 void brw_FrameBufferTexDestroy( struct brw_context *brw );
 void brw_validate_textures( struct brw_context *brw );
 
-/*======================================================================
- * brw_metaops.c
- */
-
-void brw_init_metaops( struct brw_context *brw );
-void brw_destroy_metaops( struct brw_context *brw );
-
 
 /*======================================================================
  * brw_program.c
@@ -721,7 +670,9 @@ void brwInitFragProgFuncs( struct dd_function_table *functions );
  */
 void brw_upload_urb_fence(struct brw_context *brw);
 
-void brw_upload_constant_buffer_state(struct brw_context *brw);
+/* brw_curbe.c
+ */
+void brw_upload_cs_urb_state(struct brw_context *brw);
 
 
 /*======================================================================
diff --git a/src/mesa/drivers/dri/i965/brw_curbe.c b/src/mesa/drivers/dri/i965/brw_curbe.c
index fbf473a..4ec0cfb 100644
--- a/src/mesa/drivers/dri/i965/brw_curbe.c
+++ b/src/mesa/drivers/dri/i965/brw_curbe.c
@@ -48,6 +48,7 @@
  */
 static void calculate_curbe_offsets( struct brw_context *brw )
 {
+   GLcontext *ctx = &brw->intel.ctx;
    /* CACHE_NEW_WM_PROG */
    GLuint nr_fp_regs = (brw->wm.prog_data->nr_params + 15) / 16;
    
@@ -58,8 +59,8 @@ static void calculate_curbe_offsets( struct brw_context *brw )
    GLuint total_regs;
 
    /* _NEW_TRANSFORM */
-   if (brw->attribs.Transform->ClipPlanesEnabled) {
-      GLuint nr_planes = 6 + brw_count_bits(brw->attribs.Transform->ClipPlanesEnabled);
+   if (ctx->Transform.ClipPlanesEnabled) {
+      GLuint nr_planes = 6 + brw_count_bits(ctx->Transform.ClipPlanesEnabled);
       nr_clip_regs = (nr_planes * 4 + 15) / 16;
    }
 
@@ -137,24 +138,24 @@ const struct brw_tracked_state brw_curbe_offsets = {
  * fixed-function hardware in a double-buffering scheme to avoid a
  * pipeline stall each time the contents of the curbe is changed.
  */
-void brw_upload_constant_buffer_state(struct brw_context *brw)
+void brw_upload_cs_urb_state(struct brw_context *brw)
 {
-   struct brw_constant_buffer_state cbs; 
-   memset(&cbs, 0, sizeof(cbs));
+   struct brw_cs_urb_state cs_urb;
+   memset(&cs_urb, 0, sizeof(cs_urb));
 
    /* It appears that this is the state packet for the CS unit, ie. the
     * urb entries detailed here are housed in the CS range from the
     * URB_FENCE command.
     */
-   cbs.header.opcode = CMD_CONST_BUFFER_STATE;
-   cbs.header.length = sizeof(cbs)/4 - 2;
+   cs_urb.header.opcode = CMD_CS_URB_STATE;
+   cs_urb.header.length = sizeof(cs_urb)/4 - 2;
 
    /* BRW_NEW_URB_FENCE */
-   cbs.bits0.nr_urb_entries = brw->urb.nr_cs_entries;
-   cbs.bits0.urb_entry_size = brw->urb.csize - 1;
+   cs_urb.bits0.nr_urb_entries = brw->urb.nr_cs_entries;
+   cs_urb.bits0.urb_entry_size = brw->urb.csize - 1;
 
    assert(brw->urb.nr_cs_entries);
-   BRW_CACHED_BATCH_STRUCT(brw, &cbs);
+   BRW_CACHED_BATCH_STRUCT(brw, &cs_urb);
 }
 
 static GLfloat fixed_plane[6][4] = {
@@ -233,11 +234,11 @@ static void prepare_constant_buffer(struct brw_context *brw)
        */
       assert(MAX_CLIP_PLANES == 6);
       for (j = 0; j < MAX_CLIP_PLANES; j++) {
-	 if (brw->attribs.Transform->ClipPlanesEnabled & (1<<j)) {
-	    buf[offset + i * 4 + 0] = brw->attribs.Transform->_ClipUserPlane[j][0];
-	    buf[offset + i * 4 + 1] = brw->attribs.Transform->_ClipUserPlane[j][1];
-	    buf[offset + i * 4 + 2] = brw->attribs.Transform->_ClipUserPlane[j][2];
-	    buf[offset + i * 4 + 3] = brw->attribs.Transform->_ClipUserPlane[j][3];
+	 if (ctx->Transform.ClipPlanesEnabled & (1<<j)) {
+	    buf[offset + i * 4 + 0] = ctx->Transform._ClipUserPlane[j][0];
+	    buf[offset + i * 4 + 1] = ctx->Transform._ClipUserPlane[j][1];
+	    buf[offset + i * 4 + 2] = ctx->Transform._ClipUserPlane[j][2];
+	    buf[offset + i * 4 + 3] = ctx->Transform._ClipUserPlane[j][3];
 	    i++;
 	 }
       }
diff --git a/src/mesa/drivers/dri/i965/brw_defines.h b/src/mesa/drivers/dri/i965/brw_defines.h
index 39c3225..590b064 100644
--- a/src/mesa/drivers/dri/i965/brw_defines.h
+++ b/src/mesa/drivers/dri/i965/brw_defines.h
@@ -734,7 +734,7 @@
 
 
 #define CMD_URB_FENCE                 0x6000
-#define CMD_CONST_BUFFER_STATE        0x6001
+#define CMD_CS_URB_STATE              0x6001
 #define CMD_CONST_BUFFER              0x6002
 
 #define CMD_STATE_BASE_ADDRESS        0x6101
diff --git a/src/mesa/drivers/dri/i965/brw_draw.c b/src/mesa/drivers/dri/i965/brw_draw.c
index 785fb78..3ca953d 100644
--- a/src/mesa/drivers/dri/i965/brw_draw.c
+++ b/src/mesa/drivers/dri/i965/brw_draw.c
@@ -84,15 +84,17 @@ static const GLenum reduced_prim[GL_POLYGON+1] = {
  */
 static GLuint brw_set_prim(struct brw_context *brw, GLenum prim)
 {
+   GLcontext *ctx = &brw->intel.ctx;
+
    if (INTEL_DEBUG & DEBUG_PRIMS)
       _mesa_printf("PRIM: %s\n", _mesa_lookup_enum_by_nr(prim));
    
    /* Slight optimization to avoid the GS program when not needed:
     */
    if (prim == GL_QUAD_STRIP &&
-       brw->attribs.Light->ShadeModel != GL_FLAT &&
-       brw->attribs.Polygon->FrontMode == GL_FILL &&
-       brw->attribs.Polygon->BackMode == GL_FILL)
+       ctx->Light.ShadeModel != GL_FLAT &&
+       ctx->Polygon.FrontMode == GL_FILL &&
+       ctx->Polygon.BackMode == GL_FILL)
       prim = GL_TRIANGLE_STRIP;
 
    if (prim != brw->primitive) {
@@ -166,14 +168,11 @@ static void brw_merge_inputs( struct brw_context *brw,
    for (i = 0; i < VERT_ATTRIB_MAX; i++) {
       brw->vb.inputs[i].glarray = arrays[i];
 
-      /* XXX: metaops passes null arrays */
-      if (arrays[i]) {
-	 if (arrays[i]->StrideB != 0)
-	    brw->vb.info.varying |= 1 << i;
+      if (arrays[i]->StrideB != 0)
+	 brw->vb.info.varying |= 1 << i;
 
 	 brw->vb.info.sizes[i/16] |= (brw->vb.inputs[i].glarray->Size - 1) <<
 	    ((i%16) * 2);
-      }
    }
 
    /* Raise statechanges if input sizes and varying have changed: 
@@ -192,12 +191,13 @@ static GLboolean check_fallbacks( struct brw_context *brw,
 				  const struct _mesa_prim *prim,
 				  GLuint nr_prims )
 {
+   GLcontext *ctx = &brw->intel.ctx;
    GLuint i;
 
    if (!brw->intel.strict_conformance)
       return GL_FALSE;
 
-   if (brw->attribs.Polygon->SmoothFlag) {
+   if (ctx->Polygon.SmoothFlag) {
       for (i = 0; i < nr_prims; i++)
 	 if (reduced_prim[prim[i].mode] == GL_TRIANGLES) 
 	    return GL_TRUE;
@@ -206,7 +206,7 @@ static GLboolean check_fallbacks( struct brw_context *brw,
    /* BRW hardware will do AA lines, but they are non-conformant it
     * seems.  TBD whether we keep this fallback:
     */
-   if (brw->attribs.Line->SmoothFlag) {
+   if (ctx->Line.SmoothFlag) {
       for (i = 0; i < nr_prims; i++)
 	 if (reduced_prim[prim[i].mode] == GL_LINES) 
 	    return GL_TRUE;
@@ -215,23 +215,23 @@ static GLboolean check_fallbacks( struct brw_context *brw,
    /* Stipple -- these fallbacks could be resolved with a little
     * bit of work?
     */
-   if (brw->attribs.Line->StippleFlag) {
+   if (ctx->Line.StippleFlag) {
       for (i = 0; i < nr_prims; i++) {
 	 /* GS doesn't get enough information to know when to reset
 	  * the stipple counter?!?
 	  */
-	 if (prim[i].mode == GL_LINE_LOOP) 
+	 if (prim[i].mode == GL_LINE_LOOP || prim[i].mode == GL_LINE_STRIP) 
 	    return GL_TRUE;
 	    
 	 if (prim[i].mode == GL_POLYGON &&
-	     (brw->attribs.Polygon->FrontMode == GL_LINE ||
-	      brw->attribs.Polygon->BackMode == GL_LINE))
+	     (ctx->Polygon.FrontMode == GL_LINE ||
+	      ctx->Polygon.BackMode == GL_LINE))
 	    return GL_TRUE;
       }
    }
 
 
-   if (brw->attribs.Point->SmoothFlag) {
+   if (ctx->Point.SmoothFlag) {
       for (i = 0; i < nr_prims; i++)
 	 if (prim[i].mode == GL_POINTS) 
 	    return GL_TRUE;
diff --git a/src/mesa/drivers/dri/i965/brw_draw_upload.c b/src/mesa/drivers/dri/i965/brw_draw_upload.c
index 73d6dea..02998d5 100644
--- a/src/mesa/drivers/dri/i965/brw_draw_upload.c
+++ b/src/mesa/drivers/dri/i965/brw_draw_upload.c
@@ -156,7 +156,13 @@ static GLuint byte_types_scale[5] = {
 };
 
 
-static GLuint get_surface_type( GLenum type, GLuint size, GLboolean normalized )
+/**
+ * Given vertex array type/size/format/normalized info, return
+ * the appopriate hardware surface type.
+ * Format will be GL_RGBA or possibly GL_BGRA for GLubyte[4] color arrays.
+ */
+static GLuint get_surface_type( GLenum type, GLuint size,
+                                GLenum format, GLboolean normalized )
 {
    if (INTEL_DEBUG & DEBUG_VERTS)
       _mesa_printf("type %s size %d normalized %d\n", 
@@ -171,11 +177,20 @@ static GLuint get_surface_type( GLenum type, GLuint size, GLboolean normalized )
       case GL_BYTE: return byte_types_norm[size];
       case GL_UNSIGNED_INT: return uint_types_norm[size];
       case GL_UNSIGNED_SHORT: return ushort_types_norm[size];
-      case GL_UNSIGNED_BYTE: return ubyte_types_norm[size];
+      case GL_UNSIGNED_BYTE:
+         if (format == GL_BGRA) {
+            /* See GL_EXT_vertex_array_bgra */
+            assert(size == 4);
+            return BRW_SURFACEFORMAT_B8G8R8A8_UNORM;
+         }
+         else {
+            return ubyte_types_norm[size];
+         }
       default: assert(0); return 0;
       }      
    }
    else {
+      assert(format == GL_RGBA); /* sanity check */
       switch (type) {
       case GL_DOUBLE: return double_types[size];
       case GL_FLOAT: return float_types[size];
@@ -281,7 +296,7 @@ copy_array_to_vbo_array( struct brw_context *brw,
    } else {
       void *data;
       char *dest;
-      const char *src = element->glarray->Ptr;
+      const unsigned char *src = element->glarray->Ptr;
       int i;
 
       data = _mesa_malloc(dst_stride * element->count);
@@ -484,6 +499,7 @@ static void brw_emit_vertices(struct brw_context *brw)
       struct brw_vertex_element *input = enabled[i];
       uint32_t format = get_surface_type(input->glarray->Type,
 					 input->glarray->Size,
+					 input->glarray->Format,
 					 input->glarray->Normalized);
       uint32_t comp0 = BRW_VE1_COMPONENT_STORE_SRC;
       uint32_t comp1 = BRW_VE1_COMPONENT_STORE_SRC;
@@ -549,7 +565,7 @@ static void brw_prepare_indices(struct brw_context *brw)
        */
       dri_bo_subdata(bo, offset, ib_size, index_buffer->ptr);
    } else {
-      offset = (GLuint)index_buffer->ptr;
+      offset = (GLuint) (unsigned long) index_buffer->ptr;
 
       /* If the index buffer isn't aligned to its element size, we have to
        * rebase it into a temporary.
diff --git a/src/mesa/drivers/dri/i965/brw_eu.c b/src/mesa/drivers/dri/i965/brw_eu.c
index b3ae4ee..c53efba 100644
--- a/src/mesa/drivers/dri/i965/brw_eu.c
+++ b/src/mesa/drivers/dri/i965/brw_eu.c
@@ -129,3 +129,126 @@ const GLuint *brw_get_program( struct brw_compile *p,
    return (const GLuint *)p->store;
 }
 
+
+
+/**
+ * Subroutine calls require special attention.
+ * Mesa instructions may be expanded into multiple hardware instructions
+ * so the prog_instruction::BranchTarget field can't be used as an index
+ * into the hardware instructions.
+ *
+ * The BranchTarget field isn't needed, however.  Mesa's GLSL compiler
+ * emits CAL and BGNSUB instructions with labels that can be used to map
+ * subroutine calls to actual subroutine code blocks.
+ *
+ * The structures and function here implement patching of CAL instructions
+ * so they jump to the right subroutine code...
+ */
+
+
+/**
+ * For each OPCODE_BGNSUB we create one of these.
+ */
+struct brw_glsl_label
+{
+   const char *name; /**< the label string */
+   GLuint position;  /**< the position of the brw instruction for this label */
+   struct brw_glsl_label *next;  /**< next in linked list */
+};
+
+
+/**
+ * For each OPCODE_CAL we create one of these.
+ */
+struct brw_glsl_call
+{
+   GLuint call_inst_pos;  /**< location of the CAL instruction */
+   const char *sub_name;  /**< name of subroutine to call */
+   struct brw_glsl_call *next;  /**< next in linked list */
+};
+
+
+/**
+ * Called for each OPCODE_BGNSUB.
+ */
+void
+brw_save_label(struct brw_compile *c, const char *name, GLuint position)
+{
+   struct brw_glsl_label *label = CALLOC_STRUCT(brw_glsl_label);
+   label->name = name;
+   label->position = position;
+   label->next = c->first_label;
+   c->first_label = label;
+}
+
+
+/**
+ * Called for each OPCODE_CAL.
+ */
+void
+brw_save_call(struct brw_compile *c, const char *name, GLuint call_pos)
+{
+   struct brw_glsl_call *call = CALLOC_STRUCT(brw_glsl_call);
+   call->call_inst_pos = call_pos;
+   call->sub_name = name;
+   call->next = c->first_call;
+   c->first_call = call;
+}
+
+
+/**
+ * Lookup a label, return label's position/offset.
+ */
+static GLuint
+brw_lookup_label(struct brw_compile *c, const char *name)
+{
+   const struct brw_glsl_label *label;
+   for (label = c->first_label; label; label = label->next) {
+      if (strcmp(name, label->name) == 0) {
+         return label->position;
+      }
+   }
+   abort();  /* should never happen */
+   return ~0;
+}
+
+
+/**
+ * When we're done generating code, this function is called to resolve
+ * subroutine calls.
+ */
+void
+brw_resolve_cals(struct brw_compile *c)
+{
+    const struct brw_glsl_call *call;
+
+    for (call = c->first_call; call; call = call->next) {
+        const GLuint sub_loc = brw_lookup_label(c, call->sub_name);
+	struct brw_instruction *brw_call_inst = &c->store[call->call_inst_pos];
+	struct brw_instruction *brw_sub_inst = &c->store[sub_loc];
+	GLint offset = brw_sub_inst - brw_call_inst;
+
+	/* patch brw_inst1 to point to brw_inst2 */
+	brw_set_src1(brw_call_inst, brw_imm_d(offset * 16));
+    }
+
+    /* free linked list of calls */
+    {
+        struct brw_glsl_call *call, *next;
+        for (call = c->first_call; call; call = next) {
+	    next = call->next;
+	    _mesa_free(call);
+	}
+	c->first_call = NULL;
+    }
+
+    /* free linked list of labels */
+    {
+        struct brw_glsl_label *label, *next;
+	for (label = c->first_label; label; label = next) {
+	    next = label->next;
+	    _mesa_free(label);
+	}
+	c->first_label = NULL;
+    }
+}
diff --git a/src/mesa/drivers/dri/i965/brw_eu.h b/src/mesa/drivers/dri/i965/brw_eu.h
index 9e2b39a..b36a197 100644
--- a/src/mesa/drivers/dri/i965/brw_eu.h
+++ b/src/mesa/drivers/dri/i965/brw_eu.h
@@ -91,6 +91,11 @@ struct brw_indirect {
 };
 
 
+struct brw_glsl_label;
+struct brw_glsl_call;
+
+
+
 #define BRW_EU_MAX_INSN_STACK 5
 #define BRW_EU_MAX_INSN 1200
 
@@ -106,9 +111,22 @@ struct brw_compile {
    GLuint flag_value;
    GLboolean single_program_flow;
    struct brw_context *brw;
+
+   struct brw_glsl_label *first_label;  /**< linked list of labels */
+   struct brw_glsl_call *first_call;    /**< linked list of CALs */
 };
 
 
+void
+brw_save_label(struct brw_compile *c, const char *name, GLuint position);
+
+void
+brw_save_call(struct brw_compile *c, const char *name, GLuint call_pos);
+
+void
+brw_resolve_cals(struct brw_compile *c);
+
+
 
 static INLINE int type_sz( GLuint type )
 {
diff --git a/src/mesa/drivers/dri/i965/brw_eu_emit.c b/src/mesa/drivers/dri/i965/brw_eu_emit.c
index 4e099b5..bac7135 100644
--- a/src/mesa/drivers/dri/i965/brw_eu_emit.c
+++ b/src/mesa/drivers/dri/i965/brw_eu_emit.c
@@ -96,7 +96,7 @@ static void brw_set_dest( struct brw_instruction *insn,
 }
 
 static void brw_set_src0( struct brw_instruction *insn,
-		      struct brw_reg reg )
+                          struct brw_reg reg )
 {
    assert(reg.file != BRW_MESSAGE_REGISTER_FILE);
 
@@ -169,7 +169,7 @@ static void brw_set_src0( struct brw_instruction *insn,
 
 
 void brw_set_src1( struct brw_instruction *insn,
-			  struct brw_reg reg )
+                   struct brw_reg reg )
 {
    assert(reg.file != BRW_MESSAGE_REGISTER_FILE);
 
@@ -323,13 +323,13 @@ static void brw_set_dp_read_message( struct brw_instruction *insn,
 }
 
 static void brw_set_sampler_message(struct brw_context *brw,
-                 struct brw_instruction *insn,
-				     GLuint binding_table_index,
-				     GLuint sampler,
-				     GLuint msg_type,
-				     GLuint response_length,
-				     GLuint msg_length,
-				     GLboolean eot)
+                                    struct brw_instruction *insn,
+                                    GLuint binding_table_index,
+                                    GLuint sampler,
+                                    GLuint msg_type,
+                                    GLuint response_length,
+                                    GLuint msg_length,
+                                    GLboolean eot)
 {
    brw_set_src1(insn, brw_imm_d(0));
 
@@ -407,7 +407,7 @@ static struct brw_instruction *brw_alu2(struct brw_compile *p,
  * Convenience routines.
  */
 #define ALU1(OP)					\
-struct brw_instruction *brw_##OP(struct brw_compile *p,			\
+struct brw_instruction *brw_##OP(struct brw_compile *p,	\
 	      struct brw_reg dest,			\
 	      struct brw_reg src0)   			\
 {							\
@@ -415,7 +415,7 @@ struct brw_instruction *brw_##OP(struct brw_compile *p,			\
 }
 
 #define ALU2(OP)					\
-struct brw_instruction *brw_##OP(struct brw_compile *p,			\
+struct brw_instruction *brw_##OP(struct brw_compile *p,	\
 	      struct brw_reg dest,			\
 	      struct brw_reg src0,			\
 	      struct brw_reg src1)   			\
@@ -469,9 +469,9 @@ void brw_NOP(struct brw_compile *p)
  */
 
 struct brw_instruction *brw_JMPI(struct brw_compile *p, 
-	      struct brw_reg dest,
-	      struct brw_reg src0,
-	      struct brw_reg src1)
+                                 struct brw_reg dest,
+                                 struct brw_reg src0,
+                                 struct brw_reg src1)
 {
    struct brw_instruction *insn = brw_alu2(p, BRW_OPCODE_JMPI, dest, src0, src1);
 
@@ -674,7 +674,7 @@ struct brw_instruction *brw_DO(struct brw_compile *p, GLuint execute_size)
 
 
 struct brw_instruction *brw_WHILE(struct brw_compile *p, 
-	       struct brw_instruction *do_insn)
+                                  struct brw_instruction *do_insn)
 {
    struct brw_instruction *insn;
 
@@ -931,13 +931,13 @@ void brw_dp_READ_16( struct brw_compile *p,
 
 
 void brw_fb_WRITE(struct brw_compile *p,
-		   struct brw_reg dest,
-		   GLuint msg_reg_nr,
-		   struct brw_reg src0,
-		   GLuint binding_table_index,
-		   GLuint msg_length,
-		   GLuint response_length,
-		   GLboolean eot)
+                  struct brw_reg dest,
+                  GLuint msg_reg_nr,
+                  struct brw_reg src0,
+                  GLuint binding_table_index,
+                  GLuint msg_length,
+                  GLuint response_length,
+                  GLboolean eot)
 {
    struct brw_instruction *insn = next_insn(p, BRW_OPCODE_SEND);
    
@@ -973,8 +973,8 @@ void brw_SAMPLE(struct brw_compile *p,
 {
    GLboolean need_stall = 0;
    
-   if(writemask == 0) {
-/*       _mesa_printf("%s: zero writemask??\n", __FUNCTION__); */
+   if (writemask == 0) {
+      /*_mesa_printf("%s: zero writemask??\n", __FUNCTION__); */
       return;
    }
    
@@ -1006,7 +1006,7 @@ void brw_SAMPLE(struct brw_compile *p,
 
       if (newmask != writemask) {
 	 need_stall = 1;
-/* 	 _mesa_printf("need stall %x %x\n", newmask , writemask); */
+         /* _mesa_printf("need stall %x %x\n", newmask , writemask); */
       }
       else {
 	 struct brw_reg m1 = brw_message_reg(msg_reg_nr);
@@ -1047,8 +1047,7 @@ void brw_SAMPLE(struct brw_compile *p,
 			      eot);
    }
 
-   if (need_stall)
-   {
+   if (need_stall) {
       struct brw_reg reg = vec8(offset(dest, response_length-1));
 
       /*  mov (8) r9.0<1>:f    r9.0<8;8,1>:f    { Align1 }
diff --git a/src/mesa/drivers/dri/i965/brw_fallback.c b/src/mesa/drivers/dri/i965/brw_fallback.c
index 4ea660a..5f4f2d5 100644
--- a/src/mesa/drivers/dri/i965/brw_fallback.c
+++ b/src/mesa/drivers/dri/i965/brw_fallback.c
@@ -47,20 +47,12 @@ static GLboolean do_check_fallback(struct brw_context *brw)
    GLcontext *ctx = &brw->intel.ctx;
    GLuint i;
 
-   /* BRW_NEW_METAOPS
-    */
-   if (brw->metaops.active)
-      return GL_FALSE;
-
    if (brw->intel.no_rast) {
       DBG("FALLBACK: rasterization disabled\n");
       return GL_TRUE;
    }
 
    /* _NEW_RENDERMODE
-    *
-    * XXX: need to save/restore RenderMode in metaops state, or
-    * somehow move to a new attribs pointer:
     */
    if (ctx->RenderMode != GL_RENDER) {
       DBG("FALLBACK: render mode\n");
@@ -70,7 +62,7 @@ static GLboolean do_check_fallback(struct brw_context *brw)
    /* _NEW_TEXTURE:
     */
    for (i = 0; i < BRW_MAX_TEX_UNIT; i++) {
-      struct gl_texture_unit *texUnit = &brw->attribs.Texture->Unit[i];
+      struct gl_texture_unit *texUnit = &ctx->Texture.Unit[i];
       if (texUnit->_ReallyEnabled) {
 	 struct intel_texture_object *intelObj = intel_texture_object(texUnit->_Current);
 	 struct gl_texture_image *texImage = intelObj->base.Image[0][intelObj->firstLevel];
@@ -83,8 +75,8 @@ static GLboolean do_check_fallback(struct brw_context *brw)
    
    /* _NEW_STENCIL 
     */
-   if (brw->attribs.Stencil->Enabled && 
-       !brw->intel.hw_stencil) {
+   if (ctx->Stencil.Enabled &&
+       (ctx->DrawBuffer->Name == 0 && !brw->intel.hw_stencil)) {
       DBG("FALLBACK: stencil\n");
       return GL_TRUE;
    }
@@ -101,7 +93,7 @@ static void check_fallback(struct brw_context *brw)
 const struct brw_tracked_state brw_check_fallback = {
    .dirty = {
       .mesa = _NEW_BUFFERS | _NEW_RENDERMODE | _NEW_TEXTURE | _NEW_STENCIL,
-      .brw  = BRW_NEW_METAOPS,
+      .brw  = 0,
       .cache = 0
    },
    .prepare = check_fallback
diff --git a/src/mesa/drivers/dri/i965/brw_metaops.c b/src/mesa/drivers/dri/i965/brw_metaops.c
deleted file mode 100644
index 41bfa2e..0000000
--- a/src/mesa/drivers/dri/i965/brw_metaops.c
+++ /dev/null
@@ -1,583 +0,0 @@
-/*
- Copyright (C) Intel Corp.  2006.  All Rights Reserved.
- Intel funded Tungsten Graphics (http://www.tungstengraphics.com) to
- develop this 3D driver.
- 
- Permission is hereby granted, free of charge, to any person obtaining
- a copy of this software and associated documentation files (the
- "Software"), to deal in the Software without restriction, including
- without limitation the rights to use, copy, modify, merge, publish,
- distribute, sublicense, and/or sell copies of the Software, and to
- permit persons to whom the Software is furnished to do so, subject to
- the following conditions:
- 
- The above copyright notice and this permission notice (including the
- next paragraph) shall be included in all copies or substantial
- portions of the Software.
- 
- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
- LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- 
- **********************************************************************/
- /*
-  * Authors:
-  *   Keith Whitwell <keith@tungstengraphics.com>
-  *   frame buffer texture by Gary Wong <gtw@gnu.org>
-  */
- 
-
-
-#include "main/glheader.h"
-#include "main/context.h"
-#include "main/macros.h"
-
-#include "shader/arbprogparse.h"
-
-#include "intel_screen.h"
-#include "intel_batchbuffer.h"
-#include "intel_regions.h"
-#include "intel_buffers.h"
-
-#include "brw_context.h"
-#include "brw_defines.h"
-#include "brw_draw.h"
-#include "brw_fallback.h"
-
-#define INIT(brw, STRUCT, ATTRIB) 		\
-do {						\
-   brw->attribs.ATTRIB = &ctx->ATTRIB;		\
-} while (0)
-
-#define DUP(brw, STRUCT, ATTRIB) 		\
-do {						\
-   brw->metaops.attribs.ATTRIB = MALLOC_STRUCT(STRUCT);	\
-   memcpy(brw->metaops.attribs.ATTRIB, 			\
-	  brw->attribs.ATTRIB,			\
-	  sizeof(struct STRUCT));		\
-} while (0)
-
-
-#define INSTALL(brw, ATTRIB, STATE)		\
-do {						\
-   brw->attribs.ATTRIB = brw->metaops.attribs.ATTRIB;	\
-   brw->state.dirty.mesa |= STATE;		\
-} while (0)
-
-#define RESTORE(brw, ATTRIB, STATE)			\
-do {							\
-   brw->attribs.ATTRIB = &brw->intel.ctx.ATTRIB;	\
-   brw->state.dirty.mesa |= STATE;			\
-} while (0)
-
-static void init_attribs( struct brw_context *brw )
-{
-   DUP(brw, gl_colorbuffer_attrib, Color);
-   DUP(brw, gl_depthbuffer_attrib, Depth);
-   DUP(brw, gl_fog_attrib, Fog);
-   DUP(brw, gl_hint_attrib, Hint);
-   DUP(brw, gl_light_attrib, Light);
-   DUP(brw, gl_line_attrib, Line);
-   DUP(brw, gl_point_attrib, Point);
-   DUP(brw, gl_polygon_attrib, Polygon);
-   DUP(brw, gl_scissor_attrib, Scissor);
-   DUP(brw, gl_stencil_attrib, Stencil);
-   DUP(brw, gl_texture_attrib, Texture);
-   DUP(brw, gl_transform_attrib, Transform);
-   DUP(brw, gl_viewport_attrib, Viewport);
-   DUP(brw, gl_vertex_program_state, VertexProgram);
-   DUP(brw, gl_fragment_program_state, FragmentProgram);
-}
-
-static void install_attribs( struct brw_context *brw )
-{
-   INSTALL(brw, Color, _NEW_COLOR);
-   INSTALL(brw, Depth, _NEW_DEPTH);
-   INSTALL(brw, Fog, _NEW_FOG);
-   INSTALL(brw, Hint, _NEW_HINT);
-   INSTALL(brw, Light, _NEW_LIGHT);
-   INSTALL(brw, Line, _NEW_LINE);
-   INSTALL(brw, Point, _NEW_POINT);
-   INSTALL(brw, Polygon, _NEW_POLYGON);
-   INSTALL(brw, Scissor, _NEW_SCISSOR);
-   INSTALL(brw, Stencil, _NEW_STENCIL);
-   INSTALL(brw, Texture, _NEW_TEXTURE);
-   INSTALL(brw, Transform, _NEW_TRANSFORM);
-   INSTALL(brw, Viewport, _NEW_VIEWPORT);
-   INSTALL(brw, VertexProgram, _NEW_PROGRAM);
-   INSTALL(brw, FragmentProgram, _NEW_PROGRAM);
-}
-
-static void restore_attribs( struct brw_context *brw )
-{
-   RESTORE(brw, Color, _NEW_COLOR);
-   RESTORE(brw, Depth, _NEW_DEPTH);
-   RESTORE(brw, Fog, _NEW_FOG);
-   RESTORE(brw, Hint, _NEW_HINT);
-   RESTORE(brw, Light, _NEW_LIGHT);
-   RESTORE(brw, Line, _NEW_LINE);
-   RESTORE(brw, Point, _NEW_POINT);
-   RESTORE(brw, Polygon, _NEW_POLYGON);
-   RESTORE(brw, Scissor, _NEW_SCISSOR);
-   RESTORE(brw, Stencil, _NEW_STENCIL);
-   RESTORE(brw, Texture, _NEW_TEXTURE);
-   RESTORE(brw, Transform, _NEW_TRANSFORM);
-   RESTORE(brw, Viewport, _NEW_VIEWPORT);
-   RESTORE(brw, VertexProgram, _NEW_PROGRAM);
-   RESTORE(brw, FragmentProgram, _NEW_PROGRAM);
-}
-
-
-static const char *vp_prog =
-      "!!ARBvp1.0\n"
-      "MOV  result.color, vertex.color;\n"
-      "MOV  result.position, vertex.position;\n"
-      "END\n";
-
-static const char *fp_prog =
-      "!!ARBfp1.0\n"
-      "MOV result.color, fragment.color;\n"
-      "END\n";
-
-static const char *fp_tex_prog =
-      "!!ARBfp1.0\n"
-      "TEMP a;\n"
-      "ADD a, fragment.position, program.local[0];\n"
-      "MUL a, a, program.local[1];\n"
-      "TEX result.color, a, texture[0], 2D;\n"
-      "MOV result.depth.z, fragment.position;\n"
-      "END\n";
-
-/* Derived values of importance:
- *
- *   FragmentProgram->_Current
- *   VertexProgram->_Enabled
- *   brw->vertex_program
- *   DrawBuffer->_ColorDrawBufferIndexes[0]
- * 
- *
- * More if drawpixels-through-texture is added.  
- */
-static void init_metaops_state( struct brw_context *brw )
-{
-   GLcontext *ctx = &brw->intel.ctx;
-
-   brw->metaops.vbo = ctx->Driver.NewBufferObject(ctx, 1, GL_ARRAY_BUFFER_ARB);
-
-   ctx->Driver.BufferData(ctx,
-			  GL_ARRAY_BUFFER_ARB,
-			  4096,
-			  NULL,
-			  GL_DYNAMIC_DRAW_ARB,
-			  brw->metaops.vbo);
-
-   brw->metaops.fp = (struct gl_fragment_program *)
-      ctx->Driver.NewProgram(ctx, GL_FRAGMENT_PROGRAM_ARB, 1 );
-
-   brw->metaops.fp_tex = (struct gl_fragment_program *)
-      ctx->Driver.NewProgram(ctx, GL_FRAGMENT_PROGRAM_ARB, 1 );
-
-   brw->metaops.vp = (struct gl_vertex_program *)
-      ctx->Driver.NewProgram(ctx, GL_VERTEX_PROGRAM_ARB, 1 );
-
-   _mesa_parse_arb_fragment_program(ctx, GL_FRAGMENT_PROGRAM_ARB, 
-				    fp_prog, strlen(fp_prog),
-				    brw->metaops.fp);
-
-   _mesa_parse_arb_fragment_program(ctx, GL_FRAGMENT_PROGRAM_ARB, 
-				    fp_tex_prog, strlen(fp_tex_prog),
-				    brw->metaops.fp_tex);
-
-   _mesa_parse_arb_vertex_program(ctx, GL_VERTEX_PROGRAM_ARB, 
-				  vp_prog, strlen(vp_prog),
-				  brw->metaops.vp);
-
-   brw->metaops.attribs.VertexProgram->_Current = brw->metaops.vp;
-   brw->metaops.attribs.VertexProgram->_Enabled = GL_TRUE;
-
-   brw->metaops.attribs.FragmentProgram->_Current = brw->metaops.fp;
-}
-
-static void meta_flat_shade( struct intel_context *intel )
-{
-   struct brw_context *brw = brw_context(&intel->ctx);
-
-   brw->metaops.attribs.Light->ShadeModel = GL_FLAT;
-   brw->state.dirty.mesa |= _NEW_LIGHT;
-}
-
-
-static void meta_no_stencil_write( struct intel_context *intel )
-{
-   struct brw_context *brw = brw_context(&intel->ctx);
-
-   brw->metaops.attribs.Stencil->Enabled = GL_FALSE;
-   brw->metaops.attribs.Stencil->WriteMask[0] = GL_FALSE; 
-   brw->state.dirty.mesa |= _NEW_STENCIL;
-}
-
-static void meta_no_depth_write( struct intel_context *intel )
-{
-   struct brw_context *brw = brw_context(&intel->ctx);
-
-   brw->metaops.attribs.Depth->Test = GL_FALSE;
-   brw->metaops.attribs.Depth->Mask = GL_FALSE;
-   brw->state.dirty.mesa |= _NEW_DEPTH;
-}
-
-
-static void meta_depth_replace( struct intel_context *intel )
-{
-   struct brw_context *brw = brw_context(&intel->ctx);
-
-   /* ctx->Driver.Enable( ctx, GL_DEPTH_TEST, GL_TRUE )
-    * ctx->Driver.DepthMask( ctx, GL_TRUE )
-    */
-   brw->metaops.attribs.Depth->Test = GL_TRUE;
-   brw->metaops.attribs.Depth->Mask = GL_TRUE;
-   brw->state.dirty.mesa |= _NEW_DEPTH;
-
-   /* ctx->Driver.DepthFunc( ctx, GL_ALWAYS )
-    */
-   brw->metaops.attribs.Depth->Func = GL_ALWAYS;
-
-   brw->state.dirty.mesa |= _NEW_DEPTH;
-}
-
-
-static void meta_stencil_replace( struct intel_context *intel,
-				 GLuint s_mask,
-				 GLuint s_clear)
-{
-   struct brw_context *brw = brw_context(&intel->ctx);
-
-   brw->metaops.attribs.Stencil->Enabled = GL_TRUE;
-   brw->metaops.attribs.Stencil->WriteMask[0] = s_mask;
-   brw->metaops.attribs.Stencil->ValueMask[0] = 0xff;
-   brw->metaops.attribs.Stencil->Ref[0] = s_clear;
-   brw->metaops.attribs.Stencil->Function[0] = GL_ALWAYS;
-   brw->metaops.attribs.Stencil->FailFunc[0] = GL_REPLACE;
-   brw->metaops.attribs.Stencil->ZPassFunc[0] = GL_REPLACE;
-   brw->metaops.attribs.Stencil->ZFailFunc[0] = GL_REPLACE;
-   brw->state.dirty.mesa |= _NEW_STENCIL;
-}
-
-
-static void meta_color_mask( struct intel_context *intel, GLboolean state )
-{
-   struct brw_context *brw = brw_context(&intel->ctx);
-
-   if (state)
-      COPY_4V(brw->metaops.attribs.Color->ColorMask, 
-	      brw->intel.ctx.Color.ColorMask); 
-   else
-      ASSIGN_4V(brw->metaops.attribs.Color->ColorMask, 0, 0, 0, 0);
-
-   brw->state.dirty.mesa |= _NEW_COLOR;
-}
-
-static void meta_no_texture( struct intel_context *intel )
-{
-   struct brw_context *brw = brw_context(&intel->ctx);
-   
-   brw->metaops.attribs.FragmentProgram->_Current = brw->metaops.fp;
-   
-   brw->metaops.attribs.Texture->CurrentUnit = 0;
-   brw->metaops.attribs.Texture->_EnabledUnits = 0;
-   brw->metaops.attribs.Texture->_EnabledCoordUnits = 0;
-   brw->metaops.attribs.Texture->Unit[ 0 ].Enabled = 0;
-   brw->metaops.attribs.Texture->Unit[ 0 ]._ReallyEnabled = 0;
-
-   brw->state.dirty.mesa |= _NEW_TEXTURE | _NEW_PROGRAM;
-}
-
-static void meta_texture_blend_replace(struct intel_context *intel)
-{
-   struct brw_context *brw = brw_context(&intel->ctx);
-
-   brw->metaops.attribs.Texture->CurrentUnit = 0;
-   brw->metaops.attribs.Texture->_EnabledUnits = 1;
-   brw->metaops.attribs.Texture->_EnabledCoordUnits = 1;
-   brw->metaops.attribs.Texture->Unit[ 0 ].Enabled = TEXTURE_2D_BIT;
-   brw->metaops.attribs.Texture->Unit[ 0 ]._ReallyEnabled = TEXTURE_2D_BIT;
-   brw->metaops.attribs.Texture->Unit[ 0 ].Current2D =
-      intel->frame_buffer_texobj;
-   brw->metaops.attribs.Texture->Unit[ 0 ]._Current =
-      intel->frame_buffer_texobj;
-
-   brw->state.dirty.mesa |= _NEW_TEXTURE | _NEW_PROGRAM;
-}
-
-static void meta_import_pixel_state(struct intel_context *intel)
-{
-   struct brw_context *brw = brw_context(&intel->ctx);
-   
-   RESTORE(brw, Color, _NEW_COLOR);
-   RESTORE(brw, Depth, _NEW_DEPTH);
-   RESTORE(brw, Fog, _NEW_FOG);
-   RESTORE(brw, Scissor, _NEW_SCISSOR);
-   RESTORE(brw, Stencil, _NEW_STENCIL);
-   RESTORE(brw, Texture, _NEW_TEXTURE);
-   RESTORE(brw, FragmentProgram, _NEW_PROGRAM);
-}
-
-static void meta_frame_buffer_texture( struct intel_context *intel,
-				       GLint xoff, GLint yoff )
-{
-   struct brw_context *brw = brw_context(&intel->ctx);
-   struct intel_region *region = intel_drawbuf_region( intel );
-   
-   INSTALL(brw, FragmentProgram, _NEW_PROGRAM);
-
-   brw->metaops.attribs.FragmentProgram->_Current = brw->metaops.fp_tex;
-   /* This is unfortunate, but seems to be necessary, since later on we
-      will end up calling _mesa_load_state_parameters to lookup the
-      local params (below), and that will want to look in ctx.FragmentProgram
-      instead of brw->attribs.FragmentProgram. */
-   intel->ctx.FragmentProgram.Current = brw->metaops.fp_tex;
-
-   brw->metaops.fp_tex->Base.LocalParams[ 0 ][ 0 ] = xoff;
-   brw->metaops.fp_tex->Base.LocalParams[ 0 ][ 1 ] = yoff;
-   brw->metaops.fp_tex->Base.LocalParams[ 0 ][ 2 ] = 0.0;
-   brw->metaops.fp_tex->Base.LocalParams[ 0 ][ 3 ] = 0.0;
-   brw->metaops.fp_tex->Base.LocalParams[ 1 ][ 0 ] =
-      1.0 / region->pitch;
-   brw->metaops.fp_tex->Base.LocalParams[ 1 ][ 1 ] =
-      -1.0 / region->height;
-   brw->metaops.fp_tex->Base.LocalParams[ 1 ][ 2 ] = 0.0;
-   brw->metaops.fp_tex->Base.LocalParams[ 1 ][ 3 ] = 1.0;
-   
-   brw->state.dirty.mesa |= _NEW_PROGRAM;
-}
-
-
-static void meta_draw_region( struct intel_context *intel,
-			     struct intel_region *draw_region,
-			     struct intel_region *depth_region )
-{
-   struct brw_context *brw = brw_context(&intel->ctx);
-
-   if (!brw->metaops.saved_draw_region) {
-      brw->metaops.saved_draw_region = brw->state.draw_regions[0];
-      brw->metaops.saved_nr_draw_regions = brw->state.nr_draw_regions;
-      brw->metaops.saved_depth_region = brw->state.depth_region;
-   }
-
-   brw->state.draw_regions[0] = draw_region;
-   brw->state.nr_draw_regions = 1;
-   brw->state.depth_region = depth_region;
-
-   if (intel->frame_buffer_texobj != NULL)
-      brw_FrameBufferTexDestroy(brw);
-
-   if (draw_region)
-       brw_FrameBufferTexInit(brw, draw_region);
-
-   brw->state.dirty.mesa |= _NEW_BUFFERS;
-}
-
-
-static void meta_draw_quad(struct intel_context *intel, 
-			   GLfloat x0, GLfloat x1,
-			   GLfloat y0, GLfloat y1, 
-			   GLfloat z,
-			   GLuint color,
-			   GLfloat s0, GLfloat s1,
-			   GLfloat t0, GLfloat t1)
-{
-   GLcontext *ctx = &intel->ctx;
-   struct brw_context *brw = brw_context(&intel->ctx);
-   struct gl_client_array pos_array;
-   struct gl_client_array color_array;
-   struct gl_client_array *attribs[VERT_ATTRIB_MAX];
-   struct _mesa_prim prim[1];
-   GLfloat pos[4][3];
-
-   ctx->Driver.BufferData(ctx,
-			  GL_ARRAY_BUFFER_ARB,
-			  sizeof(pos) + sizeof(color),
-			  NULL,
-			  GL_DYNAMIC_DRAW_ARB,
-			  brw->metaops.vbo);
-
-   pos[0][0] = x0;
-   pos[0][1] = y0;
-   pos[0][2] = z;
-
-   pos[1][0] = x1;
-   pos[1][1] = y0;
-   pos[1][2] = z;
-
-   pos[2][0] = x1;
-   pos[2][1] = y1;
-   pos[2][2] = z;
-
-   pos[3][0] = x0;
-   pos[3][1] = y1;
-   pos[3][2] = z;
-
-   ctx->Driver.BufferSubData(ctx,
-			     GL_ARRAY_BUFFER_ARB,
-			     0,
-			     sizeof(pos),
-			     pos,
-			     brw->metaops.vbo);
-
-   /* Convert incoming ARGB to required RGBA */
-   /* Note this color is stored as GL_UNSIGNED_BYTE */
-   color = (color & 0xff00ff00) | (((color >> 16) | (color << 16)) & 0xff00ff);
-
-   ctx->Driver.BufferSubData(ctx,
-			     GL_ARRAY_BUFFER_ARB,
-			     sizeof(pos),
-			     sizeof(color),
-			     &color,
-			     brw->metaops.vbo);
-
-   /* Ignoring texture coords. 
-    */
-
-   memset(attribs, 0, VERT_ATTRIB_MAX * sizeof(*attribs));
-
-   attribs[VERT_ATTRIB_POS] = &pos_array;
-   attribs[VERT_ATTRIB_POS]->Ptr = 0;
-   attribs[VERT_ATTRIB_POS]->Type = GL_FLOAT;
-   attribs[VERT_ATTRIB_POS]->Enabled = 1;
-   attribs[VERT_ATTRIB_POS]->Size = 3;
-   attribs[VERT_ATTRIB_POS]->StrideB = 3 * sizeof(GLfloat);
-   attribs[VERT_ATTRIB_POS]->Stride = 3 * sizeof(GLfloat);
-   attribs[VERT_ATTRIB_POS]->_MaxElement = 4;
-   attribs[VERT_ATTRIB_POS]->Normalized = 0;
-   attribs[VERT_ATTRIB_POS]->BufferObj = brw->metaops.vbo;
-
-   attribs[VERT_ATTRIB_COLOR0] = &color_array;
-   attribs[VERT_ATTRIB_COLOR0]->Ptr = (const GLubyte *)sizeof(pos);
-   attribs[VERT_ATTRIB_COLOR0]->Type = GL_UNSIGNED_BYTE;
-   attribs[VERT_ATTRIB_COLOR0]->Enabled = 1;
-   attribs[VERT_ATTRIB_COLOR0]->Size = 4;
-   attribs[VERT_ATTRIB_COLOR0]->StrideB = 0;
-   attribs[VERT_ATTRIB_COLOR0]->Stride = 0;
-   attribs[VERT_ATTRIB_COLOR0]->_MaxElement = 1;
-   attribs[VERT_ATTRIB_COLOR0]->Normalized = 1;
-   attribs[VERT_ATTRIB_COLOR0]->BufferObj = brw->metaops.vbo;
-   
-   /* Just ignoring texture coordinates for now. 
-    */
-
-   memset(prim, 0, sizeof(*prim));
-
-   prim[0].mode = GL_TRIANGLE_FAN;
-   prim[0].begin = 1;
-   prim[0].end = 1;
-   prim[0].weak = 0;
-   prim[0].pad = 0;
-   prim[0].start = 0;
-   prim[0].count = 4;
-
-   brw_draw_prims(&brw->intel.ctx, 
-		  (const struct gl_client_array **)attribs,
-		  prim, 1,
-		  NULL,
-		  0,
-		  3 );
-}
-
-
-static void install_meta_state( struct intel_context *intel )
-{
-   GLcontext *ctx = &intel->ctx;
-   struct brw_context *brw = brw_context(ctx);
-   GLuint i;
-
-   if (!brw->metaops.vbo) {
-      init_metaops_state(brw);
-   }
-
-   install_attribs(brw);
-   
-   meta_no_texture(&brw->intel);
-   meta_flat_shade(&brw->intel);
-   for (i = 0; i < ctx->Const.MaxDrawBuffers; i++) {
-      brw->metaops.restore_draw_buffers[i]
-         = ctx->DrawBuffer->_ColorDrawBufferIndexes[i];
-   }
-   brw->metaops.restore_num_draw_buffers = ctx->DrawBuffer->_NumColorDrawBuffers;
-
-   brw->metaops.restore_fp = ctx->FragmentProgram.Current;
-
-   /* This works without adjusting refcounts.  Fix later? 
-    */
-   brw->metaops.saved_draw_region = brw->state.draw_regions[0];
-   brw->metaops.saved_nr_draw_regions = brw->state.nr_draw_regions;
-   brw->metaops.saved_depth_region = brw->state.depth_region;
-   brw->metaops.active = 1;
-   
-   brw->state.dirty.brw |= BRW_NEW_METAOPS;
-}
-
-static void leave_meta_state( struct intel_context *intel )
-{
-   GLcontext *ctx = &intel->ctx;
-   struct brw_context *brw = brw_context(ctx);
-   GLuint i;
-
-   restore_attribs(brw);
-
-   for (i = 0; i < ctx->Const.MaxDrawBuffers; i++) {
-      ctx->DrawBuffer->_ColorDrawBufferIndexes[i]
-         = brw->metaops.restore_draw_buffers[i];
-   }
-   ctx->DrawBuffer->_NumColorDrawBuffers = brw->metaops.restore_num_draw_buffers;
-
-   ctx->FragmentProgram.Current = brw->metaops.restore_fp;
-
-   brw->state.draw_regions[0] = brw->metaops.saved_draw_region;
-   brw->state.nr_draw_regions = brw->metaops.saved_nr_draw_regions;
-   brw->state.depth_region = brw->metaops.saved_depth_region;
-   brw->metaops.saved_draw_region = NULL;
-   brw->metaops.saved_depth_region = NULL;
-   brw->metaops.active = 0;
-
-   brw->state.dirty.mesa |= _NEW_BUFFERS;
-   brw->state.dirty.brw |= BRW_NEW_METAOPS;
-}
-
-
-
-void brw_init_metaops( struct brw_context *brw )
-{
-   init_attribs(brw);
-
-
-   brw->intel.vtbl.install_meta_state = install_meta_state;
-   brw->intel.vtbl.leave_meta_state = leave_meta_state;
-   brw->intel.vtbl.meta_no_depth_write = meta_no_depth_write;
-   brw->intel.vtbl.meta_no_stencil_write = meta_no_stencil_write;
-   brw->intel.vtbl.meta_stencil_replace = meta_stencil_replace;
-   brw->intel.vtbl.meta_depth_replace = meta_depth_replace;
-   brw->intel.vtbl.meta_color_mask = meta_color_mask;
-   brw->intel.vtbl.meta_no_texture = meta_no_texture;
-   brw->intel.vtbl.meta_import_pixel_state = meta_import_pixel_state;
-   brw->intel.vtbl.meta_frame_buffer_texture = meta_frame_buffer_texture;
-   brw->intel.vtbl.meta_draw_region = meta_draw_region;
-   brw->intel.vtbl.meta_draw_quad = meta_draw_quad;
-   brw->intel.vtbl.meta_texture_blend_replace = meta_texture_blend_replace;
-/*    brw->intel.vtbl.meta_tex_rect_source = meta_tex_rect_source; */
-/*    brw->intel.vtbl.meta_draw_format = set_draw_format; */
-}
-
-void brw_destroy_metaops( struct brw_context *brw )
-{
-   GLcontext *ctx = &brw->intel.ctx;
-
-   if (brw->metaops.vbo)
-      ctx->Driver.DeleteBuffer( ctx, brw->metaops.vbo );
-
-/*    ctx->Driver.DeleteProgram( ctx, brw->metaops.fp ); */
-/*    ctx->Driver.DeleteProgram( ctx, brw->metaops.fp_tex ); */
-/*    ctx->Driver.DeleteProgram( ctx, brw->metaops.vp ); */
-}
diff --git a/src/mesa/drivers/dri/i965/brw_misc_state.c b/src/mesa/drivers/dri/i965/brw_misc_state.c
index 627705f..40cb7a3 100644
--- a/src/mesa/drivers/dri/i965/brw_misc_state.c
+++ b/src/mesa/drivers/dri/i965/brw_misc_state.c
@@ -48,15 +48,16 @@
 
 static void upload_blend_constant_color(struct brw_context *brw)
 {
+   GLcontext *ctx = &brw->intel.ctx;
    struct brw_blend_constant_color bcc;
 
    memset(&bcc, 0, sizeof(bcc));      
    bcc.header.opcode = CMD_BLEND_CONSTANT_COLOR;
    bcc.header.length = sizeof(bcc)/4-2;
-   bcc.blend_constant_color[0] = brw->attribs.Color->BlendColor[0];
-   bcc.blend_constant_color[1] = brw->attribs.Color->BlendColor[1];
-   bcc.blend_constant_color[2] = brw->attribs.Color->BlendColor[2];
-   bcc.blend_constant_color[3] = brw->attribs.Color->BlendColor[3];
+   bcc.blend_constant_color[0] = ctx->Color.BlendColor[0];
+   bcc.blend_constant_color[1] = ctx->Color.BlendColor[1];
+   bcc.blend_constant_color[2] = ctx->Color.BlendColor[2];
+   bcc.blend_constant_color[3] = ctx->Color.BlendColor[3];
 
    BRW_CACHED_BATCH_STRUCT(brw, &bcc);
 }
@@ -154,10 +155,7 @@ static void upload_pipelined_state_pointers(struct brw_context *brw )
       OUT_RELOC(brw->gs.state_bo, I915_GEM_DOMAIN_INSTRUCTION, 0, 1);
    else
       OUT_BATCH(0);
-   if (!brw->metaops.active)
-      OUT_RELOC(brw->clip.state_bo, I915_GEM_DOMAIN_INSTRUCTION, 0, 1);
-   else
-      OUT_BATCH(0);
+   OUT_RELOC(brw->clip.state_bo, I915_GEM_DOMAIN_INSTRUCTION, 0, 1);
    OUT_RELOC(brw->sf.state_bo, I915_GEM_DOMAIN_INSTRUCTION, 0, 0);
    OUT_RELOC(brw->wm.state_bo, I915_GEM_DOMAIN_INSTRUCTION, 0, 0);
    OUT_RELOC(brw->cc.state_bo, I915_GEM_DOMAIN_INSTRUCTION, 0, 0);
@@ -180,13 +178,13 @@ static void upload_psp_urb_cbs(struct brw_context *brw )
 {
    upload_pipelined_state_pointers(brw);
    brw_upload_urb_fence(brw);
-   brw_upload_constant_buffer_state(brw);
+   brw_upload_cs_urb_state(brw);
 }
 
 const struct brw_tracked_state brw_psp_urb_cbs = {
    .dirty = {
       .mesa = 0,
-      .brw = BRW_NEW_URB_FENCE | BRW_NEW_METAOPS | BRW_NEW_BATCH,
+      .brw = BRW_NEW_URB_FENCE | BRW_NEW_BATCH,
       .cache = (CACHE_NEW_VS_UNIT | 
 		CACHE_NEW_GS_UNIT | 
 		CACHE_NEW_GS_PROG | 
@@ -284,6 +282,7 @@ const struct brw_tracked_state brw_depthbuffer = {
 
 static void upload_polygon_stipple(struct brw_context *brw)
 {
+   GLcontext *ctx = &brw->intel.ctx;
    struct brw_polygon_stipple bps;
    GLuint i;
 
@@ -292,7 +291,7 @@ static void upload_polygon_stipple(struct brw_context *brw)
    bps.header.length = sizeof(bps)/4-2;
 
    for (i = 0; i < 32; i++)
-      bps.stipple[i] = brw->attribs.PolygonStipple[31 - i]; /* invert */
+      bps.stipple[i] = ctx->PolygonStipple[31 - i]; /* invert */
 
    BRW_CACHED_BATCH_STRUCT(brw, &bps);
 }
@@ -370,6 +369,7 @@ const struct brw_tracked_state brw_aa_line_parameters = {
 
 static void upload_line_stipple(struct brw_context *brw)
 {
+   GLcontext *ctx = &brw->intel.ctx;
    struct brw_line_stipple bls;
    GLfloat tmp;
    GLint tmpi;
@@ -378,10 +378,10 @@ static void upload_line_stipple(struct brw_context *brw)
    bls.header.opcode = CMD_LINE_STIPPLE_PATTERN;
    bls.header.length = sizeof(bls)/4 - 2;
 
-   bls.bits0.pattern = brw->attribs.Line->StipplePattern;
-   bls.bits1.repeat_count = brw->attribs.Line->StippleFactor;
+   bls.bits0.pattern = ctx->Line.StipplePattern;
+   bls.bits1.repeat_count = ctx->Line.StippleFactor;
 
-   tmp = 1.0 / (GLfloat) brw->attribs.Line->StippleFactor;
+   tmp = 1.0 / (GLfloat) ctx->Line.StippleFactor;
    tmpi = tmp * (1<<13);
 
 
diff --git a/src/mesa/drivers/dri/i965/brw_program.c b/src/mesa/drivers/dri/i965/brw_program.c
index 0c86911..774180c 100644
--- a/src/mesa/drivers/dri/i965/brw_program.c
+++ b/src/mesa/drivers/dri/i965/brw_program.c
@@ -94,7 +94,6 @@ static struct gl_program *brwNewProgram( GLcontext *ctx,
 static void brwDeleteProgram( GLcontext *ctx,
 			      struct gl_program *prog )
 {
-   
    _mesa_delete_program( ctx, prog );
 }
 
@@ -110,30 +109,29 @@ static void brwProgramStringNotify( GLcontext *ctx,
 				    GLenum target,
 				    struct gl_program *prog )
 {
+   struct brw_context *brw = brw_context(ctx);
    if (target == GL_FRAGMENT_PROGRAM_ARB) {
       struct gl_fragment_program *fprog = (struct gl_fragment_program *) prog;
-      struct brw_context *brw = brw_context(ctx);
-      struct brw_fragment_program *p = (struct brw_fragment_program *)prog;
-      struct brw_fragment_program *fp = (struct brw_fragment_program *)brw->fragment_program;
+      struct brw_fragment_program *newFP = (struct brw_fragment_program *) prog;
+      struct brw_fragment_program *curFP = (struct brw_fragment_program *) brw->fragment_program;
       if (fprog->FogOption) {
          _mesa_append_fog_code(ctx, fprog);
          fprog->FogOption = GL_NONE;
       }
 
-      if (p == fp)
+      if (newFP == curFP)
 	 brw->state.dirty.brw |= BRW_NEW_FRAGMENT_PROGRAM;
-      p->id = brw->program_id++;      
+      newFP->id = brw->program_id++;      
    }
    else if (target == GL_VERTEX_PROGRAM_ARB) {
-      struct brw_context *brw = brw_context(ctx);
-      struct brw_vertex_program *p = (struct brw_vertex_program *)prog;
-      struct brw_vertex_program *vp = (struct brw_vertex_program *)brw->vertex_program;
-      if (p == vp)
+      struct brw_vertex_program *newVP = (struct brw_vertex_program *) prog;
+      struct brw_vertex_program *curVP = (struct brw_vertex_program *) brw->vertex_program;
+      if (newVP == curVP)
 	 brw->state.dirty.brw |= BRW_NEW_VERTEX_PROGRAM;
-      if (p->program.IsPositionInvariant) {
-	 _mesa_insert_mvp_code(ctx, &p->program);
+      if (newVP->program.IsPositionInvariant) {
+	 _mesa_insert_mvp_code(ctx, &newVP->program);
       }
-      p->id = brw->program_id++;      
+      newVP->id = brw->program_id++;      
 
       /* Also tell tnl about it:
        */
diff --git a/src/mesa/drivers/dri/i965/brw_sf.c b/src/mesa/drivers/dri/i965/brw_sf.c
index 1a11d54..8c17115 100644
--- a/src/mesa/drivers/dri/i965/brw_sf.c
+++ b/src/mesa/drivers/dri/i965/brw_sf.c
@@ -46,6 +46,7 @@
 static void compile_sf_prog( struct brw_context *brw,
 			     struct brw_sf_prog_key *key )
 {
+   GLcontext *ctx = &brw->intel.ctx;
    struct brw_sf_compile c;
    const GLuint *program;
    GLuint program_size;
@@ -74,7 +75,7 @@ static void compile_sf_prog( struct brw_context *brw,
 	 c.idx_to_attr[idx] = i;
 	 if (i >= VERT_RESULT_TEX0 && i <= VERT_RESULT_TEX7) {
             c.point_attrs[i].CoordReplace = 
-               brw->attribs.Point->CoordReplace[i - VERT_RESULT_TEX0];
+               ctx->Point.CoordReplace[i - VERT_RESULT_TEX0];
 	 }
          else {
             c.point_attrs[i].CoordReplace = GL_FALSE;
@@ -128,6 +129,7 @@ static void compile_sf_prog( struct brw_context *brw,
  */
 static void upload_sf_prog(struct brw_context *brw)
 {
+   GLcontext *ctx = &brw->intel.ctx;
    struct brw_sf_prog_key key;
 
    memset(&key, 0, sizeof(key));
@@ -158,15 +160,15 @@ static void upload_sf_prog(struct brw_context *brw)
       break;
    }
 
-   key.do_point_sprite = brw->attribs.Point->PointSprite;
-   key.SpriteOrigin = brw->attribs.Point->SpriteOrigin;
+   key.do_point_sprite = ctx->Point.PointSprite;
+   key.SpriteOrigin = ctx->Point.SpriteOrigin;
    /* _NEW_LIGHT */
-   key.do_flat_shading = (brw->attribs.Light->ShadeModel == GL_FLAT);
-   key.do_twoside_color = (brw->attribs.Light->Enabled && brw->attribs.Light->Model.TwoSide);
+   key.do_flat_shading = (ctx->Light.ShadeModel == GL_FLAT);
+   key.do_twoside_color = (ctx->Light.Enabled && ctx->Light.Model.TwoSide);
 
    /* _NEW_POLYGON */
    if (key.do_twoside_color)
-      key.frontface_ccw = (brw->attribs.Polygon->FrontFace == GL_CCW);
+      key.frontface_ccw = (ctx->Polygon.FrontFace == GL_CCW);
 
    dri_bo_unreference(brw->sf.prog_bo);
    brw->sf.prog_bo = brw_search_cache(&brw->cache, BRW_SF_PROG,
diff --git a/src/mesa/drivers/dri/i965/brw_sf_state.c b/src/mesa/drivers/dri/i965/brw_sf_state.c
index 242b704..e96d535 100644
--- a/src/mesa/drivers/dri/i965/brw_sf_state.c
+++ b/src/mesa/drivers/dri/i965/brw_sf_state.c
@@ -43,10 +43,11 @@ static void upload_sf_vp(struct brw_context *brw)
    const GLfloat depth_scale = 1.0F / ctx->DrawBuffer->_DepthMaxF;
    struct brw_sf_viewport sfv;
    GLfloat y_scale, y_bias;
+   const GLboolean render_to_fbo = (ctx->DrawBuffer->Name != 0);
 
    memset(&sfv, 0, sizeof(sfv));
 
-   if (intel_rendering_to_texture(ctx)) {
+   if (render_to_fbo) {
       y_scale = 1.0;
       y_bias = 0;
    }
@@ -55,25 +56,16 @@ static void upload_sf_vp(struct brw_context *brw)
       y_bias = ctx->DrawBuffer->Height;
    }
 
-   /* _NEW_VIEWPORT, BRW_NEW_METAOPS */
-
-   if (!brw->metaops.active) {
-      const GLfloat *v = ctx->Viewport._WindowMap.m;
-
-      sfv.viewport.m00 = v[MAT_SX];
-      sfv.viewport.m11 = v[MAT_SY] * y_scale;
-      sfv.viewport.m22 = v[MAT_SZ] * depth_scale;
-      sfv.viewport.m30 = v[MAT_TX];
-      sfv.viewport.m31 = v[MAT_TY] * y_scale + y_bias;
-      sfv.viewport.m32 = v[MAT_TZ] * depth_scale;
-   } else {
-      sfv.viewport.m00 =   1;
-      sfv.viewport.m11 = - 1;
-      sfv.viewport.m22 =   1;
-      sfv.viewport.m30 =   0;
-      sfv.viewport.m31 =   ctx->DrawBuffer->Height;
-      sfv.viewport.m32 =   0;
-   }
+   /* _NEW_VIEWPORT */
+
+   const GLfloat *v = ctx->Viewport._WindowMap.m;
+
+   sfv.viewport.m00 = v[MAT_SX];
+   sfv.viewport.m11 = v[MAT_SY] * y_scale;
+   sfv.viewport.m22 = v[MAT_SZ] * depth_scale;
+   sfv.viewport.m30 = v[MAT_TX];
+   sfv.viewport.m31 = v[MAT_TY] * y_scale + y_bias;
+   sfv.viewport.m32 = v[MAT_TZ] * depth_scale;
 
    /* _NEW_SCISSOR */
 
@@ -84,10 +76,20 @@ static void upload_sf_vp(struct brw_context *brw)
     * Note that the hardware's coordinates are inclusive, while Mesa's min is
     * inclusive but max is exclusive.
     */
-   sfv.scissor.xmin = ctx->DrawBuffer->_Xmin;
-   sfv.scissor.xmax = ctx->DrawBuffer->_Xmax - 1;
-   sfv.scissor.ymin = ctx->DrawBuffer->Height - ctx->DrawBuffer->_Ymax;
-   sfv.scissor.ymax = ctx->DrawBuffer->Height - ctx->DrawBuffer->_Ymin - 1;
+   if (render_to_fbo) {
+      /* texmemory: Y=0=bottom */
+      sfv.scissor.xmin = ctx->DrawBuffer->_Xmin;
+      sfv.scissor.xmax = ctx->DrawBuffer->_Xmax - 1;
+      sfv.scissor.ymin = ctx->DrawBuffer->_Ymin;
+      sfv.scissor.ymax = ctx->DrawBuffer->_Ymax - 1;
+   }
+   else {
+      /* memory: Y=0=top */
+      sfv.scissor.xmin = ctx->DrawBuffer->_Xmin;
+      sfv.scissor.xmax = ctx->DrawBuffer->_Xmax - 1;
+      sfv.scissor.ymin = ctx->DrawBuffer->Height - ctx->DrawBuffer->_Ymax;
+      sfv.scissor.ymax = ctx->DrawBuffer->Height - ctx->DrawBuffer->_Ymin - 1;
+   }
 
    dri_bo_unreference(brw->sf.vp_bo);
    brw->sf.vp_bo = brw_cache_data( &brw->cache, BRW_SF_VP, &sfv, NULL, 0 );
@@ -97,7 +99,7 @@ const struct brw_tracked_state brw_sf_vp = {
    .dirty = {
       .mesa  = (_NEW_VIEWPORT | 
 		_NEW_SCISSOR),
-      .brw   = BRW_NEW_METAOPS,
+      .brw   = 0,
       .cache = 0
    },
    .prepare = upload_sf_vp
@@ -110,15 +112,19 @@ struct brw_sf_unit_key {
    unsigned int nr_urb_entries, urb_size, sfsize;
 
    GLenum front_face, cull_face;
-   GLboolean scissor, line_smooth, point_sprite, point_attenuated;
+   unsigned scissor:1;
+   unsigned line_smooth:1;
+   unsigned point_sprite:1;
+   unsigned point_attenuated:1;
+   unsigned render_to_fbo:1;
    float line_width;
    float point_size;
-   GLboolean render_to_texture;
 };
 
 static void
 sf_unit_populate_key(struct brw_context *brw, struct brw_sf_unit_key *key)
 {
+   GLcontext *ctx = &brw->intel.ctx;
    memset(key, 0, sizeof(*key));
 
    /* CACHE_NEW_SF_PROG */
@@ -130,22 +136,22 @@ sf_unit_populate_key(struct brw_context *brw, struct brw_sf_unit_key *key)
    key->urb_size = brw->urb.vsize;
    key->sfsize = brw->urb.sfsize;
 
-   key->scissor = brw->attribs.Scissor->Enabled;
-   key->front_face = brw->attribs.Polygon->FrontFace;
+   key->scissor = ctx->Scissor.Enabled;
+   key->front_face = ctx->Polygon.FrontFace;
 
-   if (brw->attribs.Polygon->CullFlag)
-      key->cull_face = brw->attribs.Polygon->CullFaceMode;
+   if (ctx->Polygon.CullFlag)
+      key->cull_face = ctx->Polygon.CullFaceMode;
    else
       key->cull_face = GL_NONE;
 
-   key->line_width = brw->attribs.Line->Width;
-   key->line_smooth = brw->attribs.Line->SmoothFlag;
+   key->line_width = ctx->Line.Width;
+   key->line_smooth = ctx->Line.SmoothFlag;
 
-   key->point_sprite = brw->attribs.Point->PointSprite;
-   key->point_size = brw->attribs.Point->Size;
-   key->point_attenuated = brw->attribs.Point->_Attenuated;
+   key->point_sprite = ctx->Point.PointSprite;
+   key->point_size = ctx->Point.Size;
+   key->point_attenuated = ctx->Point._Attenuated;
 
-   key->render_to_texture = intel_rendering_to_texture(&brw->intel.ctx);
+   key->render_to_fbo = brw->intel.ctx.DrawBuffer->Name != 0;
 }
 
 static dri_bo *
@@ -192,10 +198,10 @@ sf_unit_create_from_key(struct brw_context *brw, struct brw_sf_unit_key *key,
    else
       sf.sf5.front_winding = BRW_FRONTWINDING_CW;
 
-   /* The viewport is inverted for rendering to texture, and that inverts
+   /* The viewport is inverted for rendering to a FBO, and that inverts
     * polygon front/back orientation.
     */
-   sf.sf5.front_winding ^= key->render_to_texture;
+   sf.sf5.front_winding ^= key->render_to_fbo;
 
    switch (key->cull_face) {
    case GL_FRONT:
@@ -295,8 +301,7 @@ const struct brw_tracked_state brw_sf_unit = {
 		_NEW_LINE | 
 		_NEW_POINT | 
 		_NEW_SCISSOR),
-      .brw   = (BRW_NEW_URB_FENCE |
-		BRW_NEW_METAOPS),
+      .brw   = BRW_NEW_URB_FENCE,
       .cache = (CACHE_NEW_SF_VP |
 		CACHE_NEW_SF_PROG)
    },
diff --git a/src/mesa/drivers/dri/i965/brw_state.h b/src/mesa/drivers/dri/i965/brw_state.h
index df839c5..81b0a45 100644
--- a/src/mesa/drivers/dri/i965/brw_state.h
+++ b/src/mesa/drivers/dri/i965/brw_state.h
@@ -52,7 +52,6 @@ const struct brw_tracked_state brw_cc_vp;
 const struct brw_tracked_state brw_check_fallback;
 const struct brw_tracked_state brw_clip_prog;
 const struct brw_tracked_state brw_clip_unit;
-const struct brw_tracked_state brw_constant_buffer_state;
 const struct brw_tracked_state brw_constant_buffer;
 const struct brw_tracked_state brw_curbe_offsets;
 const struct brw_tracked_state brw_invarient_state;
diff --git a/src/mesa/drivers/dri/i965/brw_state_upload.c b/src/mesa/drivers/dri/i965/brw_state_upload.c
index 4845859..5de1450 100644
--- a/src/mesa/drivers/dri/i965/brw_state_upload.c
+++ b/src/mesa/drivers/dri/i965/brw_state_upload.c
@@ -233,7 +233,6 @@ static struct dirty_bit_map brw_bits[] = {
    DEFINE_BIT(BRW_NEW_WM_INPUT_DIMENSIONS),
    DEFINE_BIT(BRW_NEW_INPUT_VARYING),
    DEFINE_BIT(BRW_NEW_PSP),
-   DEFINE_BIT(BRW_NEW_METAOPS),
    DEFINE_BIT(BRW_NEW_FENCE),
    DEFINE_BIT(BRW_NEW_INDICES),
    DEFINE_BIT(BRW_NEW_VERTICES),
@@ -298,6 +297,7 @@ brw_print_dirty_count(struct dirty_bit_map *bit_map, int32_t bits)
  */
 void brw_validate_state( struct brw_context *brw )
 {
+   GLcontext *ctx = &brw->intel.ctx;
    struct intel_context *intel = &brw->intel;
    struct brw_state_flags *state = &brw->state.dirty;
    GLuint i;
@@ -314,13 +314,13 @@ void brw_validate_state( struct brw_context *brw )
       state->brw |= ~0;
    }
 
-   if (brw->fragment_program != brw->attribs.FragmentProgram->_Current) {
-      brw->fragment_program = brw->attribs.FragmentProgram->_Current;
+   if (brw->fragment_program != ctx->FragmentProgram._Current) {
+      brw->fragment_program = ctx->FragmentProgram._Current;
       brw->state.dirty.brw |= BRW_NEW_FRAGMENT_PROGRAM;
    }
 
-   if (brw->vertex_program != brw->attribs.VertexProgram->_Current) {
-      brw->vertex_program = brw->attribs.VertexProgram->_Current;
+   if (brw->vertex_program != ctx->VertexProgram._Current) {
+      brw->vertex_program = ctx->VertexProgram._Current;
       brw->state.dirty.brw |= BRW_NEW_VERTEX_PROGRAM;
    }
 
diff --git a/src/mesa/drivers/dri/i965/brw_structs.h b/src/mesa/drivers/dri/i965/brw_structs.h
index 4e577d0..89e2981 100644
--- a/src/mesa/drivers/dri/i965/brw_structs.h
+++ b/src/mesa/drivers/dri/i965/brw_structs.h
@@ -439,7 +439,7 @@ struct brw_urb_fence
    } bits1;
 };
 
-struct brw_constant_buffer_state /* previously brw_command_streamer */
+struct brw_cs_urb_state
 {
    struct header header;
 
@@ -1031,10 +1031,10 @@ struct brw_surface_state
       GLuint writedisable_green:1; 
       GLuint writedisable_red:1; 
       GLuint writedisable_alpha:1; 
-      GLuint surface_format:9; 
+      GLuint surface_format:9;     /**< BRW_SURFACEFORMAT_x */
       GLuint data_return_format:1; 
       GLuint pad0:1;
-      GLuint surface_type:3; 
+      GLuint surface_type:3;       /**< BRW_SURFACE_1D/2D/3D/CUBE */
    } ss0;
    
    struct {
diff --git a/src/mesa/drivers/dri/i965/brw_tex.c b/src/mesa/drivers/dri/i965/brw_tex.c
index 0bb6f17..ef99e9c 100644
--- a/src/mesa/drivers/dri/i965/brw_tex.c
+++ b/src/mesa/drivers/dri/i965/brw_tex.c
@@ -86,11 +86,12 @@ void brw_FrameBufferTexDestroy( struct brw_context *brw )
  */
 void brw_validate_textures( struct brw_context *brw )
 {
+   GLcontext *ctx = &brw->intel.ctx;
    struct intel_context *intel = &brw->intel;
    int i;
 
    for (i = 0; i < BRW_MAX_TEX_UNIT; i++) {
-      struct gl_texture_unit *texUnit = &brw->attribs.Texture->Unit[i];
+      struct gl_texture_unit *texUnit = &ctx->Texture.Unit[i];
 
       if (texUnit->_ReallyEnabled) {
 	 intel_finalize_mipmap_tree(intel, i);
diff --git a/src/mesa/drivers/dri/i965/brw_vs.c b/src/mesa/drivers/dri/i965/brw_vs.c
index 1db7cee..e3111c6 100644
--- a/src/mesa/drivers/dri/i965/brw_vs.c
+++ b/src/mesa/drivers/dri/i965/brw_vs.c
@@ -85,6 +85,7 @@ static void do_vs_prog( struct brw_context *brw,
 
 static void brw_upload_vs_prog(struct brw_context *brw)
 {
+   GLcontext *ctx = &brw->intel.ctx;
    struct brw_vs_prog_key key;
    struct brw_vertex_program *vp = 
       (struct brw_vertex_program *)brw->vertex_program;
@@ -97,14 +98,9 @@ static void brw_upload_vs_prog(struct brw_context *brw)
     * the inputs it asks for, whether they are varying or not.
     */
    key.program_string_id = vp->id;
-   key.nr_userclip = brw_count_bits(brw->attribs.Transform->ClipPlanesEnabled);
-   key.copy_edgeflag = (brw->attribs.Polygon->FrontMode != GL_FILL ||
-			brw->attribs.Polygon->BackMode != GL_FILL);
-
-   /* BRW_NEW_METAOPS
-    */
-   if (brw->metaops.active)
-      key.know_w_is_one = 1;
+   key.nr_userclip = brw_count_bits(ctx->Transform.ClipPlanesEnabled);
+   key.copy_edgeflag = (ctx->Polygon.FrontMode != GL_FILL ||
+			ctx->Polygon.BackMode != GL_FILL);
 
    /* Make an early check for the key.
     */
@@ -123,7 +119,7 @@ static void brw_upload_vs_prog(struct brw_context *brw)
 const struct brw_tracked_state brw_vs_prog = {
    .dirty = {
       .mesa  = _NEW_TRANSFORM | _NEW_POLYGON,
-      .brw   = BRW_NEW_VERTEX_PROGRAM | BRW_NEW_METAOPS,
+      .brw   = BRW_NEW_VERTEX_PROGRAM,
       .cache = 0
    },
    .prepare = brw_upload_vs_prog
diff --git a/src/mesa/drivers/dri/i965/brw_vs.h b/src/mesa/drivers/dri/i965/brw_vs.h
index 22388ec..99d0e93 100644
--- a/src/mesa/drivers/dri/i965/brw_vs.h
+++ b/src/mesa/drivers/dri/i965/brw_vs.h
@@ -43,7 +43,6 @@ struct brw_vs_prog_key {
    GLuint program_string_id;
    GLuint nr_userclip:4;
    GLuint copy_edgeflag:1;
-   GLuint know_w_is_one:1;
    GLuint pad:26;
 };
 
diff --git a/src/mesa/drivers/dri/i965/brw_vs_constval.c b/src/mesa/drivers/dri/i965/brw_vs_constval.c
index 6fbac02..9977677 100644
--- a/src/mesa/drivers/dri/i965/brw_vs_constval.c
+++ b/src/mesa/drivers/dri/i965/brw_vs_constval.c
@@ -168,6 +168,7 @@ static GLuint get_input_size(struct brw_context *brw,
  */
 static void calc_wm_input_sizes( struct brw_context *brw )
 {
+   GLcontext *ctx = &brw->intel.ctx;
    /* BRW_NEW_VERTEX_PROGRAM */
    struct brw_vertex_program *vp = 
       (struct brw_vertex_program *)brw->vertex_program;
@@ -179,7 +180,7 @@ static void calc_wm_input_sizes( struct brw_context *brw )
    memset(&t, 0, sizeof(t));
 
    /* _NEW_LIGHT */
-   if (brw->attribs.Light->Model.TwoSide)
+   if (ctx->Light.Model.TwoSide)
       t.twoside = 1;
 
    for (i = 0; i < VERT_ATTRIB_MAX; i++) 
diff --git a/src/mesa/drivers/dri/i965/brw_vs_emit.c b/src/mesa/drivers/dri/i965/brw_vs_emit.c
index 174331a..235f826 100644
--- a/src/mesa/drivers/dri/i965/brw_vs_emit.c
+++ b/src/mesa/drivers/dri/i965/brw_vs_emit.c
@@ -871,21 +871,15 @@ static void emit_vertex_write( struct brw_vs_compile *c)
    }
 
    /* Build ndc coords */
-   if (!c->key.know_w_is_one) {
-      ndc = get_tmp(c);
-      emit_math1(c, BRW_MATH_FUNCTION_INV, ndc, brw_swizzle1(pos, 3), BRW_MATH_PRECISION_FULL);
-      brw_MUL(p, brw_writemask(ndc, WRITEMASK_XYZ), pos, ndc);
-   }
-   else {
-      ndc = pos;
-   }
+   ndc = get_tmp(c);
+   emit_math1(c, BRW_MATH_FUNCTION_INV, ndc, brw_swizzle1(pos, 3), BRW_MATH_PRECISION_FULL);
+   brw_MUL(p, brw_writemask(ndc, WRITEMASK_XYZ), pos, ndc);
 
    /* Update the header for point size, user clipping flags, and -ve rhw
     * workaround.
     */
    if ((c->prog_data.outputs_written & (1<<VERT_RESULT_PSIZ)) ||
-       c->key.nr_userclip ||
-       (!BRW_IS_G4X(p->brw) && !c->key.know_w_is_one))
+       c->key.nr_userclip || !BRW_IS_G4X(p->brw))
    {
       struct brw_reg header1 = retype(get_tmp(c), BRW_REGISTER_TYPE_UD);
       GLuint i;
@@ -916,7 +910,7 @@ static void emit_vertex_write( struct brw_vs_compile *c)
        * Later, clipping will detect ucp[6] and ensure the primitive is
        * clipped against all fixed planes.
        */
-      if (!BRW_IS_G4X(p->brw) && !c->key.know_w_is_one) {
+      if (!BRW_IS_G4X(p->brw)) {
 	 brw_CMP(p,
 		 vec8(brw_null_reg()),
 		 BRW_CONDITIONAL_L,
@@ -960,36 +954,27 @@ static void emit_vertex_write( struct brw_vs_compile *c)
 }
 
 
+/**
+ * Called after code generation to resolve subroutine calls and the
+ * END instruction.
+ * \param end_inst  points to brw code for END instruction
+ * \param last_inst  points to last instruction emitted before vertex write
+ */
 static void 
-post_vs_emit( struct brw_vs_compile *c, struct brw_instruction *end_inst )
+post_vs_emit( struct brw_vs_compile *c,
+              struct brw_instruction *end_inst,
+              struct brw_instruction *last_inst )
 {
-   GLuint nr_insns = c->vp->program.Base.NumInstructions;
-   GLuint insn, target_insn;
-   struct prog_instruction *inst1, *inst2;
-   struct brw_instruction *brw_inst1, *brw_inst2;
-   int offset;
-   for (insn = 0; insn < nr_insns; insn++) {
-       inst1 = &c->vp->program.Base.Instructions[insn];
-       brw_inst1 = inst1->Data;
-       switch (inst1->Opcode) {
-	   case OPCODE_CAL:
-	   case OPCODE_BRA:
-	       target_insn = inst1->BranchTarget;
-	       inst2 = &c->vp->program.Base.Instructions[target_insn];
-	       brw_inst2 = inst2->Data;
-	       offset = brw_inst2 - brw_inst1;
-	       brw_set_src1(brw_inst1, brw_imm_d(offset*16));
-	       break;
-	   case OPCODE_END:
-	       offset = end_inst - brw_inst1;
-	       brw_set_src1(brw_inst1, brw_imm_d(offset*16));
-	       break;
-	   default:
-	       break;
-       }
-   }
+   GLint offset;
+
+   brw_resolve_cals(&c->func);
+
+   /* patch up the END code to jump past subroutines, etc */
+   offset = last_inst - end_inst;
+   brw_set_src1(end_inst, brw_imm_d(offset * 16));
 }
 
+
 /* Emit the fragment program instructions here.
  */
 void brw_vs_emit(struct brw_vs_compile *c )
@@ -998,7 +983,8 @@ void brw_vs_emit(struct brw_vs_compile *c )
    struct brw_compile *p = &c->func;
    GLuint nr_insns = c->vp->program.Base.NumInstructions;
    GLuint insn, if_insn = 0;
-   struct brw_instruction *end_inst;
+   GLuint end_offset = 0;
+   struct brw_instruction *end_inst, *last_inst;
    struct brw_instruction *if_inst[MAX_IFSN];
    struct brw_indirect stack_index = brw_indirect(0, 0);   
 
@@ -1041,7 +1027,6 @@ void brw_vs_emit(struct brw_vs_compile *c )
       
       /* Get argument regs.  SWZ is special and does this itself.
        */
-      inst->Data = &p->store[p->nr_insn];
       if (inst->Opcode != OPCODE_SWZ)
 	  for (i = 0; i < 3; i++) {
 	      struct prog_src_register *src = &inst->SrcReg[i];
@@ -1209,7 +1194,7 @@ void brw_vs_emit(struct brw_vs_compile *c )
 	 brw_set_access_mode(p, BRW_ALIGN_16);
 	 brw_ADD(p, get_addr_reg(stack_index),
 			 get_addr_reg(stack_index), brw_imm_d(4));
-	 inst->Data = &p->store[p->nr_insn];
+         brw_save_call(p, inst->Comment, p->nr_insn);
 	 brw_ADD(p, brw_ip_reg(), brw_ip_reg(), brw_imm_d(1*16));
          break;
       case OPCODE_RET:
@@ -1218,14 +1203,23 @@ void brw_vs_emit(struct brw_vs_compile *c )
 	 brw_set_access_mode(p, BRW_ALIGN_1);
          brw_MOV(p, brw_ip_reg(), deref_1d(stack_index, 0));
 	 brw_set_access_mode(p, BRW_ALIGN_16);
+	 break;
       case OPCODE_END:	
+         end_offset = p->nr_insn;
+         /* this instruction will get patched later to jump past subroutine
+          * code, etc.
+          */
          brw_ADD(p, brw_ip_reg(), brw_ip_reg(), brw_imm_d(1*16));
          break;
       case OPCODE_PRINT:
+         /* no-op */
+         break;
       case OPCODE_BGNSUB:
+         brw_save_label(p, inst->Comment, p->nr_insn);
+         break;
       case OPCODE_ENDSUB:
-         /* no-op instructions */
-	 break;
+         /* no-op */
+         break;
       default:
 	 _mesa_problem(NULL, "Unsupported opcode %i (%s) in vertex shader",
                        inst->Opcode, inst->Opcode < MAX_OPCODE ?
@@ -1263,9 +1257,11 @@ void brw_vs_emit(struct brw_vs_compile *c )
       release_tmps(c);
    }
 
-   end_inst = &p->store[p->nr_insn];
+   end_inst = &p->store[end_offset];
+   last_inst = &p->store[p->nr_insn];
+
+   /* The END instruction will be patched to jump to this code */
    emit_vertex_write(c);
-   post_vs_emit(c, end_inst);
-   for (insn = 0; insn < nr_insns; insn++)
-       c->vp->program.Base.Instructions[insn].Data = NULL;
+
+   post_vs_emit(c, end_inst, last_inst);
 }
diff --git a/src/mesa/drivers/dri/i965/brw_vs_state.c b/src/mesa/drivers/dri/i965/brw_vs_state.c
index 9425816..1a63766 100644
--- a/src/mesa/drivers/dri/i965/brw_vs_state.c
+++ b/src/mesa/drivers/dri/i965/brw_vs_state.c
@@ -49,6 +49,8 @@ struct brw_vs_unit_key {
 static void
 vs_unit_populate_key(struct brw_context *brw, struct brw_vs_unit_key *key)
 {
+   GLcontext *ctx = &brw->intel.ctx;
+
    memset(key, 0, sizeof(*key));
 
    /* CACHE_NEW_VS_PROG */
@@ -61,7 +63,7 @@ vs_unit_populate_key(struct brw_context *brw, struct brw_vs_unit_key *key)
    key->urb_size = brw->urb.vsize;
 
    /* BRW_NEW_CURBE_OFFSETS, _NEW_TRANSFORM */
-   if (brw->attribs.Transform->ClipPlanesEnabled) {
+   if (ctx->Transform.ClipPlanesEnabled) {
       /* Note that we read in the userclip planes as well, hence
        * clip_start:
        */
diff --git a/src/mesa/drivers/dri/i965/brw_vtbl.c b/src/mesa/drivers/dri/i965/brw_vtbl.c
index f7293ef..fc9f6cc 100644
--- a/src/mesa/drivers/dri/i965/brw_vtbl.c
+++ b/src/mesa/drivers/dri/i965/brw_vtbl.c
@@ -23,14 +23,12 @@
  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  
- **********************************************************************/
- /*
-  * Authors:
-  *   Keith Whitwell <keith@tungstengraphics.com>
-  */
-            
-
+**********************************************************************/
 
+/*
+ * Authors:
+ *   Keith Whitwell <keith@tungstengraphics.com>
+ */
 
 #include "main/glheader.h"
 #include "main/mtypes.h"
@@ -44,12 +42,11 @@
 #include "brw_context.h"
 #include "brw_defines.h"
 #include "brw_state.h"
-
 #include "brw_draw.h"
 #include "brw_state.h"
 #include "brw_fallback.h"
 #include "brw_vs.h"
-#include <stdarg.h>
+
 
 static void
 dri_bo_release(dri_bo **bo)
@@ -58,22 +55,25 @@ dri_bo_release(dri_bo **bo)
    *bo = NULL;
 }
 
-/* called from intelDestroyContext()
+
+/**
+ * called from intelDestroyContext()
  */
 static void brw_destroy_context( struct intel_context *intel )
 {
    struct brw_context *brw = brw_context(&intel->ctx);
    int i;
 
-   brw_destroy_metaops(brw);
    brw_destroy_state(brw);
    brw_draw_destroy( brw );
 
+   _mesa_free(brw->wm.compile_data);
+
    brw_FrameBufferTexDestroy( brw );
 
-   for (i = 0; i < brw->state.nr_draw_regions; i++)
-       intel_region_release(&brw->state.draw_regions[i]);
-   brw->state.nr_draw_regions = 0;
+   for (i = 0; i < brw->state.nr_color_regions; i++)
+      intel_region_release(&brw->state.color_regions[i]);
+   brw->state.nr_color_regions = 0;
    intel_region_release(&brw->state.depth_region);
 
    dri_bo_release(&brw->curbe.curbe_bo);
@@ -92,6 +92,7 @@ static void brw_destroy_context( struct intel_context *intel )
    dri_bo_release(&brw->wm.bind_bo);
    for (i = 0; i < BRW_WM_MAX_SURF; i++)
       dri_bo_release(&brw->wm.surf_bo[i]);
+   dri_bo_release(&brw->wm.sampler_bo);
    dri_bo_release(&brw->wm.prog_bo);
    dri_bo_release(&brw->wm.state_bo);
    dri_bo_release(&brw->cc.prog_bo);
@@ -99,37 +100,46 @@ static void brw_destroy_context( struct intel_context *intel )
    dri_bo_release(&brw->cc.vp_bo);
 }
 
-/* called from intelDrawBuffer()
+
+/**
+ * called from intelDrawBuffer()
  */
 static void brw_set_draw_region( struct intel_context *intel, 
-				  struct intel_region *draw_regions[],
-				  struct intel_region *depth_region,
-				GLuint num_regions)
+                                 struct intel_region *color_regions[],
+                                 struct intel_region *depth_region,
+                                 GLuint num_color_regions)
 {
    struct brw_context *brw = brw_context(&intel->ctx);
-   int i;
+   GLuint i;
+
+   /* release old color/depth regions */
    if (brw->state.depth_region != depth_region)
       brw->state.dirty.brw |= BRW_NEW_DEPTH_BUFFER;
-   for (i = 0; i < brw->state.nr_draw_regions; i++)
-       intel_region_release(&brw->state.draw_regions[i]);
+   for (i = 0; i < brw->state.nr_color_regions; i++)
+       intel_region_release(&brw->state.color_regions[i]);
    intel_region_release(&brw->state.depth_region);
-   for (i = 0; i < num_regions; i++)
-       intel_region_reference(&brw->state.draw_regions[i], draw_regions[i]);
+
+   /* reference new color/depth regions */
+   for (i = 0; i < num_color_regions; i++)
+       intel_region_reference(&brw->state.color_regions[i], color_regions[i]);
    intel_region_reference(&brw->state.depth_region, depth_region);
-   brw->state.nr_draw_regions = num_regions;
+   brw->state.nr_color_regions = num_color_regions;
 }
 
-/* called from intel_batchbuffer_flush and children before sending a
+
+/**
+ * called from intel_batchbuffer_flush and children before sending a
  * batchbuffer off.
  */
 static void brw_finish_batch(struct intel_context *intel)
 {
    struct brw_context *brw = brw_context(&intel->ctx);
-
    brw_emit_query_end(brw);
 }
 
-/* called from intelFlushBatchLocked
+
+/**
+ * called from intelFlushBatchLocked
  */
 static void brw_new_batch( struct intel_context *intel )
 {
@@ -160,22 +170,21 @@ static void brw_new_batch( struct intel_context *intel )
    }
 }
 
-static void brw_note_fence( struct intel_context *intel, 
-			    GLuint fence )
+
+static void brw_note_fence( struct intel_context *intel, GLuint fence )
 {
    brw_context(&intel->ctx)->state.dirty.brw |= BRW_NEW_FENCE;
 }
- 
+
+
 static void brw_note_unlock( struct intel_context *intel )
 {
    struct brw_context *brw = brw_context(&intel->ctx);
-
    brw_state_cache_check_size(brw);
 }
 
 
-void brw_do_flush( struct brw_context *brw, 
-		   GLuint flags )
+void brw_do_flush( struct brw_context *brw, GLuint flags )
 {
    struct brw_mi_flush flush;
    memset(&flush, 0, sizeof(flush));      
@@ -185,8 +194,7 @@ void brw_do_flush( struct brw_context *brw,
 }
 
 
-static void brw_emit_flush( struct intel_context *intel,
-			GLuint unused )
+static void brw_emit_flush( struct intel_context *intel, GLuint unused )
 {
    brw_do_flush(brw_context(&intel->ctx),
 		BRW_FLUSH_STATE_CACHE|BRW_FLUSH_READ_CACHE);
@@ -206,6 +214,7 @@ static GLuint brw_flush_cmd( void )
    return *(GLuint *)&flush;
 }
 
+
 static void brw_invalidate_state( struct intel_context *intel, GLuint new_state )
 {
    /* nothing */
@@ -215,14 +224,14 @@ static void brw_invalidate_state( struct intel_context *intel, GLuint new_state
 void brwInitVtbl( struct brw_context *brw )
 {
    brw->intel.vtbl.check_vertex_size = 0;
-   brw->intel.vtbl.emit_state = 0; 
-   brw->intel.vtbl.reduced_primitive_state = 0;	
+   brw->intel.vtbl.emit_state = 0;
+   brw->intel.vtbl.reduced_primitive_state = 0;
    brw->intel.vtbl.render_start = 0;
-   brw->intel.vtbl.update_texture_state = 0; 
+   brw->intel.vtbl.update_texture_state = 0;
 
-   brw->intel.vtbl.invalidate_state = brw_invalidate_state; 
-   brw->intel.vtbl.note_fence = brw_note_fence; 
-   brw->intel.vtbl.note_unlock = brw_note_unlock; 
+   brw->intel.vtbl.invalidate_state = brw_invalidate_state;
+   brw->intel.vtbl.note_fence = brw_note_fence;
+   brw->intel.vtbl.note_unlock = brw_note_unlock;
    brw->intel.vtbl.new_batch = brw_new_batch;
    brw->intel.vtbl.finish_batch = brw_finish_batch;
    brw->intel.vtbl.destroy = brw_destroy_context;
@@ -231,4 +240,3 @@ void brwInitVtbl( struct brw_context *brw )
    brw->intel.vtbl.emit_flush = brw_emit_flush;
    brw->intel.vtbl.debug_batch = brw_debug_batch;
 }
-
diff --git a/src/mesa/drivers/dri/i965/brw_wm.c b/src/mesa/drivers/dri/i965/brw_wm.c
index c50b0d2..10f38e0 100644
--- a/src/mesa/drivers/dri/i965/brw_wm.c
+++ b/src/mesa/drivers/dri/i965/brw_wm.c
@@ -80,6 +80,53 @@ GLuint brw_wm_is_scalar_result( GLuint opcode )
 }
 
 
+/**
+ * Do GPU code generation for non-GLSL shader.  non-GLSL shaders have
+ * no flow control instructions so we can more readily do SSA-style
+ * optimizations.
+ */
+static void
+brw_wm_non_glsl_emit(struct brw_context *brw, struct brw_wm_compile *c)
+{
+   /* Augment fragment program.  Add instructions for pre- and
+    * post-fragment-program tasks such as interpolation and fogging.
+    */
+   brw_wm_pass_fp(c);
+
+   /* Translate to intermediate representation.  Build register usage
+    * chains.
+    */
+   brw_wm_pass0(c);
+
+   /* Dead code removal.
+    */
+   brw_wm_pass1(c);
+
+   /* Register allocation.
+    */
+   c->grf_limit = BRW_WM_MAX_GRF / 2;
+
+   brw_wm_pass2(c);
+
+   c->prog_data.total_grf = c->max_wm_grf;
+   if (c->last_scratch) {
+      c->prog_data.total_scratch = c->last_scratch + 0x40;
+   }
+   else {
+      c->prog_data.total_scratch = 0;
+   }
+
+   /* Emit GEN4 code.
+    */
+   brw_wm_emit(c);
+}
+
+
+/**
+ * All Mesa program -> GPU code generation goes through this function.
+ * Depending on the instructions used (i.e. flow control instructions)
+ * we'll use one of two code generators.
+ */
 static void do_wm_prog( struct brw_context *brw,
 			struct brw_fragment_program *fp, 
 			struct brw_wm_prog_key *key)
@@ -90,52 +137,29 @@ static void do_wm_prog( struct brw_context *brw,
 
    c = brw->wm.compile_data;
    if (c == NULL) {
-     brw->wm.compile_data = calloc(1, sizeof(*brw->wm.compile_data));
-     c = brw->wm.compile_data;
+      brw->wm.compile_data = calloc(1, sizeof(*brw->wm.compile_data));
+      c = brw->wm.compile_data;
    } else {
-     memset(c, 0, sizeof(*brw->wm.compile_data));
+      memset(c, 0, sizeof(*brw->wm.compile_data));
    }
    memcpy(&c->key, key, sizeof(*key));
 
    c->fp = fp;
    c->env_param = brw->intel.ctx.FragmentProgram.Parameters;
 
-    brw_init_compile(brw, &c->func);
+   brw_init_compile(brw, &c->func);
+
+   /*
+    * Shader which use GLSL features such as flow control are handled
+    * differently from "simple" shaders.
+    */
    if (brw_wm_is_glsl(&c->fp->program)) {
-       brw_wm_glsl_emit(brw, c);
-   } else {
-       /* Augment fragment program.  Add instructions for pre- and
-	* post-fragment-program tasks such as interpolation and fogging.
-	*/
-       brw_wm_pass_fp(c);
-
-       /* Translate to intermediate representation.  Build register usage
-	* chains.
-	*/
-       brw_wm_pass0(c);
-
-       /* Dead code removal.
-	*/
-       brw_wm_pass1(c);
-
-       /* Register allocation.
-	*/
-       c->grf_limit = BRW_WM_MAX_GRF/2;
-
-       brw_wm_pass2(c);
-
-       c->prog_data.total_grf = c->max_wm_grf;
-       if (c->last_scratch) {
-	   c->prog_data.total_scratch =
-	       c->last_scratch + 0x40;
-       } else {
-	   c->prog_data.total_scratch = 0;
-       }
-
-       /* Emit GEN4 code.
-	*/
-       brw_wm_emit(c);
+      brw_wm_glsl_emit(brw, c);
    }
+   else {
+      brw_wm_non_glsl_emit(brw, c);
+   }
+
    if (INTEL_DEBUG & DEBUG_WM)
       fprintf(stderr, "\n");
 
@@ -157,8 +181,9 @@ static void do_wm_prog( struct brw_context *brw,
 static void brw_wm_populate_key( struct brw_context *brw,
 				 struct brw_wm_prog_key *key )
 {
+   GLcontext *ctx = &brw->intel.ctx;
    /* BRW_NEW_FRAGMENT_PROGRAM */
-   struct brw_fragment_program *fp = 
+   const struct brw_fragment_program *fp = 
       (struct brw_fragment_program *)brw->fragment_program;
    GLuint lookup = 0;
    GLuint line_aa;
@@ -170,51 +195,50 @@ static void brw_wm_populate_key( struct brw_context *brw,
     */
    /* _NEW_COLOR */
    if (fp->program.UsesKill ||
-       brw->attribs.Color->AlphaEnabled)
+       ctx->Color.AlphaEnabled)
       lookup |= IZ_PS_KILL_ALPHATEST_BIT;
 
    if (fp->program.Base.OutputsWritten & (1<<FRAG_RESULT_DEPR))
       lookup |= IZ_PS_COMPUTES_DEPTH_BIT;
 
    /* _NEW_DEPTH */
-   if (brw->attribs.Depth->Test)
+   if (ctx->Depth.Test)
       lookup |= IZ_DEPTH_TEST_ENABLE_BIT;
 
-   if (brw->attribs.Depth->Test &&  
-       brw->attribs.Depth->Mask) /* ?? */
+   if (ctx->Depth.Test &&  
+       ctx->Depth.Mask) /* ?? */
       lookup |= IZ_DEPTH_WRITE_ENABLE_BIT;
 
    /* _NEW_STENCIL */
-   if (brw->attribs.Stencil->Enabled) {
+   if (ctx->Stencil.Enabled) {
       lookup |= IZ_STENCIL_TEST_ENABLE_BIT;
 
-      if (brw->attribs.Stencil->WriteMask[0] ||
-	  (brw->attribs.Stencil->_TestTwoSide &&
-	   brw->attribs.Stencil->WriteMask[1]))
+      if (ctx->Stencil.WriteMask[0] ||
+	  ctx->Stencil.WriteMask[ctx->Stencil._BackFace])
 	 lookup |= IZ_STENCIL_WRITE_ENABLE_BIT;
    }
 
    line_aa = AA_NEVER;
 
    /* _NEW_LINE, _NEW_POLYGON, BRW_NEW_REDUCED_PRIMITIVE */
-   if (brw->attribs.Line->SmoothFlag) {
+   if (ctx->Line.SmoothFlag) {
       if (brw->intel.reduced_primitive == GL_LINES) {
 	 line_aa = AA_ALWAYS;
       }
       else if (brw->intel.reduced_primitive == GL_TRIANGLES) {
-	 if (brw->attribs.Polygon->FrontMode == GL_LINE) {
+	 if (ctx->Polygon.FrontMode == GL_LINE) {
 	    line_aa = AA_SOMETIMES;
 
-	    if (brw->attribs.Polygon->BackMode == GL_LINE ||
-		(brw->attribs.Polygon->CullFlag &&
-		 brw->attribs.Polygon->CullFaceMode == GL_BACK))
+	    if (ctx->Polygon.BackMode == GL_LINE ||
+		(ctx->Polygon.CullFlag &&
+		 ctx->Polygon.CullFaceMode == GL_BACK))
 	       line_aa = AA_ALWAYS;
 	 }
-	 else if (brw->attribs.Polygon->BackMode == GL_LINE) {
+	 else if (ctx->Polygon.BackMode == GL_LINE) {
 	    line_aa = AA_SOMETIMES;
 
-	    if ((brw->attribs.Polygon->CullFlag &&
-		 brw->attribs.Polygon->CullFaceMode == GL_FRONT))
+	    if ((ctx->Polygon.CullFlag &&
+		 ctx->Polygon.CullFaceMode == GL_FRONT))
 	       line_aa = AA_ALWAYS;
 	 }
       }
@@ -229,20 +253,25 @@ static void brw_wm_populate_key( struct brw_context *brw,
    key->projtex_mask = brw->wm.input_size_masks[4-1] >> (FRAG_ATTRIB_TEX0 - FRAG_ATTRIB_WPOS); 
 
    /* _NEW_LIGHT */
-   key->flat_shade = (brw->attribs.Light->ShadeModel == GL_FLAT);
+   key->flat_shade = (ctx->Light.ShadeModel == GL_FLAT);
 
    /* _NEW_TEXTURE */
    for (i = 0; i < BRW_MAX_TEX_UNIT; i++) {
-      const struct gl_texture_unit *unit = &brw->attribs.Texture->Unit[i];
-      const struct gl_texture_object *t = unit->_Current;
+      const struct gl_texture_unit *unit = &ctx->Texture.Unit[i];
 
       if (unit->_ReallyEnabled) {
-	 if (t->Image[0][t->BaseLevel]->InternalFormat == GL_YCBCR_MESA) {
-	    key->yuvtex_mask |= 1<<i;
-	    if (t->Image[0][t->BaseLevel]->TexFormat->MesaFormat == 
-		    MESA_FORMAT_YCBCR)
-		key->yuvtex_swap_mask |= 1<< i;
+         const struct gl_texture_object *t = unit->_Current;
+         const struct gl_texture_image *img = t->Image[0][t->BaseLevel];
+	 if (img->InternalFormat == GL_YCBCR_MESA) {
+	    key->yuvtex_mask |= 1 << i;
+	    if (img->TexFormat->MesaFormat == MESA_FORMAT_YCBCR)
+		key->yuvtex_swap_mask |= 1 << i;
 	 }
+
+         key->tex_swizzles[i] = t->_Swizzle;
+      }
+      else {
+         key->tex_swizzles[i] = SWIZZLE_NOOP;
       }
    }
 
@@ -273,10 +302,8 @@ static void brw_wm_populate_key( struct brw_context *brw,
       key->drawable_height = brw->intel.driDrawable->h;
    }
 
-   /* Extra info:
-    */
+   /* The unique fragment program ID */
    key->program_string_id = fp->id;
-
 }
 
 
@@ -300,8 +327,6 @@ static void brw_prepare_wm_prog(struct brw_context *brw)
 }
 
 
-/* See brw_wm.c:
- */
 const struct brw_tracked_state brw_wm_prog = {
    .dirty = {
       .mesa  = (_NEW_COLOR |
diff --git a/src/mesa/drivers/dri/i965/brw_wm.h b/src/mesa/drivers/dri/i965/brw_wm.h
index ded0796..6b94591 100644
--- a/src/mesa/drivers/dri/i965/brw_wm.h
+++ b/src/mesa/drivers/dri/i965/brw_wm.h
@@ -60,16 +60,17 @@ struct brw_wm_prog_key {
    GLuint aa_dest_stencil_reg:3;
    GLuint dest_depth_reg:3;
    GLuint nr_depth_regs:3;
-   GLuint projtex_mask:8;
-   GLuint shadowtex_mask:8;
    GLuint computes_depth:1;	/* could be derived from program string */
    GLuint source_depth_to_render_target:1;
    GLuint flat_shade:1;
    GLuint runtime_check_aads_emit:1;
    
-   GLuint yuvtex_mask:8;
-   GLuint yuvtex_swap_mask:8;	/* UV swaped */
-   GLuint pad1:16;
+   GLuint projtex_mask:16;
+   GLuint shadowtex_mask:16;
+   GLuint yuvtex_mask:16;
+   GLuint yuvtex_swap_mask:16;	/* UV swaped */
+
+   GLuint tex_swizzles[BRW_MAX_TEX_UNIT];
 
    GLuint program_string_id:32;
    GLuint origin_x, origin_y;
@@ -142,6 +143,7 @@ struct brw_wm_instruction {
    GLuint writemask:4;
    GLuint tex_unit:4;   /* texture unit for TEX, TXD, TXP instructions */
    GLuint tex_idx:3;    /* TEXTURE_1D,2D,3D,CUBE,RECT_INDEX source target */
+   GLuint tex_shadow:1; /* do shadow comparison? */
    GLuint eot:1;    	/* End of thread indicator for FB_WRITE*/
    GLuint target:10;    /* target binding table index for FB_WRITE*/
 };
@@ -280,4 +282,6 @@ void brw_wm_lookup_iz( GLuint line_aa,
 
 GLboolean brw_wm_is_glsl(const struct gl_fragment_program *fp);
 void brw_wm_glsl_emit(struct brw_context *brw, struct brw_wm_compile *c);
+
+
 #endif
diff --git a/src/mesa/drivers/dri/i965/brw_wm_emit.c b/src/mesa/drivers/dri/i965/brw_wm_emit.c
index b5050a3..281ffe0 100644
--- a/src/mesa/drivers/dri/i965/brw_wm_emit.c
+++ b/src/mesa/drivers/dri/i965/brw_wm_emit.c
@@ -671,7 +671,6 @@ static void emit_tex( struct brw_wm_compile *c,
 {
    struct brw_compile *p = &c->func;
    GLuint msgLength, responseLength;
-   GLboolean shadow = (c->key.shadowtex_mask & (1<<inst->tex_unit)) ? 1 : 0;
    GLuint i, nr;
    GLuint emit;
 
@@ -693,7 +692,7 @@ static void emit_tex( struct brw_wm_compile *c,
       break;
    }
 
-   if (shadow) {
+   if (inst->tex_shadow) {
       nr = 4;
       emit |= WRITEMASK_W;
    }
@@ -718,7 +717,7 @@ static void emit_tex( struct brw_wm_compile *c,
 	      inst->tex_unit + MAX_DRAW_BUFFERS, /* surface */
 	      inst->tex_unit,	  /* sampler */
 	      inst->writemask,
-	      (shadow ? 
+	      (inst->tex_shadow ? 
 	       BRW_SAMPLER_MESSAGE_SIMD16_SAMPLE_COMPARE : 
 	       BRW_SAMPLER_MESSAGE_SIMD16_SAMPLE),
 	      responseLength,
diff --git a/src/mesa/drivers/dri/i965/brw_wm_fp.c b/src/mesa/drivers/dri/i965/brw_wm_fp.c
index 6df2c95..977b9dd 100644
--- a/src/mesa/drivers/dri/i965/brw_wm_fp.c
+++ b/src/mesa/drivers/dri/i965/brw_wm_fp.c
@@ -111,6 +111,12 @@ static struct prog_src_register src_swizzle1( struct prog_src_register reg, int
    return src_swizzle(reg, x, x, x, x);
 }
 
+static struct prog_src_register src_swizzle4( struct prog_src_register reg, uint swizzle )
+{
+   reg.Swizzle = swizzle;
+   return reg;
+}
+
 
 /***********************************************************************
  * Dest regs
@@ -177,16 +183,16 @@ static struct prog_instruction *emit_insn(struct brw_wm_compile *c,
 {
    struct prog_instruction *inst = get_fp_inst(c);
    *inst = *inst0;
-   inst->Data = (void *)inst0;
    return inst;
 }
 
-static struct prog_instruction * emit_op(struct brw_wm_compile *c,
+static struct prog_instruction * emit_tex_op(struct brw_wm_compile *c,
 				       GLuint op,
 				       struct prog_dst_register dest,
 				       GLuint saturate,
 				       GLuint tex_src_unit,
 				       GLuint tex_src_target,
+				       GLuint tex_shadow,
 				       struct prog_src_register src0,
 				       struct prog_src_register src1,
 				       struct prog_src_register src2 )
@@ -200,6 +206,7 @@ static struct prog_instruction * emit_op(struct brw_wm_compile *c,
    inst->SaturateMode = saturate;   
    inst->TexSrcUnit = tex_src_unit;
    inst->TexSrcTarget = tex_src_target;
+   inst->TexShadow = tex_shadow;
    inst->SrcReg[0] = src0;
    inst->SrcReg[1] = src1;
    inst->SrcReg[2] = src2;
@@ -207,6 +214,20 @@ static struct prog_instruction * emit_op(struct brw_wm_compile *c,
 }
    
 
+static struct prog_instruction * emit_op(struct brw_wm_compile *c,
+				       GLuint op,
+				       struct prog_dst_register dest,
+				       GLuint saturate,
+				       struct prog_src_register src0,
+				       struct prog_src_register src1,
+				       struct prog_src_register src2 )
+{
+   return emit_tex_op(c, op, dest, saturate,
+                      0, 0, 0,  /* tex unit, target, shadow */
+                      src0, src1, src2);
+}
+   
+
 
 
 /***********************************************************************
@@ -228,7 +249,7 @@ static struct prog_src_register get_pixel_xy( struct brw_wm_compile *c )
       emit_op(c,
 	      WM_PIXELXY,
 	      dst_mask(pixel_xy, WRITEMASK_XY),
-	      0, 0, 0,
+	      0,
 	      payload_r0_depth,
 	      src_undef(),
 	      src_undef());
@@ -251,7 +272,7 @@ static struct prog_src_register get_delta_xy( struct brw_wm_compile *c )
       emit_op(c,
 	      WM_DELTAXY,
 	      dst_mask(delta_xy, WRITEMASK_XY),
-	      0, 0, 0,
+	      0,
 	      pixel_xy, 
 	      payload_r0_depth,
 	      src_undef());
@@ -268,14 +289,13 @@ static struct prog_src_register get_pixel_w( struct brw_wm_compile *c )
       struct prog_dst_register pixel_w = get_temp(c);
       struct prog_src_register deltas = get_delta_xy(c);
       struct prog_src_register interp_wpos = src_reg(PROGRAM_PAYLOAD, FRAG_ATTRIB_WPOS);
-      
-      
+
       /* deltas.xyw = DELTAS2 deltas.xy, payload.interp_wpos.x
        */
       emit_op(c,
 	      WM_PIXELW,
 	      dst_mask(pixel_w, WRITEMASK_W),
-	      0, 0, 0,
+	      0,
 	      interp_wpos,
 	      deltas, 
 	      src_undef());
@@ -310,7 +330,7 @@ static void emit_interp( struct brw_wm_compile *c,
       emit_op(c,
 	      WM_WPOSXY,
 	      dst_mask(dst, WRITEMASK_XY),
-	      0, 0, 0,
+	      0,
 	      get_pixel_xy(c),
 	      src_undef(),
 	      src_undef());
@@ -322,7 +342,7 @@ static void emit_interp( struct brw_wm_compile *c,
       emit_op(c,
 	      WM_LINTERP,
 	      dst,
-	      0, 0, 0,
+	      0,
 	      interp,
 	      deltas,
 	      arg2);
@@ -333,7 +353,7 @@ static void emit_interp( struct brw_wm_compile *c,
 	 emit_op(c,
 		 WM_CINTERP,
 		 dst,
-		 0, 0, 0,
+		 0,
 		 interp,
 		 src_undef(),
 		 src_undef());
@@ -342,7 +362,7 @@ static void emit_interp( struct brw_wm_compile *c,
 	 emit_op(c,
 		 WM_LINTERP,
 		 dst,
-		 0, 0, 0,
+		 0,
 		 interp,
 		 deltas,
 		 src_undef());
@@ -352,7 +372,7 @@ static void emit_interp( struct brw_wm_compile *c,
       emit_op(c,
 	      WM_PINTERP,
 	      dst,
-	      0, 0, 0,
+	      0,
 	      interp,
 	      deltas,
 	      get_pixel_w(c));
@@ -372,7 +392,7 @@ static void emit_ddx( struct brw_wm_compile *c,
     emit_op(c,
             OPCODE_DDX,
             inst->DstReg,
-            0, 0, 0,
+            0,
             interp,
             get_pixel_w(c),
             src_undef());
@@ -388,7 +408,7 @@ static void emit_ddy( struct brw_wm_compile *c,
     emit_op(c,
             OPCODE_DDY,
             inst->DstReg,
-            0, 0, 0,
+            0,
             interp,
             get_pixel_w(c),
             src_undef());
@@ -483,13 +503,12 @@ static void precalc_dst( struct brw_wm_compile *c,
       emit_op(c,
 	      OPCODE_MUL,
 	      dst_mask(dst, WRITEMASK_Y),
-	      inst->SaturateMode, 0, 0,
+	      inst->SaturateMode,
 	      src0,
 	      src1,
 	      src_undef());
    }
 
-
    if (dst.WriteMask & WRITEMASK_XZ) {
       struct prog_instruction *swz;
       GLuint z = GET_SWZ(src0.Swizzle, Z);
@@ -499,7 +518,7 @@ static void precalc_dst( struct brw_wm_compile *c,
       swz = emit_op(c,
 		    OPCODE_SWZ,
 		    dst_mask(dst, WRITEMASK_XZ),
-		    inst->SaturateMode, 0, 0,
+		    inst->SaturateMode,
 		    src_swizzle(src0, SWIZZLE_ONE, z, z, z),
 		    src_undef(),
 		    src_undef());
@@ -512,7 +531,7 @@ static void precalc_dst( struct brw_wm_compile *c,
       emit_op(c,
 	      OPCODE_MOV,
 	      dst_mask(dst, WRITEMASK_W),
-	      inst->SaturateMode, 0, 0,
+	      inst->SaturateMode,
 	      src1,
 	      src_undef(),
 	      src_undef());
@@ -534,7 +553,7 @@ static void precalc_lit( struct brw_wm_compile *c,
       swz = emit_op(c,
 		    OPCODE_SWZ,
 		    dst_mask(dst, WRITEMASK_XW),
-		    0, 0, 0,
+		    0,
 		    src_swizzle1(src0, SWIZZLE_ONE),
 		    src_undef(),
 		    src_undef());
@@ -542,24 +561,30 @@ static void precalc_lit( struct brw_wm_compile *c,
       swz->SrcReg[0].NegateBase = 0;
    }
 
-
    if (dst.WriteMask & WRITEMASK_YZ) {
       emit_op(c,
 	      OPCODE_LIT,
 	      dst_mask(dst, WRITEMASK_YZ),
-	      inst->SaturateMode, 0, 0,
+	      inst->SaturateMode,
 	      src0,
 	      src_undef(),
 	      src_undef());
    }
 }
 
+
+/**
+ * Some TEX instructions require extra code, cube map coordinate
+ * normalization, or coordinate scaling for RECT textures, etc.
+ * This function emits those extra instructions and the TEX
+ * instruction itself.
+ */
 static void precalc_tex( struct brw_wm_compile *c,
 			 const struct prog_instruction *inst )
 {
    struct prog_src_register coord;
    struct prog_dst_register tmpcoord;
-   GLuint unit = c->fp->program.Base.SamplerUnits[inst->TexSrcUnit];
+   const GLuint unit = c->fp->program.Base.SamplerUnits[inst->TexSrcUnit];
 
    if (inst->TexSrcTarget == TEXTURE_CUBE_INDEX) {
        struct prog_instruction *out;
@@ -569,49 +594,56 @@ static void precalc_tex( struct brw_wm_compile *c,
        struct prog_src_register tmp1src = src_reg_from_dst(tmp1);
        struct prog_src_register src0 = inst->SrcReg[0];
 
+       /* find longest component of coord vector and normalize it */
        tmpcoord = get_temp(c);
        coord = src_reg_from_dst(tmpcoord);
 
+       /* tmpcoord = src0 (i.e.: coord = src0) */
        out = emit_op(c, OPCODE_MOV,
                      tmpcoord,
-                     0, 0, 0,
+                     0,
                      src0,
                      src_undef(),
                      src_undef());
        out->SrcReg[0].NegateBase = 0;
        out->SrcReg[0].Abs = 1;
 
+       /* tmp0 = MAX(coord.X, coord.Y) */
        emit_op(c, OPCODE_MAX,
                tmp0,
-               0, 0, 0,
+               0,
                src_swizzle1(coord, X),
                src_swizzle1(coord, Y),
                src_undef());
 
+       /* tmp1 = MAX(tmp0, coord.Z) */
        emit_op(c, OPCODE_MAX,
                tmp1,
-               0, 0, 0,
+               0,
                tmp0src,
                src_swizzle1(coord, Z),
                src_undef());
 
+       /* tmp0 = 1 / tmp1 */
        emit_op(c, OPCODE_RCP,
                tmp0,
-               0, 0, 0,
+               0,
                tmp1src,
                src_undef(),
                src_undef());
 
+       /* tmpCoord = src0 * tmp0 */
        emit_op(c, OPCODE_MUL,
                tmpcoord,
-               0, 0, 0,
+               0,
                src0,
                tmp0src,
                src_undef());
 
        release_temp(c, tmp0);
        release_temp(c, tmp1);
-   } else if (inst->TexSrcTarget == TEXTURE_RECT_INDEX) {
+   }
+   else if (inst->TexSrcTarget == TEXTURE_RECT_INDEX) {
       struct prog_src_register scale = 
 	 search_or_add_param5( c, 
 			       STATE_INTERNAL, 
@@ -626,7 +658,7 @@ static void precalc_tex( struct brw_wm_compile *c,
       emit_op(c,
 	      OPCODE_MUL,
 	      tmpcoord,
-	      0, 0, 0,
+	      0,
 	      inst->SrcReg[0],
 	      scale,
 	      src_undef());
@@ -642,19 +674,9 @@ static void precalc_tex( struct brw_wm_compile *c,
     * conversion requires allocating a temporary variable which we
     * don't have the facility to do that late in the compilation.
     */
-   if (!(c->key.yuvtex_mask & (1<<unit))) {
-      emit_op(c, 
-	      OPCODE_TEX,
-	      inst->DstReg,
-	      inst->SaturateMode,
-	      unit,
-	      inst->TexSrcTarget,
-	      coord,
-	      src_undef(),
-	      src_undef());
-   }
-   else {
-       GLboolean  swap_uv = c->key.yuvtex_swap_mask & (1<<unit);
+   if (c->key.yuvtex_mask & (1 << unit)) {
+      /* convert ycbcr to RGBA */
+      GLboolean  swap_uv = c->key.yuvtex_swap_mask & (1<<unit);
 
       /* 
 	 CONST C0 = { -.5, -.0625,  -.5, 1.164 }
@@ -676,22 +698,23 @@ static void precalc_tex( struct brw_wm_compile *c,
      
       /* tmp     = TEX ...
        */
-      emit_op(c, 
-	      OPCODE_TEX,
-	      tmp,
-	      inst->SaturateMode,
-	      unit,
-	      inst->TexSrcTarget,
-	      coord,
-	      src_undef(),
-	      src_undef());
+      emit_tex_op(c, 
+                  OPCODE_TEX,
+                  tmp,
+                  inst->SaturateMode,
+                  unit,
+                  inst->TexSrcTarget,
+                  inst->TexShadow,
+                  coord,
+                  src_undef(),
+                  src_undef());
 
       /* tmp.xyz =  ADD TMP, C0
        */
       emit_op(c,
 	      OPCODE_ADD,
 	      dst_mask(tmp, WRITEMASK_XYZ),
-	      0, 0, 0,
+	      0,
 	      tmpsrc,
 	      C0,
 	      src_undef());
@@ -702,7 +725,7 @@ static void precalc_tex( struct brw_wm_compile *c,
       emit_op(c,
 	      OPCODE_MUL,
 	      dst_mask(tmp, WRITEMASK_Y),
-	      0, 0, 0,
+	      0,
 	      tmpsrc,
 	      src_swizzle1(C0, W),
 	      src_undef());
@@ -717,7 +740,7 @@ static void precalc_tex( struct brw_wm_compile *c,
       emit_op(c,
 	      OPCODE_MAD,
 	      dst_mask(dst, WRITEMASK_XYZ),
-	      0, 0, 0,
+	      0,
 	      swap_uv?src_swizzle(tmpsrc, Z,Z,X,X):src_swizzle(tmpsrc, X,X,Z,Z),
 	      C1,
 	      src_swizzle1(tmpsrc, Y));
@@ -727,13 +750,38 @@ static void precalc_tex( struct brw_wm_compile *c,
       emit_op(c,
 	      OPCODE_MAD,
 	      dst_mask(dst, WRITEMASK_Y),
-	      0, 0, 0,
+	      0,
 	      src_swizzle1(tmpsrc, Z),
 	      src_swizzle1(C1, W),
 	      src_swizzle1(src_reg_from_dst(dst), Y));
 
       release_temp(c, tmp);
    }
+   else {
+      /* ordinary RGBA tex instruction */
+      emit_tex_op(c, 
+                  OPCODE_TEX,
+                  inst->DstReg,
+                  inst->SaturateMode,
+                  unit,
+                  inst->TexSrcTarget,
+                  inst->TexShadow,
+                  coord,
+                  src_undef(),
+                  src_undef());
+   }
+
+   /* For GL_EXT_texture_swizzle: */
+   if (c->key.tex_swizzles[unit] != SWIZZLE_NOOP) {
+      /* swizzle the result of the TEX instruction */
+      struct prog_src_register tmpsrc = src_reg_from_dst(inst->DstReg);
+      emit_op(c, OPCODE_SWZ,
+              inst->DstReg,
+              SATURATE_OFF, /* saturate already done above */
+              src_swizzle4(tmpsrc, c->key.tex_swizzles[unit]),
+              src_undef(),
+              src_undef());
+   }
 
    if ((inst->TexSrcTarget == TEXTURE_RECT_INDEX) ||
        (inst->TexSrcTarget == TEXTURE_CUBE_INDEX))
@@ -778,7 +826,7 @@ static void precalc_txp( struct brw_wm_compile *c,
       emit_op(c,
 	      OPCODE_RCP,
 	      dst_mask(tmp, WRITEMASK_W),
-	      0, 0, 0,
+	      0,
 	      src_swizzle1(src0, GET_SWZ(src0.Swizzle, W)),
 	      src_undef(),
 	      src_undef());
@@ -788,7 +836,7 @@ static void precalc_txp( struct brw_wm_compile *c,
       emit_op(c,
 	      OPCODE_MUL,
 	      dst_mask(tmp, WRITEMASK_XYZ),
-	      0, 0, 0,
+	      0,
 	      src0,
 	      src_swizzle1(src_reg_from_dst(tmp), W),
 	      src_undef());
@@ -821,24 +869,23 @@ static void emit_fb_write( struct brw_wm_compile *c )
    struct prog_instruction *inst, *last_inst;
    struct brw_context *brw = c->func.brw;
 
-   /* inst->Sampler is not used by backend, 
-      use it for fb write target and eot */
-
-   if (brw->state.nr_draw_regions > 1) {
-       for (i = 0 ; i < brw->state.nr_draw_regions; i++) {
-	   outcolor = src_reg(PROGRAM_OUTPUT, FRAG_RESULT_DATA0 + i);
-	   last_inst = inst = emit_op(c,
-		   WM_FB_WRITE, dst_mask(dst_undef(),0), 0, 0, 0,
-		   outcolor, payload_r0_depth, outdepth);
-	   inst->Sampler = (i<<1);
-	   if (c->fp_fragcolor_emitted) {
-	       outcolor = src_reg(PROGRAM_OUTPUT, FRAG_RESULT_COLR);
-	       last_inst = inst = emit_op(c, WM_FB_WRITE, dst_mask(dst_undef(),0),
-		       0, 0, 0, outcolor, payload_r0_depth, outdepth);
-	       inst->Sampler = (i<<1);
-	   }
-       }
-       last_inst->Sampler |= 1; //eot
+   /* The inst->Aux field is used for FB write target and the EOT marker */
+
+   if (brw->state.nr_color_regions > 1) {
+      for (i = 0 ; i < brw->state.nr_color_regions; i++) {
+         outcolor = src_reg(PROGRAM_OUTPUT, FRAG_RESULT_DATA0 + i);
+         last_inst = inst = emit_op(c,
+                                    WM_FB_WRITE, dst_mask(dst_undef(),0), 0,
+                                    outcolor, payload_r0_depth, outdepth);
+         inst->Aux = (i<<1);
+         if (c->fp_fragcolor_emitted) {
+            outcolor = src_reg(PROGRAM_OUTPUT, FRAG_RESULT_COLR);
+            last_inst = inst = emit_op(c, WM_FB_WRITE, dst_mask(dst_undef(),0),
+                                       0, outcolor, payload_r0_depth, outdepth);
+            inst->Aux = (i<<1);
+         }
+      }
+      last_inst->Aux |= 1; //eot
    }
    else {
       /* if gl_FragData[0] is written, use it, else use gl_FragColor */
@@ -847,9 +894,9 @@ static void emit_fb_write( struct brw_wm_compile *c )
       else 
          outcolor = src_reg(PROGRAM_OUTPUT, FRAG_RESULT_COLR);
 
-       inst = emit_op(c, WM_FB_WRITE, dst_mask(dst_undef(),0),
-	       0, 0, 0, outcolor, payload_r0_depth, outdepth);
-       inst->Sampler = 1|(0<<1);
+      inst = emit_op(c, WM_FB_WRITE, dst_mask(dst_undef(),0),
+                     0, outcolor, payload_r0_depth, outdepth);
+      inst->Aux = 1|(0<<1);
    }
 }
 
@@ -880,9 +927,9 @@ static void validate_dst_regs( struct brw_wm_compile *c,
 			       const struct prog_instruction *inst )
 {
    if (inst->DstReg.File == PROGRAM_OUTPUT) {
-       GLuint idx = inst->DstReg.Index;
-       if (idx == FRAG_RESULT_COLR)
-	   c->fp_fragcolor_emitted = 1;
+      GLuint idx = inst->DstReg.Index;
+      if (idx == FRAG_RESULT_COLR)
+         c->fp_fragcolor_emitted = 1;
    }
 }
 
@@ -903,10 +950,14 @@ static void print_insns( const struct prog_instruction *insn,
       }
       else 
 	 _mesa_printf("UNKNOWN\n");
-	   
    }
 }
 
+
+/**
+ * Initial pass for fragment program code generation.
+ * This function is used by both the GLSL and non-GLSL paths.
+ */
 void brw_wm_pass_fp( struct brw_wm_compile *c )
 {
    struct brw_fragment_program *fp = c->fp;
@@ -923,15 +974,19 @@ void brw_wm_pass_fp( struct brw_wm_compile *c )
    c->pixel_w = src_undef();
    c->nr_fp_insns = 0;
 
-   /* Emit preamble instructions:
+   /* Emit preamble instructions.  This is where special instructions such as
+    * WM_CINTERP, WM_LINTERP, WM_PINTERP and WM_WPOSXY are emitted to
+    * compute shader inputs from varying vars.
     */
-
-
    for (insn = 0; insn < fp->program.Base.NumInstructions; insn++) {
       const struct prog_instruction *inst = &fp->program.Base.Instructions[insn];
       validate_src_regs(c, inst);
       validate_dst_regs(c, inst);
    }
+
+   /* Loop over all instructions doing assorted simplifications and
+    * transformations.
+    */
    for (insn = 0; insn < fp->program.Base.NumInstructions; insn++) {
       const struct prog_instruction *inst = &fp->program.Base.Instructions[insn];
       struct prog_instruction *out;
@@ -940,7 +995,6 @@ void brw_wm_pass_fp( struct brw_wm_compile *c )
        * necessary:
        */
 
-
       switch (inst->Opcode) {
       case OPCODE_SWZ: 
 	 out = emit_insn(c, inst);
@@ -1020,9 +1074,9 @@ void brw_wm_pass_fp( struct brw_wm_compile *c )
    }
 
    if (INTEL_DEBUG & DEBUG_WM) {
-	   _mesa_printf("pass_fp:\n");
-	   print_insns( c->prog_instructions, c->nr_fp_insns );
-	   _mesa_printf("\n");
+      _mesa_printf("pass_fp:\n");
+      print_insns( c->prog_instructions, c->nr_fp_insns );
+      _mesa_printf("\n");
    }
 }
 
diff --git a/src/mesa/drivers/dri/i965/brw_wm_glsl.c b/src/mesa/drivers/dri/i965/brw_wm_glsl.c
index 8fd776a..8e404bc 100644
--- a/src/mesa/drivers/dri/i965/brw_wm_glsl.c
+++ b/src/mesa/drivers/dri/i965/brw_wm_glsl.c
@@ -8,12 +8,17 @@ enum _subroutine {
     SUB_NOISE1, SUB_NOISE2, SUB_NOISE3, SUB_NOISE4
 };
 
-/* Only guess, need a flag in gl_fragment_program later */
+
+/**
+ * Determine if the given fragment program uses GLSL features such
+ * as flow conditionals, loops, subroutines.
+ * Some GLSL shaders may use these features, others might not.
+ */
 GLboolean brw_wm_is_glsl(const struct gl_fragment_program *fp)
 {
     int i;
     for (i = 0; i < fp->Base.NumInstructions; i++) {
-	struct prog_instruction *inst = &fp->Base.Instructions[i];
+	const struct prog_instruction *inst = &fp->Base.Instructions[i];
 	switch (inst->Opcode) {
 	    case OPCODE_IF:
 	    case OPCODE_TRUNC:
@@ -176,13 +181,15 @@ static struct brw_reg get_src_reg(struct brw_wm_compile *c,
 	    src->NegateBase, src->Abs);
 }
 
-/* Subroutines are minimal support for resusable instruction sequences.
-   They are implemented as simply as possible to minimise overhead: there
-   is no explicit support for communication between the caller and callee
-   other than saving the return address in a temporary register, nor is
-   there any automatic local storage.  This implies that great care is
-   required before attempting reentrancy or any kind of nested
-   subroutine invocations. */
+/**
+ * Subroutines are minimal support for resusable instruction sequences.
+ * They are implemented as simply as possible to minimise overhead: there
+ * is no explicit support for communication between the caller and callee
+ * other than saving the return address in a temporary register, nor is
+ * there any automatic local storage.  This implies that great care is
+ * required before attempting reentrancy or any kind of nested
+ * subroutine invocations.
+ */
 static void invoke_subroutine( struct brw_wm_compile *c,
 			       enum _subroutine subroutine,
 			       void (*emit)( struct brw_wm_compile * ) )
@@ -319,11 +326,10 @@ static void emit_pixel_xy(struct brw_wm_compile *c,
 		stride(suboffset(r1_uw, 5), 2, 4, 0),
 		brw_imm_v(0x11001100));
     }
-
 }
 
 static void emit_delta_xy(struct brw_wm_compile *c,
-		struct prog_instruction *inst)
+                          struct prog_instruction *inst)
 {
     struct brw_reg r1 = brw_vec1_grf(1, 0);
     struct brw_reg dst0, dst1, src0, src1;
@@ -351,10 +357,8 @@ static void emit_delta_xy(struct brw_wm_compile *c,
 		negate(suboffset(r1,1)));
 
     }
-
 }
 
-
 static void fire_fb_write( struct brw_wm_compile *c,
                            GLuint base_reg,
                            GLuint nr,
@@ -397,33 +401,33 @@ static void emit_fb_write(struct brw_wm_compile *c,
      */
     if (c->key.aa_dest_stencil_reg)
 	nr += 1;
-    {
-	brw_push_insn_state(p);
-	for (channel = 0; channel < 4; channel++) {
-	    src0 = get_src_reg(c,  &inst->SrcReg[0], channel, 1);
-	    /*  mov (8) m2.0<1>:ud   r28.0<8;8,1>:ud  { Align1 } */
-	    /*  mov (8) m6.0<1>:ud   r29.0<8;8,1>:ud  { Align1 SecHalf } */
-	    brw_MOV(p, brw_message_reg(nr + channel), src0);
-	}
-	/* skip over the regs populated above: */
-	nr += 8;
-	brw_pop_insn_state(p);
+
+    brw_push_insn_state(p);
+    for (channel = 0; channel < 4; channel++) {
+        src0 = get_src_reg(c,  &inst->SrcReg[0], channel, 1);
+        /*  mov (8) m2.0<1>:ud   r28.0<8;8,1>:ud  { Align1 } */
+        /*  mov (8) m6.0<1>:ud   r29.0<8;8,1>:ud  { Align1 SecHalf } */
+        brw_MOV(p, brw_message_reg(nr + channel), src0);
     }
+    /* skip over the regs populated above: */
+    nr += 8;
+    brw_pop_insn_state(p);
 
-   if (c->key.source_depth_to_render_target)
-   {
-      if (c->key.computes_depth) {
-         src0 = get_src_reg(c, &inst->SrcReg[2], 2, 1);
-         brw_MOV(p, brw_message_reg(nr), src0);
-      } else {
-         src0 = get_src_reg(c, &inst->SrcReg[1], 1, 1);
-         brw_MOV(p, brw_message_reg(nr), src0);
-      }
-
-      nr += 2;
-   }
-    target = inst->Sampler >> 1;
-    eot = inst->Sampler & 1;
+    if (c->key.source_depth_to_render_target) {
+       if (c->key.computes_depth) {
+          src0 = get_src_reg(c, &inst->SrcReg[2], 2, 1);
+          brw_MOV(p, brw_message_reg(nr), src0);
+       }
+       else {
+          src0 = get_src_reg(c, &inst->SrcReg[1], 1, 1);
+          brw_MOV(p, brw_message_reg(nr), src0);
+       }
+
+       nr += 2;
+    }
+
+    target = inst->Aux >> 1;
+    eot = inst->Aux & 1;
     fire_fb_write(c, 0, nr, target, eot);
 }
 
@@ -1045,23 +1049,23 @@ static void emit_ddy(struct brw_wm_compile *c,
     brw_set_saturate(p, 0);
 }
 
-static __inline struct brw_reg high_words( struct brw_reg reg )
+static INLINE struct brw_reg high_words( struct brw_reg reg )
 {
     return stride( suboffset( retype( reg, BRW_REGISTER_TYPE_W ), 1 ),
 		   0, 8, 2 );
 }
 
-static __inline struct brw_reg low_words( struct brw_reg reg )
+static INLINE struct brw_reg low_words( struct brw_reg reg )
 {
     return stride( retype( reg, BRW_REGISTER_TYPE_W ), 0, 8, 2 );
 }
 
-static __inline struct brw_reg even_bytes( struct brw_reg reg )
+static INLINE struct brw_reg even_bytes( struct brw_reg reg )
 {
     return stride( retype( reg, BRW_REGISTER_TYPE_B ), 0, 16, 2 );
 }
 
-static __inline struct brw_reg odd_bytes( struct brw_reg reg )
+static INLINE struct brw_reg odd_bytes( struct brw_reg reg )
 {
     return stride( suboffset( retype( reg, BRW_REGISTER_TYPE_B ), 1 ),
 		   0, 16, 2 );
@@ -1366,9 +1370,11 @@ static void emit_noise2( struct brw_wm_compile *c,
     release_tmps( c, mark );
 }
 
-/* The three-dimensional case is much like the one- and two- versions above,
-   but since the number of corners is rapidly growing we now pack 16 16-bit
-   hashes into each register to extract more parallelism from the EUs. */
+/**
+ * The three-dimensional case is much like the one- and two- versions above,
+ * but since the number of corners is rapidly growing we now pack 16 16-bit
+ * hashes into each register to extract more parallelism from the EUs.
+ */
 static void noise3_sub( struct brw_wm_compile *c ) {
 
     struct brw_compile *p = &c->func;
@@ -1670,13 +1676,15 @@ static void emit_noise3( struct brw_wm_compile *c,
     release_tmps( c, mark );
 }
     
-/* For the four-dimensional case, the little micro-optimisation benefits
-   we obtain by unrolling all the loops aren't worth the massive bloat it
-   now causes.  Instead, we loop twice around performing a similar operation
-   to noise3, once for the w=0 cube and once for the w=1, with a bit more
-   code to glue it all together. */
-static void noise4_sub( struct brw_wm_compile *c ) {
-
+/**
+ * For the four-dimensional case, the little micro-optimisation benefits
+ * we obtain by unrolling all the loops aren't worth the massive bloat it
+ * now causes.  Instead, we loop twice around performing a similar operation
+ * to noise3, once for the w=0 cube and once for the w=1, with a bit more
+ * code to glue it all together.
+ */
+static void noise4_sub( struct brw_wm_compile *c )
+{
     struct brw_compile *p = &c->func;
     struct brw_reg param[ 4 ],
 	x0y0, x0y1, x1y0, x1y1, /* gradients at four of the corners */
@@ -2244,28 +2252,12 @@ static void emit_tex(struct brw_wm_compile *c,
 	brw_MOV(p, dst[3], brw_imm_f(1.0));
 }
 
+/**
+ * Resolve subroutine calls after code emit is done.
+ */
 static void post_wm_emit( struct brw_wm_compile *c )
 {
-    GLuint nr_insns = c->fp->program.Base.NumInstructions;
-    GLuint insn, target_insn;
-    struct prog_instruction *inst1, *inst2;
-    struct brw_instruction *brw_inst1, *brw_inst2;
-    int offset;
-    for (insn = 0; insn < nr_insns; insn++) {
-	inst1 = &c->fp->program.Base.Instructions[insn];
-	brw_inst1 = inst1->Data;
-	switch (inst1->Opcode) {
-	    case OPCODE_CAL:
-		target_insn = inst1->BranchTarget;
-		inst2 = &c->fp->program.Base.Instructions[target_insn];
-		brw_inst2 = inst2->Data;
-		offset = brw_inst2 - brw_inst1;
-		brw_set_src1(brw_inst1, brw_imm_d(offset*16));
-		break;
-	    default:
-		break;
-	}
-    }
+    brw_resolve_cals(&c->func);
 }
 
 static void brw_wm_emit_glsl(struct brw_context *brw, struct brw_wm_compile *c)
@@ -2285,10 +2277,6 @@ static void brw_wm_emit_glsl(struct brw_context *brw, struct brw_wm_compile *c)
 
     for (i = 0; i < c->nr_fp_insns; i++) {
 	struct prog_instruction *inst = &c->prog_instructions[i];
-	struct prog_instruction *orig_inst;
-
-	if ((orig_inst = inst->Data) != 0)
-	    orig_inst->Data = current_insn(p);
 
 	if (inst->CondUpdate)
 	    brw_set_conditionalmod(p, BRW_CONDITIONAL_NZ);
@@ -2446,7 +2434,10 @@ static void brw_wm_emit_glsl(struct brw_context *brw, struct brw_wm_compile *c)
 		brw_ENDIF(p, if_inst[--if_insn]);
 		break;
 	    case OPCODE_BGNSUB:
+		brw_save_label(p, inst->Comment, p->nr_insn);
+		break;
 	    case OPCODE_ENDSUB:
+		/* no-op */
 		break;
 	    case OPCODE_CAL: 
 		brw_push_insn_state(p);
@@ -2456,8 +2447,7 @@ static void brw_wm_emit_glsl(struct brw_context *brw, struct brw_wm_compile *c)
                 brw_set_access_mode(p, BRW_ALIGN_16);
                 brw_ADD(p, get_addr_reg(stack_index),
                          get_addr_reg(stack_index), brw_imm_d(4));
-                orig_inst = inst->Data;
-                orig_inst->Data = &p->store[p->nr_insn];
+		brw_save_call(&c->func, inst->Comment, p->nr_insn);
                 brw_ADD(p, brw_ip_reg(), brw_ip_reg(), brw_imm_d(1*16));
                 brw_pop_insn_state(p);
 		break;
@@ -2510,14 +2500,29 @@ static void brw_wm_emit_glsl(struct brw_context *brw, struct brw_wm_compile *c)
 	    brw_set_predicate_control(p, BRW_PREDICATE_NONE);
     }
     post_wm_emit(c);
-    for (i = 0; i < c->fp->program.Base.NumInstructions; i++)
-	c->fp->program.Base.Instructions[i].Data = NULL;
 }
 
+
+/**
+ * Do GPU code generation for shaders that use GLSL features such as
+ * flow control.  Other shaders will be compiled with the 
+ */
 void brw_wm_glsl_emit(struct brw_context *brw, struct brw_wm_compile *c)
 {
+    if (INTEL_DEBUG & DEBUG_WM) {
+        _mesa_printf("brw_wm_glsl_emit:\n");
+    }
+
+    /* initial instruction translation/simplification */
     brw_wm_pass_fp(c);
+
+    /* actual code generation */
     brw_wm_emit_glsl(brw, c);
+
+    if (INTEL_DEBUG & DEBUG_WM) {
+        brw_wm_print_program(c, "brw_wm_glsl_emit done");
+    }
+
     c->prog_data.total_grf = c->reg_index;
     c->prog_data.total_scratch = 0;
 }
diff --git a/src/mesa/drivers/dri/i965/brw_wm_pass0.c b/src/mesa/drivers/dri/i965/brw_wm_pass0.c
index 205a716..2debd06 100644
--- a/src/mesa/drivers/dri/i965/brw_wm_pass0.c
+++ b/src/mesa/drivers/dri/i965/brw_wm_pass0.c
@@ -51,6 +51,7 @@ static struct brw_wm_value *get_value( struct brw_wm_compile *c)
    return &c->vreg[c->nr_vreg++];
 }
 
+/** return pointer to a newly allocated instruction */
 static struct brw_wm_instruction *get_instruction( struct brw_wm_compile *c )
 {
    assert(c->nr_insns < BRW_WM_MAX_INSN);
@@ -60,6 +61,7 @@ static struct brw_wm_instruction *get_instruction( struct brw_wm_compile *c )
 /***********************************************************************
  */
 
+/** Init the "undef" register */
 static void pass0_init_undef( struct brw_wm_compile *c)
 {
    struct brw_wm_ref *ref = &c->undef_ref;
@@ -69,6 +71,7 @@ static void pass0_init_undef( struct brw_wm_compile *c)
    ref->prevuse = NULL;
 }
 
+/** Set a FP register to a value */
 static void pass0_set_fpreg_value( struct brw_wm_compile *c,
 				   GLuint file,
 				   GLuint idx,
@@ -83,6 +86,7 @@ static void pass0_set_fpreg_value( struct brw_wm_compile *c,
    c->pass0_fp_reg[file][idx][component] = ref;
 }
 
+/** Set a FP register to a ref */
 static void pass0_set_fpreg_ref( struct brw_wm_compile *c,
 				 GLuint file,
 				 GLuint idx,
@@ -115,12 +119,13 @@ static const struct brw_wm_ref *get_param_ref( struct brw_wm_compile *c,
       ref->value = &c->creg[i/16];
       ref->insn = 0;
       ref->prevuse = NULL;
-      
+
       return ref;
    }
 }
 
 
+/** Return a ref to a constant/literal value */
 static const struct brw_wm_ref *get_const_ref( struct brw_wm_compile *c,
 					       const GLfloat *constval )
 {
@@ -142,7 +147,7 @@ static const struct brw_wm_ref *get_const_ref( struct brw_wm_compile *c,
        */
       c->constref[i].constval = *constval;
       c->constref[i].ref = get_param_ref(c, constval);
-   
+
       return c->constref[i].ref;
    }
    else {
@@ -187,7 +192,7 @@ static const struct brw_wm_ref *pass0_get_reg( struct brw_wm_compile *c,
 	 
 	 /* There's something really hokey about parameters parsed in
 	  * arb programs - they all end up in here, whether they be
-	  * state values, paramters or constants.  This duplicates the
+	  * state values, parameters or constants.  This duplicates the
 	  * structure above & also seems to subvert the limits set for
 	  * each type of constant/param.
 	  */ 
@@ -198,7 +203,7 @@ static const struct brw_wm_ref *pass0_get_reg( struct brw_wm_compile *c,
 	     */
 	    ref = get_const_ref(c, &plist->ParameterValues[idx][component]);
 	    break;
-	    
+
 	 case PROGRAM_STATE_VAR:
 	 case PROGRAM_UNIFORM:
 	    /* These may change from run to run:
@@ -229,14 +234,13 @@ static const struct brw_wm_ref *pass0_get_reg( struct brw_wm_compile *c,
 
 
 
-
 /***********************************************************************
  * Straight translation to internal instruction format
  */
 
 static void pass0_set_dst( struct brw_wm_compile *c,
-			   struct brw_wm_instruction *out,		     
-			   const struct prog_instruction *inst,		     
+			   struct brw_wm_instruction *out,
+			   const struct prog_instruction *inst,
 			   GLuint writemask )
 {
    const struct prog_dst_register *dst = &inst->DstReg;
@@ -245,18 +249,17 @@ static void pass0_set_dst( struct brw_wm_compile *c,
    for (i = 0; i < 4; i++) {
       if (writemask & (1<<i)) {
 	 out->dst[i] = get_value(c);
-
 	 pass0_set_fpreg_value(c, dst->File, dst->Index, i, out->dst[i]);
       }
    }
-   
+
    out->writemask = writemask;
 }
 
 
 static void pass0_set_dst_scalar( struct brw_wm_compile *c,
-				  struct brw_wm_instruction *out,		     
-				  const struct prog_instruction *inst,		     
+				  struct brw_wm_instruction *out,
+                                  const struct prog_instruction *inst,
 				  GLuint writemask )
 {
    if (writemask) {
@@ -282,7 +285,6 @@ static void pass0_set_dst_scalar( struct brw_wm_compile *c,
 }
 
 
-
 static const struct brw_wm_ref *get_fp_src_reg_ref( struct brw_wm_compile *c,
 						    struct prog_src_register src,
 						    GLuint i )
@@ -292,14 +294,13 @@ static const struct brw_wm_ref *get_fp_src_reg_ref( struct brw_wm_compile *c,
    static const GLfloat const_zero = 0.0;
    static const GLfloat const_one = 1.0;
 
-	 
    if (component == SWIZZLE_ZERO) 
       src_ref = get_const_ref(c, &const_zero);
    else if (component == SWIZZLE_ONE) 
       src_ref = get_const_ref(c, &const_one);
    else 
       src_ref = pass0_get_reg(c, src.File, src.Index, component);
-	 
+
    return src_ref;
 }
 
@@ -311,19 +312,19 @@ static struct brw_wm_ref *get_new_ref( struct brw_wm_compile *c,
 {
    const struct brw_wm_ref *ref = get_fp_src_reg_ref(c, src, i);
    struct brw_wm_ref *newref = get_ref(c);
-      
+
    newref->value = ref->value;
    newref->hw_reg = ref->hw_reg;
 
-   if (insn) { 
+   if (insn) {
       newref->insn = insn - c->instruction;
       newref->prevuse = newref->value->lastuse;
       newref->value->lastuse = newref;
    }
 
-   if (src.NegateBase & (1<<i)) 
+   if (src.NegateBase & (1<<i))
       newref->hw_reg.negate ^= 1;
-	    
+
    if (src.Abs) {
       newref->hw_reg.negate = 0;
       newref->hw_reg.abs = 1;
@@ -333,9 +334,9 @@ static struct brw_wm_ref *get_new_ref( struct brw_wm_compile *c,
 }
 
 
-
-static struct brw_wm_instruction *translate_insn( struct brw_wm_compile *c,
-						  const struct prog_instruction *inst )
+static void
+translate_insn(struct brw_wm_compile *c,
+               const struct prog_instruction *inst)
 {
    struct brw_wm_instruction *out = get_instruction(c);
    GLuint writemask = inst->DstReg.WriteMask;
@@ -348,8 +349,9 @@ static struct brw_wm_instruction *translate_insn( struct brw_wm_compile *c,
    out->saturate = (inst->SaturateMode != SATURATE_OFF);
    out->tex_unit = inst->TexSrcUnit;
    out->tex_idx = inst->TexSrcTarget;
-   out->eot = inst->Sampler & 1;
-   out->target = inst->Sampler>>1;
+   out->tex_shadow = inst->TexShadow;
+   out->eot = inst->Aux & 1;
+   out->target = inst->Aux >> 1;
 
    /* Args:
     */
@@ -365,8 +367,6 @@ static struct brw_wm_instruction *translate_insn( struct brw_wm_compile *c,
       pass0_set_dst_scalar(c, out, inst, writemask);
    else 
       pass0_set_dst(c, out, inst, writemask);
-
-   return out;
 }
 
 
@@ -379,14 +379,22 @@ static void pass0_precalc_mov( struct brw_wm_compile *c,
 {
    const struct prog_dst_register *dst = &inst->DstReg;
    GLuint writemask = inst->DstReg.WriteMask;
+   struct brw_wm_ref *refs[4];
    GLuint i;
 
    /* Get the effect of a MOV by manipulating our register table:
+    * First get all refs, then assign refs.  This ensures that "in-place"
+    * swizzles such as:
+    *   MOV t, t.xxyx
+    * are handled correctly.  Previously, these two steps were done in
+    * one loop and the above case was incorrectly handled.
     */
    for (i = 0; i < 4; i++) {
-      if (writemask & (1<<i)) {	    
-	 pass0_set_fpreg_ref( c, dst->File, dst->Index, i, 
-			      get_new_ref(c, inst->SrcReg[0], i, NULL));
+      refs[i] = get_new_ref(c, inst->SrcReg[0], i, NULL);
+   }
+   for (i = 0; i < 4; i++) {
+      if (writemask & (1 << i)) {	    
+         pass0_set_fpreg_ref( c, dst->File, dst->Index, i, refs[i]);
       }
    }
 }
@@ -418,6 +426,7 @@ static void pass0_init_payload( struct brw_wm_compile *c )
 			     &c->payload.input_interp[i] );      
 }
 
+
 /***********************************************************************
  * PASS 0
  *
@@ -440,7 +449,6 @@ void brw_wm_pass0( struct brw_wm_compile *c )
    for (insn = 0; insn < c->nr_fp_insns; insn++) {
       const struct prog_instruction *inst = &c->prog_instructions[insn];
 
-
       /* Optimize away moves, otherwise emit translated instruction:
        */      
       switch (inst->Opcode) {
@@ -453,8 +461,6 @@ void brw_wm_pass0( struct brw_wm_compile *c )
 	    translate_insn(c, inst);
 	 }
 	 break;
-	 
-
       default:
 	 translate_insn(c, inst);
 	 break;
@@ -465,4 +471,3 @@ void brw_wm_pass0( struct brw_wm_compile *c )
       brw_wm_print_program(c, "pass0");
    }
 }
-
diff --git a/src/mesa/drivers/dri/i965/brw_wm_pass1.c b/src/mesa/drivers/dri/i965/brw_wm_pass1.c
index f6f3a38..cf03189 100644
--- a/src/mesa/drivers/dri/i965/brw_wm_pass1.c
+++ b/src/mesa/drivers/dri/i965/brw_wm_pass1.c
@@ -58,7 +58,8 @@ static void unlink_ref(struct brw_wm_ref *ref)
 
    if (ref == value->lastuse) {
       value->lastuse = ref->prevuse;
-   } else {
+   }
+   else {
       struct brw_wm_ref *i = value->lastuse;
       while (i->prevuse != ref) i = i->prevuse;
       i->prevuse = ref->prevuse;
@@ -75,8 +76,9 @@ static void track_arg(struct brw_wm_compile *c,
    for (i = 0; i < 4; i++) {
       struct brw_wm_ref *ref = inst->src[arg][i];
       if (ref) {
-	 if (readmask & (1<<i)) 
+	 if (readmask & (1<<i)) {
 	    ref->value->contributes_to_output = 1;
+         }
 	 else {
 	    unlink_ref(ref);
 	    inst->src[arg][i] = NULL;
@@ -88,15 +90,21 @@ static void track_arg(struct brw_wm_compile *c,
 static GLuint get_texcoord_mask( GLuint tex_idx )
 {
    switch (tex_idx) {
-   case TEXTURE_1D_INDEX: return WRITEMASK_X;
-   case TEXTURE_2D_INDEX: return WRITEMASK_XY;
-   case TEXTURE_3D_INDEX: return WRITEMASK_XYZ;
-   case TEXTURE_CUBE_INDEX: return WRITEMASK_XYZ;
-   case TEXTURE_RECT_INDEX: return WRITEMASK_XY;
+   case TEXTURE_1D_INDEX:
+      return WRITEMASK_X;
+   case TEXTURE_2D_INDEX:
+      return WRITEMASK_XY;
+   case TEXTURE_3D_INDEX:
+      return WRITEMASK_XYZ;
+   case TEXTURE_CUBE_INDEX:
+      return WRITEMASK_XYZ;
+   case TEXTURE_RECT_INDEX:
+      return WRITEMASK_XY;
    default: return 0;
    }
 }
 
+
 /* Step two: Basically this is dead code elimination.  
  *
  * Iterate backwards over instructions, noting which values
@@ -202,9 +210,10 @@ void brw_wm_pass1( struct brw_wm_compile *c )
 	 break;
 
       case OPCODE_TEX:
+      case OPCODE_TXP:
 	 read0 = get_texcoord_mask(inst->tex_idx);
 
-	 if (c->key.shadowtex_mask & (1<<inst->tex_unit))
+         if (inst->tex_shadow)
 	    read0 |= WRITEMASK_Z;
 	 break;
 
@@ -259,7 +268,6 @@ void brw_wm_pass1( struct brw_wm_compile *c )
 	 break;
 
       case OPCODE_DST:
-      case OPCODE_TXP:
       default:
 	 break;
       }
@@ -273,6 +281,3 @@ void brw_wm_pass1( struct brw_wm_compile *c )
       brw_wm_print_program(c, "pass1");
    }
 }
-
-
-
diff --git a/src/mesa/drivers/dri/i965/brw_wm_pass2.c b/src/mesa/drivers/dri/i965/brw_wm_pass2.c
index 6fca9ad..780edbc 100644
--- a/src/mesa/drivers/dri/i965/brw_wm_pass2.c
+++ b/src/mesa/drivers/dri/i965/brw_wm_pass2.c
@@ -84,7 +84,7 @@ static void init_registers( struct brw_wm_compile *c )
    for (j = 0; j < c->nr_creg; j++) 
       prealloc_reg(c, &c->creg[j], i++);
 
-   for (j = 0; j < FRAG_ATTRIB_MAX; j++) 
+   for (j = 0; j < FRAG_ATTRIB_MAX; j++) {
       if (inputs & (1<<j)) {
 	 /* index for vs output and ps input are not the same 
 	    in shader varying */
@@ -96,6 +96,7 @@ static void init_registers( struct brw_wm_compile *c )
 	 nr_interp_regs++;
 	 prealloc_reg(c, &c->payload.input_interp[index], i++);
       }
+   }
 
    assert(nr_interp_regs >= 1);
 
@@ -120,7 +121,7 @@ static void update_register_usage(struct brw_wm_compile *c,
       /* Only search those which can change:
        */
       if (grf->nextuse < thisinsn) {
-	 struct brw_wm_ref *ref = grf->value->lastuse;
+	 const struct brw_wm_ref *ref = grf->value->lastuse;
 
 	 /* Has last use of value been passed?
 	  */
@@ -148,7 +149,7 @@ static void spill_value(struct brw_wm_compile *c,
    /* Allocate a spill slot.  Note that allocations start from 0x40 -
     * the first slot is reserved to mean "undef" in brw_wm_emit.c
     */
-   if (!value->spill_slot) {  
+   if (!value->spill_slot) {
       c->last_scratch += 0x40;	
       value->spill_slot = c->last_scratch;
    }
@@ -189,7 +190,7 @@ static GLuint search_contiguous_regs(struct brw_wm_compile *c,
 	 if (grf[i+j].nextuse < group_nextuse)
 	    group_nextuse = grf[i+j].nextuse;
       }
-	 
+
       if (group_nextuse > furthest) {
 	 furthest = group_nextuse;
 	 reg = i;
@@ -197,7 +198,7 @@ static GLuint search_contiguous_regs(struct brw_wm_compile *c,
    }
 
    assert(furthest != thisinsn);
-   
+
    /* Any non-empty regs will need to be spilled:
     */
    for (j = 0; j < nr; j++) 
@@ -243,7 +244,7 @@ static void alloc_contiguous_dest(struct brw_wm_compile *c,
 
 static void load_args(struct brw_wm_compile *c, 
 		      struct brw_wm_instruction *inst)
-{   
+{
    GLuint thisinsn = inst - c->instruction;
    GLuint i,j;
 
@@ -258,17 +259,17 @@ static void load_args(struct brw_wm_compile *c,
 		* register allocation and mark the ref as requiring a fill.
 		*/
 	       GLuint reg = search_contiguous_regs(c, 1, thisinsn);
-            
+
 	       c->pass2_grf[reg].value = ref->value;
 	       c->pass2_grf[reg].nextuse = thisinsn;
-	    
+
 	       ref->value->resident = &c->pass2_grf[reg];
 
 	       /* Note that a fill is required:
 		*/
 	       ref->unspill_reg = reg*2;
 	    }
-	    
+
 	    /* Adjust the hw_reg to point at the value's current location:
 	     */
 	    assert(ref->value == ref->value->resident->value);
@@ -294,7 +295,7 @@ void brw_wm_pass2( struct brw_wm_compile *c )
 
    for (insn = 0; insn < c->nr_insns; insn++) {
       struct brw_wm_instruction *inst = &c->instruction[insn];
-      
+
       /* Update registers' nextuse values:
        */
       update_register_usage(c, insn);
@@ -322,11 +323,11 @@ void brw_wm_pass2( struct brw_wm_compile *c )
 	 break;
       }
 
-      if (TEST_DST_SPILLS && inst->opcode != WM_PIXELXY)
+      if (TEST_DST_SPILLS && inst->opcode != WM_PIXELXY) {
 	 for (i = 0; i < 4; i++)	
 	    if (inst->dst[i])
 	       spill_value(c, inst->dst[i]);
-
+      }
    }
 
    if (INTEL_DEBUG & DEBUG_WM) {
@@ -339,6 +340,3 @@ void brw_wm_pass2( struct brw_wm_compile *c )
        brw_wm_print_program(c, "pass2/done");
    }
 }
-
-
-
diff --git a/src/mesa/drivers/dri/i965/brw_wm_sampler_state.c b/src/mesa/drivers/dri/i965/brw_wm_sampler_state.c
index 8c9cb78..b6dac0d 100644
--- a/src/mesa/drivers/dri/i965/brw_wm_sampler_state.c
+++ b/src/mesa/drivers/dri/i965/brw_wm_sampler_state.c
@@ -220,14 +220,15 @@ static void
 brw_wm_sampler_populate_key(struct brw_context *brw,
 			    struct wm_sampler_key *key)
 {
+   GLcontext *ctx = &brw->intel.ctx;
    int unit;
 
    memset(key, 0, sizeof(*key));
 
    for (unit = 0; unit < BRW_MAX_TEX_UNIT; unit++) {
-      if (brw->attribs.Texture->Unit[unit]._ReallyEnabled) {
+      if (ctx->Texture.Unit[unit]._ReallyEnabled) {
 	 struct wm_sampler_entry *entry = &key->sampler[unit];
-	 struct gl_texture_unit *texUnit = &brw->attribs.Texture->Unit[unit];
+	 struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
 	 struct gl_texture_object *texObj = texUnit->_Current;
 	 struct intel_texture_object *intelObj = intel_texture_object(texObj);
 	 struct gl_texture_image *firstImage =
@@ -274,6 +275,7 @@ brw_wm_sampler_populate_key(struct brw_context *brw,
  */
 static void upload_wm_samplers( struct brw_context *brw )
 {
+   GLcontext *ctx = &brw->intel.ctx;
    struct wm_sampler_key key;
    int i;
 
@@ -317,7 +319,7 @@ static void upload_wm_samplers( struct brw_context *brw )
 
       /* Emit SDC relocations */
       for (i = 0; i < BRW_MAX_TEX_UNIT; i++) {
-	 if (!brw->attribs.Texture->Unit[i]._ReallyEnabled)
+	 if (!ctx->Texture.Unit[i]._ReallyEnabled)
 	    continue;
 
 	 dri_bo_emit_reloc(brw->wm.sampler_bo,
diff --git a/src/mesa/drivers/dri/i965/brw_wm_state.c b/src/mesa/drivers/dri/i965/brw_wm_state.c
index 5302405..3c3b347 100644
--- a/src/mesa/drivers/dri/i965/brw_wm_state.c
+++ b/src/mesa/drivers/dri/i965/brw_wm_state.c
@@ -60,6 +60,7 @@ struct brw_wm_unit_key {
 static void
 wm_unit_populate_key(struct brw_context *brw, struct brw_wm_unit_key *key)
 {
+   GLcontext *ctx = &brw->intel.ctx;
    const struct gl_fragment_program *fp = brw->fragment_program;
    struct intel_context *intel = &brw->intel;
 
@@ -95,7 +96,7 @@ wm_unit_populate_key(struct brw_context *brw, struct brw_wm_unit_key *key)
    key->sampler_count = brw->wm.sampler_count;
 
    /* _NEW_POLYGONSTIPPLE */
-   key->polygon_stipple = brw->attribs.Polygon->StippleFlag;
+   key->polygon_stipple = ctx->Polygon.StippleFlag;
 
    /* BRW_NEW_FRAGMENT_PROGRAM */
    key->uses_depth = (fp->Base.InputsRead & (1 << FRAG_ATTRIB_WPOS)) != 0;
@@ -105,19 +106,19 @@ wm_unit_populate_key(struct brw_context *brw, struct brw_wm_unit_key *key)
       (fp->Base.OutputsWritten & (1 << FRAG_RESULT_DEPR)) != 0;
 
    /* _NEW_COLOR */
-   key->uses_kill = fp->UsesKill || brw->attribs.Color->AlphaEnabled;
+   key->uses_kill = fp->UsesKill || ctx->Color.AlphaEnabled;
    key->is_glsl = brw_wm_is_glsl(fp);
 
    /* XXX: This needs a flag to indicate when it changes. */
    key->stats_wm = intel->stats_wm;
 
    /* _NEW_LINE */
-   key->line_stipple = brw->attribs.Line->StippleFlag;
+   key->line_stipple = ctx->Line.StippleFlag;
 
    /* _NEW_POLYGON */
-   key->offset_enable = brw->attribs.Polygon->OffsetFill;
-   key->offset_units = brw->attribs.Polygon->OffsetUnits;
-   key->offset_factor = brw->attribs.Polygon->OffsetFactor;
+   key->offset_enable = ctx->Polygon.OffsetFill;
+   key->offset_units = ctx->Polygon.OffsetUnits;
+   key->offset_factor = ctx->Polygon.OffsetFactor;
 }
 
 static dri_bo *
diff --git a/src/mesa/drivers/dri/i965/brw_wm_surface_state.c b/src/mesa/drivers/dri/i965/brw_wm_surface_state.c
index 06e71e6..e402fdf 100644
--- a/src/mesa/drivers/dri/i965/brw_wm_surface_state.c
+++ b/src/mesa/drivers/dri/i965/brw_wm_surface_state.c
@@ -139,7 +139,15 @@ static GLuint translate_tex_format( GLuint mesa_format, GLenum depth_mode )
       return BRW_SURFACEFORMAT_BC1_UNORM_SRGB;
 
    case MESA_FORMAT_S8_Z24:
-      return BRW_SURFACEFORMAT_I24X8_UNORM;
+      /* XXX: these different surface formats don't seem to
+       * make any difference for shadow sampler/compares.
+       */
+      if (depth_mode == GL_INTENSITY) 
+         return BRW_SURFACEFORMAT_I24X8_UNORM;
+      else if (depth_mode == GL_ALPHA)
+         return BRW_SURFACEFORMAT_A24X8_UNORM;
+      else
+         return BRW_SURFACEFORMAT_L24X8_UNORM;
 
    default:
       assert(0);
@@ -253,7 +261,7 @@ static void
 brw_update_texture_surface( GLcontext *ctx, GLuint unit )
 {
    struct brw_context *brw = brw_context(ctx);
-   struct gl_texture_object *tObj = brw->attribs.Texture->Unit[unit]._Current;
+   struct gl_texture_object *tObj = ctx->Texture.Unit[unit]._Current;
    struct intel_texture_object *intelObj = intel_texture_object(tObj);
    struct gl_texture_image *firstImage = tObj->Image[0][intelObj->firstLevel];
    struct brw_wm_surface_key key;
@@ -301,6 +309,7 @@ static void
 brw_update_region_surface(struct brw_context *brw, struct intel_region *region,
 			  unsigned int unit, GLboolean cached)
 {
+   GLcontext *ctx = &brw->intel.ctx;
    dri_bo *region_bo = NULL;
    struct {
       unsigned int surface_type;
@@ -333,10 +342,10 @@ brw_update_region_surface(struct brw_context *brw, struct intel_region *region,
       key.height = 1;
       key.cpp = 4;
    }
-   memcpy(key.color_mask, brw->attribs.Color->ColorMask,
+   memcpy(key.color_mask, ctx->Color.ColorMask,
 	  sizeof(key.color_mask));
-   key.color_blend = (!brw->attribs.Color->_LogicOpEnabled &&
-		      brw->attribs.Color->BlendEnabled);
+   key.color_blend = (!ctx->Color._LogicOpEnabled &&
+		      ctx->Color.BlendEnabled);
 
    dri_bo_unreference(brw->wm.surf_bo[unit]);
    brw->wm.surf_bo[unit] = NULL;
@@ -380,8 +389,7 @@ brw_update_region_surface(struct brw_context *brw, struct intel_region *region,
 	  * a more restrictive relocation to emit.
 	  */
 	 dri_bo_emit_reloc(brw->wm.surf_bo[unit],
-			   I915_GEM_DOMAIN_RENDER |
-			   I915_GEM_DOMAIN_SAMPLER,
+			   I915_GEM_DOMAIN_RENDER,
 			   I915_GEM_DOMAIN_RENDER,
 			   0,
 			   offsetof(struct brw_surface_state, ss1),
@@ -446,20 +454,20 @@ static void prepare_wm_surfaces(struct brw_context *brw )
    GLuint i;
    int old_nr_surfaces;
 
-   if (brw->state.nr_draw_regions  > 1) {
-      for (i = 0; i < brw->state.nr_draw_regions; i++) {
-         brw_update_region_surface(brw, brw->state.draw_regions[i], i,
+   if (brw->state.nr_color_regions  > 1) {
+      for (i = 0; i < brw->state.nr_color_regions; i++) {
+         brw_update_region_surface(brw, brw->state.color_regions[i], i,
 				   GL_FALSE);
       }
-   }else {
-      brw_update_region_surface(brw, brw->state.draw_regions[0], 0, GL_TRUE);
+   } else {
+      brw_update_region_surface(brw, brw->state.color_regions[0], 0, GL_TRUE);
    }
 
    old_nr_surfaces = brw->wm.nr_surfaces;
    brw->wm.nr_surfaces = MAX_DRAW_BUFFERS;
 
    for (i = 0; i < BRW_MAX_TEX_UNIT; i++) {
-      struct gl_texture_unit *texUnit = &brw->attribs.Texture->Unit[i];
+      struct gl_texture_unit *texUnit = &ctx->Texture.Unit[i];
 
       /* _NEW_TEXTURE, BRW_NEW_TEXDATA */
       if(texUnit->_ReallyEnabled) {
\ No newline at end of file
diff --git a/src/mesa/drivers/dri/i965/intel_state.c b/src/mesa/drivers/dri/i965/intel_state.c
deleted file mode 100644
index 67ef5f7..519672f
--- a/src/mesa/drivers/dri/i965/intel_state.c
+++ /dev/null
@@ -1,225 +0,0 @@
-/**************************************************************************
- * 
- * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
- * All Rights Reserved.
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- * 
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- * 
- **************************************************************************/
-
-
-#include "main/glheader.h"
-#include "main/context.h"
-#include "main/macros.h"
-#include "main/enums.h"
-#include "main/colormac.h"
-#include "main/dd.h"
-
-#include "intel_screen.h"
-#include "intel_context.h"
-#include "intel_regions.h"
-#include "swrast/swrast.h"
-
-int intel_translate_shadow_compare_func( GLenum func )
-{
-   switch(func) {
-   case GL_NEVER: 
-       return COMPAREFUNC_ALWAYS; 
-   case GL_LESS: 
-       return COMPAREFUNC_LEQUAL; 
-   case GL_LEQUAL: 
-       return COMPAREFUNC_LESS;
-   case GL_GREATER: 
-       return COMPAREFUNC_GEQUAL; 
-   case GL_GEQUAL: 
-      return COMPAREFUNC_GREATER; 
-   case GL_NOTEQUAL: 
-      return COMPAREFUNC_EQUAL; 
-   case GL_EQUAL: 
-      return COMPAREFUNC_NOTEQUAL; 
-   case GL_ALWAYS: 
-       return COMPAREFUNC_NEVER; 
-   }
-
-   fprintf(stderr, "Unknown value in %s: %x\n", __FUNCTION__, func);
-   return COMPAREFUNC_NEVER; 
-}
-
-int intel_translate_compare_func( GLenum func )
-{
-   switch(func) {
-   case GL_NEVER: 
-      return COMPAREFUNC_NEVER; 
-   case GL_LESS: 
-      return COMPAREFUNC_LESS; 
-   case GL_LEQUAL: 
-      return COMPAREFUNC_LEQUAL; 
-   case GL_GREATER: 
-      return COMPAREFUNC_GREATER; 
-   case GL_GEQUAL: 
-      return COMPAREFUNC_GEQUAL; 
-   case GL_NOTEQUAL: 
-      return COMPAREFUNC_NOTEQUAL; 
-   case GL_EQUAL: 
-      return COMPAREFUNC_EQUAL; 
-   case GL_ALWAYS: 
-      return COMPAREFUNC_ALWAYS; 
-   }
-
-   fprintf(stderr, "Unknown value in %s: %x\n", __FUNCTION__, func);
-   return COMPAREFUNC_ALWAYS; 
-}
-
-int intel_translate_stencil_op( GLenum op )
-{
-   switch(op) {
-   case GL_KEEP: 
-      return STENCILOP_KEEP; 
-   case GL_ZERO: 
-      return STENCILOP_ZERO; 
-   case GL_REPLACE: 
-      return STENCILOP_REPLACE; 
-   case GL_INCR: 
-      return STENCILOP_INCRSAT;
-   case GL_DECR: 
-      return STENCILOP_DECRSAT;
-   case GL_INCR_WRAP:
-      return STENCILOP_INCR; 
-   case GL_DECR_WRAP:
-      return STENCILOP_DECR; 
-   case GL_INVERT: 
-      return STENCILOP_INVERT; 
-   default: 
-      return STENCILOP_ZERO;
-   }
-}
-
-int intel_translate_blend_factor( GLenum factor )
-{
-   switch(factor) {
-   case GL_ZERO: 
-      return BLENDFACT_ZERO; 
-   case GL_SRC_ALPHA: 
-      return BLENDFACT_SRC_ALPHA; 
-   case GL_ONE: 
-      return BLENDFACT_ONE; 
-   case GL_SRC_COLOR: 
-      return BLENDFACT_SRC_COLR; 
-   case GL_ONE_MINUS_SRC_COLOR: 
-      return BLENDFACT_INV_SRC_COLR; 
-   case GL_DST_COLOR: 
-      return BLENDFACT_DST_COLR; 
-   case GL_ONE_MINUS_DST_COLOR: 
-      return BLENDFACT_INV_DST_COLR; 
-   case GL_ONE_MINUS_SRC_ALPHA:
-      return BLENDFACT_INV_SRC_ALPHA; 
-   case GL_DST_ALPHA: 
-      return BLENDFACT_DST_ALPHA; 
-   case GL_ONE_MINUS_DST_ALPHA:
-      return BLENDFACT_INV_DST_ALPHA; 
-   case GL_SRC_ALPHA_SATURATE: 
-      return BLENDFACT_SRC_ALPHA_SATURATE;
-   case GL_CONSTANT_COLOR:
-      return BLENDFACT_CONST_COLOR; 
-   case GL_ONE_MINUS_CONSTANT_COLOR:
-      return BLENDFACT_INV_CONST_COLOR;
-   case GL_CONSTANT_ALPHA:
-      return BLENDFACT_CONST_ALPHA; 
-   case GL_ONE_MINUS_CONSTANT_ALPHA:
-      return BLENDFACT_INV_CONST_ALPHA;
-   }
-   
-   fprintf(stderr, "Unknown value in %s: %x\n", __FUNCTION__, factor);
-   return BLENDFACT_ZERO;
-}
-
-int intel_translate_logic_op( GLenum opcode )
-{
-   switch(opcode) {
-   case GL_CLEAR: 
-      return LOGICOP_CLEAR; 
-   case GL_AND: 
-      return LOGICOP_AND; 
-   case GL_AND_REVERSE: 
-      return LOGICOP_AND_RVRSE; 
-   case GL_COPY: 
-      return LOGICOP_COPY; 
-   case GL_COPY_INVERTED: 
-      return LOGICOP_COPY_INV; 
-   case GL_AND_INVERTED: 
-      return LOGICOP_AND_INV; 
-   case GL_NOOP: 
-      return LOGICOP_NOOP; 
-   case GL_XOR: 
-      return LOGICOP_XOR; 
-   case GL_OR: 
-      return LOGICOP_OR; 
-   case GL_OR_INVERTED: 
-      return LOGICOP_OR_INV; 
-   case GL_NOR: 
-      return LOGICOP_NOR; 
-   case GL_EQUIV: 
-      return LOGICOP_EQUIV; 
-   case GL_INVERT: 
-      return LOGICOP_INV; 
-   case GL_OR_REVERSE: 
-      return LOGICOP_OR_RVRSE; 
-   case GL_NAND: 
-      return LOGICOP_NAND; 
-   case GL_SET: 
-      return LOGICOP_SET; 
-   default:
-      return LOGICOP_SET;
-   }
-}
-
-
-static void intelClearColor(GLcontext *ctx, const GLfloat color[4])
-{
-   struct intel_context *intel = intel_context(ctx);
-
-   UNCLAMPED_FLOAT_TO_RGBA_CHAN(intel->clear_chan, color);
-
-   intel->ClearColor8888 = INTEL_PACKCOLOR8888(intel->clear_chan[0],
-					       intel->clear_chan[1],
-					       intel->clear_chan[2],
-					       intel->clear_chan[3]);
-   intel->ClearColor565 = INTEL_PACKCOLOR565(intel->clear_chan[0],
-					     intel->clear_chan[1],
-					     intel->clear_chan[2]);
-}
-
-
-
-/* Fallback to swrast for select and feedback.
- */
-static void intelRenderMode( GLcontext *ctx, GLenum mode )
-{
-   struct intel_context *intel = intel_context(ctx);
-   FALLBACK( intel, INTEL_FALLBACK_RENDERMODE, (mode != GL_RENDER) );
-}
-
-
-void intelInitStateFuncs( struct dd_function_table *functions )
-{
-   functions->RenderMode = intelRenderMode;
-   functions->ClearColor = intelClearColor;
-}
diff --git a/src/mesa/drivers/dri/intel/intel_buffers.c b/src/mesa/drivers/dri/intel/intel_buffers.c
index 0fd2f16..7f2144a 100644
--- a/src/mesa/drivers/dri/intel/intel_buffers.c
+++ b/src/mesa/drivers/dri/intel/intel_buffers.c
@@ -25,25 +25,14 @@
  * 
  **************************************************************************/
 
-#include "intel_screen.h"
 #include "intel_context.h"
-#include "intel_blit.h"
 #include "intel_buffers.h"
-#include "intel_chipset.h"
-#include "intel_depthstencil.h"
 #include "intel_fbo.h"
 #include "intel_regions.h"
 #include "intel_batchbuffer.h"
-#include "intel_reg.h"
-#include "main/context.h"
 #include "main/framebuffer.h"
-#include "swrast/swrast.h"
-#include "utils.h"
 #include "drirenderbuffer.h"
-#include "vblank.h"
-#include "i915_drm.h"
 
-#define FILE_DEBUG_FLAG DEBUG_BLIT
 
 /**
  * XXX move this into a new dri/common/cliprects.c file.
@@ -114,7 +103,6 @@ intel_get_cliprects(struct intel_context *intel,
 		    int *x_off, int *y_off)
 {
    __DRIdrawablePrivate *dPriv = intel->driDrawable;
-   struct intel_framebuffer *intel_fb = dPriv->driverPrivate;
 
    if (intel->constant_cliprect) {
       /* FBO or DRI2 rendering, which can just use the fb's size. */
@@ -143,399 +131,6 @@ intel_get_cliprects(struct intel_context *intel,
    }
 }
 
-/**
- * This will be called whenever the currently bound window is moved/resized.
- * XXX: actually, it seems to NOT be called when the window is only moved (BP).
- */
-void
-intelWindowMoved(struct intel_context *intel)
-{
-   GLcontext *ctx = &intel->ctx;
-   __DRIdrawablePrivate *dPriv = intel->driDrawable;
-   struct intel_framebuffer *intel_fb = dPriv->driverPrivate;
-
-   if (!intel->intelScreen->driScrnPriv->dri2.enabled &&
-       intel->intelScreen->driScrnPriv->ddx_version.minor >= 7) {
-      volatile drm_i915_sarea_t *sarea = intel->sarea;
-      drm_clip_rect_t drw_rect = { .x1 = dPriv->x, .x2 = dPriv->x + dPriv->w,
-				   .y1 = dPriv->y, .y2 = dPriv->y + dPriv->h };
-      drm_clip_rect_t planeA_rect = { .x1 = sarea->planeA_x, .y1 = sarea->planeA_y,
-				     .x2 = sarea->planeA_x + sarea->planeA_w,
-				     .y2 = sarea->planeA_y + sarea->planeA_h };
-      drm_clip_rect_t planeB_rect = { .x1 = sarea->planeB_x, .y1 = sarea->planeB_y,
-				     .x2 = sarea->planeB_x + sarea->planeB_w,
-				     .y2 = sarea->planeB_y + sarea->planeB_h };
-      GLint areaA = driIntersectArea( drw_rect, planeA_rect );
-      GLint areaB = driIntersectArea( drw_rect, planeB_rect );
-      GLuint flags = dPriv->vblFlags;
-
-      /* Update vblank info
-       */
-      if (areaB > areaA || (areaA == areaB && areaB > 0)) {
-	 flags = dPriv->vblFlags | VBLANK_FLAG_SECONDARY;
-      } else {
-	 flags = dPriv->vblFlags & ~VBLANK_FLAG_SECONDARY;
-      }
-
-      /* Check to see if we changed pipes */
-      if (flags != dPriv->vblFlags && dPriv->vblFlags &&
-	  !(dPriv->vblFlags & VBLANK_FLAG_NO_IRQ)) {
-	 int64_t count;
-	 drmVBlank vbl;
-	 int i;
-
-	 /*
-	  * Deal with page flipping
-	  */
-	 vbl.request.type = DRM_VBLANK_ABSOLUTE;
-
-	 if ( dPriv->vblFlags & VBLANK_FLAG_SECONDARY ) {
-	    vbl.request.type |= DRM_VBLANK_SECONDARY;
-	 }
-
-	 for (i = 0; i < 2; i++) {
-	    if (!intel_fb->color_rb[i] ||
-		(intel_fb->vbl_waited - intel_fb->color_rb[i]->vbl_pending) <=
-		(1<<23))
-	       continue;
-
-	    vbl.request.sequence = intel_fb->color_rb[i]->vbl_pending;
-	    drmWaitVBlank(intel->driFd, &vbl);
-	 }
-
-	 /*
-	  * Update msc_base from old pipe
-	  */
-	 driDrawableGetMSC32(dPriv->driScreenPriv, dPriv, &count);
-	 dPriv->msc_base = count;
-	 /*
-	  * Then get new vblank_base and vblSeq values
-	  */
-	 dPriv->vblFlags = flags;
-	 driGetCurrentVBlank(dPriv);
-	 dPriv->vblank_base = dPriv->vblSeq;
-
-	 intel_fb->vbl_waited = dPriv->vblSeq;
-
-	 for (i = 0; i < 2; i++) {
-	    if (intel_fb->color_rb[i])
-	       intel_fb->color_rb[i]->vbl_pending = intel_fb->vbl_waited;
-	 }
-      }
-   } else {
-      dPriv->vblFlags &= ~VBLANK_FLAG_SECONDARY;
-   }
-
-   /* Update Mesa's notion of window size */
-   driUpdateFramebufferSize(ctx, dPriv);
-   intel_fb->Base.Initialized = GL_TRUE; /* XXX remove someday */
-
-   /* Update hardware scissor */
-   if (ctx->Driver.Scissor != NULL) {
-      ctx->Driver.Scissor(ctx, ctx->Scissor.X, ctx->Scissor.Y,
-			  ctx->Scissor.Width, ctx->Scissor.Height);
-   }
-
-   /* Re-calculate viewport related state */
-   if (ctx->Driver.DepthRange != NULL)
-      ctx->Driver.DepthRange( ctx, ctx->Viewport.Near, ctx->Viewport.Far );
-}
-
-
-
-/* A true meta version of this would be very simple and additionally
- * machine independent.  Maybe we'll get there one day.
- */
-static void
-intelClearWithTris(struct intel_context *intel, GLbitfield mask)
-{
-   GLcontext *ctx = &intel->ctx;
-   struct gl_framebuffer *fb = ctx->DrawBuffer;
-   GLuint buf;
-
-   intel->vtbl.install_meta_state(intel);
-
-   /* Back and stencil cliprects are the same.  Try and do both
-    * buffers at once:
-    */
-   if (mask & (BUFFER_BIT_BACK_LEFT | BUFFER_BIT_STENCIL | BUFFER_BIT_DEPTH)) {
-      struct intel_region *backRegion =
-	 intel_get_rb_region(fb, BUFFER_BACK_LEFT);
-      struct intel_region *depthRegion =
-	 intel_get_rb_region(fb, BUFFER_DEPTH);
-
-      intel->vtbl.meta_draw_region(intel, backRegion, depthRegion);
-
-      if (mask & BUFFER_BIT_BACK_LEFT)
-	 intel->vtbl.meta_color_mask(intel, GL_TRUE);
-      else
-	 intel->vtbl.meta_color_mask(intel, GL_FALSE);
-
-      if (mask & BUFFER_BIT_STENCIL)
-	 intel->vtbl.meta_stencil_replace(intel,
-					  intel->ctx.Stencil.WriteMask[0],
-					  intel->ctx.Stencil.Clear);
-      else
-	 intel->vtbl.meta_no_stencil_write(intel);
-
-      if (mask & BUFFER_BIT_DEPTH)
-	 intel->vtbl.meta_depth_replace(intel);
-      else
-	 intel->vtbl.meta_no_depth_write(intel);
-
-      intel->vtbl.meta_draw_quad(intel,
-				 fb->_Xmin,
-				 fb->_Xmax,
-				 fb->_Ymin,
-				 fb->_Ymax,
-				 intel->ctx.Depth.Clear,
-				 intel->ClearColor8888,
-				 0, 0, 0, 0);   /* texcoords */
-
-      mask &= ~(BUFFER_BIT_BACK_LEFT | BUFFER_BIT_STENCIL | BUFFER_BIT_DEPTH);
-   }
-
-   /* clear the remaining (color) renderbuffers */
-   for (buf = 0; buf < BUFFER_COUNT && mask; buf++) {
-      const GLuint bufBit = 1 << buf;
-      if (mask & bufBit) {
-	 struct intel_renderbuffer *irbColor =
-	    intel_renderbuffer(fb->Attachment[buf].Renderbuffer);
-
-	 ASSERT(irbColor);
-
-	 intel->vtbl.meta_no_depth_write(intel);
-	 intel->vtbl.meta_no_stencil_write(intel);
-	 intel->vtbl.meta_color_mask(intel, GL_TRUE);
-	 intel->vtbl.meta_draw_region(intel, irbColor->region, NULL);
-
-	 intel->vtbl.meta_draw_quad(intel,
-				    fb->_Xmin,
-				    fb->_Xmax,
-				    fb->_Ymin,
-				    fb->_Ymax,
-				    0, intel->ClearColor8888,
-				    0, 0, 0, 0);   /* texcoords */
-
-	 mask &= ~bufBit;
-      }
-   }
-
-   intel->vtbl.leave_meta_state(intel);
-}
-
-static const char *buffer_names[] = {
-   [BUFFER_FRONT_LEFT] = "front",
-   [BUFFER_BACK_LEFT] = "back",
-   [BUFFER_FRONT_RIGHT] = "front right",
-   [BUFFER_BACK_RIGHT] = "back right",
-   [BUFFER_AUX0] = "aux0",
-   [BUFFER_AUX1] = "aux1",
-   [BUFFER_AUX2] = "aux2",
-   [BUFFER_AUX3] = "aux3",
-   [BUFFER_DEPTH] = "depth",
-   [BUFFER_STENCIL] = "stencil",
-   [BUFFER_ACCUM] = "accum",
-   [BUFFER_COLOR0] = "color0",
-   [BUFFER_COLOR1] = "color1",
-   [BUFFER_COLOR2] = "color2",
-   [BUFFER_COLOR3] = "color3",
-   [BUFFER_COLOR4] = "color4",
-   [BUFFER_COLOR5] = "color5",
-   [BUFFER_COLOR6] = "color6",
-   [BUFFER_COLOR7] = "color7",
-};
-
-/**
- * Called by ctx->Driver.Clear.
- */
-static void
-intelClear(GLcontext *ctx, GLbitfield mask)
-{
-   struct intel_context *intel = intel_context(ctx);
-   const GLuint colorMask = *((GLuint *) & ctx->Color.ColorMask);
-   GLbitfield tri_mask = 0;
-   GLbitfield blit_mask = 0;
-   GLbitfield swrast_mask = 0;
-   struct gl_framebuffer *fb = ctx->DrawBuffer;
-   GLuint i;
-
-   if (0)
-      fprintf(stderr, "%s\n", __FUNCTION__);
-
-   /* HW color buffers (front, back, aux, generic FBO, etc) */
-   if (colorMask == ~0) {
-      /* clear all R,G,B,A */
-      /* XXX FBO: need to check if colorbuffers are software RBOs! */
-      blit_mask |= (mask & BUFFER_BITS_COLOR);
-   }
-   else {
-      /* glColorMask in effect */
-      tri_mask |= (mask & BUFFER_BITS_COLOR);
-   }
-
-   /* HW stencil */
-   if (mask & BUFFER_BIT_STENCIL) {
-      const struct intel_region *stencilRegion
-         = intel_get_rb_region(fb, BUFFER_STENCIL);
-      if (stencilRegion) {
-         /* have hw stencil */
-         if (IS_965(intel->intelScreen->deviceID) ||
-	     (ctx->Stencil.WriteMask[0] & 0xff) != 0xff) {
-	    /* We have to use the 3D engine if we're clearing a partial mask
-	     * of the stencil buffer, or if we're on a 965 which has a tiled
-	     * depth/stencil buffer in a layout we can't blit to.
-	     */
-            tri_mask |= BUFFER_BIT_STENCIL;
-         }
-         else {
-            /* clearing all stencil bits, use blitting */
-            blit_mask |= BUFFER_BIT_STENCIL;
-         }
-      }
-   }
-
-   /* HW depth */
-   if (mask & BUFFER_BIT_DEPTH) {
-      /* clear depth with whatever method is used for stencil (see above) */
-      if (IS_965(intel->intelScreen->deviceID) ||
-	  tri_mask & BUFFER_BIT_STENCIL)
-         tri_mask |= BUFFER_BIT_DEPTH;
-      else
-         blit_mask |= BUFFER_BIT_DEPTH;
-   }
-
-   /* SW fallback clearing */
-   swrast_mask = mask & ~tri_mask & ~blit_mask;
-
-   for (i = 0; i < BUFFER_COUNT; i++) {
-      GLuint bufBit = 1 << i;
-      if ((blit_mask | tri_mask) & bufBit) {
-         if (!fb->Attachment[i].Renderbuffer->ClassID) {
-            blit_mask &= ~bufBit;
-            tri_mask &= ~bufBit;
-            swrast_mask |= bufBit;
-         }
-      }
-   }
-
-   if (blit_mask) {
-      if (INTEL_DEBUG & DEBUG_BLIT) {
-	 DBG("blit clear:");
-	 for (i = 0; i < BUFFER_COUNT; i++) {
-	    if (blit_mask & (1 << i))
-	       DBG(" %s", buffer_names[i]);
-	 }
-	 DBG("\n");
-      }
-      intelClearWithBlit(ctx, blit_mask);
-   }
-
-   if (tri_mask) {
-      if (INTEL_DEBUG & DEBUG_BLIT) {
-	 DBG("tri clear:");
-	 for (i = 0; i < BUFFER_COUNT; i++) {
-	    if (tri_mask & (1 << i))
-	       DBG(" %s", buffer_names[i]);
-	 }
-	 DBG("\n");
-      }
-      intelClearWithTris(intel, tri_mask);
-   }
-
-   if (swrast_mask) {
-      if (INTEL_DEBUG & DEBUG_BLIT) {
-	 DBG("swrast clear:");
-	 for (i = 0; i < BUFFER_COUNT; i++) {
-	    if (swrast_mask & (1 << i))
-	       DBG(" %s", buffer_names[i]);
-	 }
-	 DBG("\n");
-      }
-      _swrast_Clear(ctx, swrast_mask);
-   }
-}
-
-void
-intelSwapBuffers(__DRIdrawablePrivate * dPriv)
-{
-   __DRIscreenPrivate *psp = dPriv->driScreenPriv;
-
-   if (dPriv->driContextPriv && dPriv->driContextPriv->driverPrivate) {
-      GET_CURRENT_CONTEXT(ctx);
-      struct intel_context *intel;
-
-      if (ctx == NULL)
-	 return;
-
-      intel = intel_context(ctx);
-
-      if (ctx->Visual.doubleBufferMode) {
-	 GLboolean missed_target;
-	 struct intel_framebuffer *intel_fb = dPriv->driverPrivate;
-	 int64_t ust;
-         
-	 _mesa_notifySwapBuffers(ctx);  /* flush pending rendering comands */
-
-	/*
-	 * The old swapping ioctl was incredibly racy, just wait for vblank
-	 * and do the swap ourselves.
-	 */
-	 driWaitForVBlank(dPriv, &missed_target);
-
-	 /*
-	  * Update each buffer's vbl_pending so we don't get too out of
-	  * sync
-	  */
-	 intel_get_renderbuffer(&intel_fb->Base,
-		   		BUFFER_BACK_LEFT)->vbl_pending = dPriv->vblSeq;
-         intel_get_renderbuffer(&intel_fb->Base,
-		   		BUFFER_FRONT_LEFT)->vbl_pending = dPriv->vblSeq;
-
-	 intelCopyBuffer(dPriv, NULL);
-
-	 intel_fb->swap_count++;
-	 (*psp->systemTime->getUST) (&ust);
-	 if (missed_target) {
-	    intel_fb->swap_missed_count++;
-	    intel_fb->swap_missed_ust = ust - intel_fb->swap_ust;
-	 }
-
-	 intel_fb->swap_ust = ust;
-      }
-      drmCommandNone(intel->driFd, DRM_I915_GEM_THROTTLE);
-
-   }
-   else {
-      /* XXX this shouldn't be an error but we can't handle it for now */
-      fprintf(stderr, "%s: drawable has no context!\n", __FUNCTION__);
-   }
-}
-
-void
-intelCopySubBuffer(__DRIdrawablePrivate * dPriv, int x, int y, int w, int h)
-{
-   if (dPriv->driContextPriv && dPriv->driContextPriv->driverPrivate) {
-      struct intel_context *intel =
-         (struct intel_context *) dPriv->driContextPriv->driverPrivate;
-      GLcontext *ctx = &intel->ctx;
-
-      if (ctx->Visual.doubleBufferMode) {
-         drm_clip_rect_t rect;
-         rect.x1 = x + dPriv->x;
-         rect.y1 = (dPriv->h - y - h) + dPriv->y;
-         rect.x2 = rect.x1 + w;
-         rect.y2 = rect.y1 + h;
-         _mesa_notifySwapBuffers(ctx);  /* flush pending rendering comands */
-         intelCopyBuffer(dPriv, &rect);
-      }
-   }
-   else {
-      /* XXX this shouldn't be an error but we can't handle it for now */
-      fprintf(stderr, "%s: drawable has no context!\n", __FUNCTION__);
-   }
-}
-
 
 /**
  * Update the hardware state for drawing into a window or framebuffer object.
@@ -559,7 +154,7 @@ intel_draw_buffer(GLcontext * ctx, struct gl_framebuffer *fb)
       return;
    }
 
-   /* Do this here, note core Mesa, since this function is called from
+   /* Do this here, not core Mesa, since this function is called from
     * many places within the driver.
     */
    if (ctx->NewState & (_NEW_BUFFERS | _NEW_COLOR | _NEW_PIXEL)) {
@@ -577,9 +172,6 @@ intel_draw_buffer(GLcontext * ctx, struct gl_framebuffer *fb)
       return;
    }
 
-   if (fb->Name)
-      intel_validate_paired_depth_stencil(ctx, fb);
-
    /*
     * How many color buffers are we drawing into?
     */
@@ -587,7 +179,8 @@ intel_draw_buffer(GLcontext * ctx, struct gl_framebuffer *fb)
       /* writing to 0  */
       colorRegions[0] = NULL;
       intel->constant_cliprect = GL_TRUE;
-   } else if (fb->_NumColorDrawBuffers > 1) {
+   }
+   else if (fb->_NumColorDrawBuffers > 1) {
        int i;
        struct intel_renderbuffer *irb;
 
@@ -626,14 +219,6 @@ intel_draw_buffer(GLcontext * ctx, struct gl_framebuffer *fb)
       }
    }
 
-   /* Update culling direction which changes depending on the
-    * orientation of the buffer:
-    */
-   if (ctx->Driver.FrontFace)
-      ctx->Driver.FrontFace(ctx, ctx->Polygon.FrontFace);
-   else
-      ctx->NewState |= _NEW_POLYGON;
-
    if (!colorRegions[0]) {
       FALLBACK(intel, INTEL_FALLBACK_DRAW_BUFFER, GL_TRUE);
    }
@@ -665,20 +250,13 @@ intel_draw_buffer(GLcontext * ctx, struct gl_framebuffer *fb)
    /***
     *** Stencil buffer
     *** This can only be hardware accelerated if we're using a
-    *** combined DEPTH_STENCIL buffer (for now anyway).
+    *** combined DEPTH_STENCIL buffer.
     ***/
    if (fb->_StencilBuffer && fb->_StencilBuffer->Wrapped) {
       irbStencil = intel_renderbuffer(fb->_StencilBuffer->Wrapped);
       if (irbStencil && irbStencil->region) {
          ASSERT(irbStencil->Base._ActualFormat == GL_DEPTH24_STENCIL8_EXT);
          FALLBACK(intel, INTEL_FALLBACK_STENCIL_BUFFER, GL_FALSE);
-         /* need to re-compute stencil hw state */
-	 if (ctx->Driver.Enable != NULL)
-	    ctx->Driver.Enable(ctx, GL_STENCIL_TEST, ctx->Stencil.Enabled);
-	 else
-	    ctx->NewState |= _NEW_STENCIL;
-         if (!depthRegion)
-            depthRegion = irbStencil->region;
       }
       else {
          FALLBACK(intel, INTEL_FALLBACK_STENCIL_BUFFER, GL_TRUE);
@@ -687,37 +265,30 @@ intel_draw_buffer(GLcontext * ctx, struct gl_framebuffer *fb)
    else {
       /* XXX FBO: instead of FALSE, pass ctx->Stencil.Enabled ??? */
       FALLBACK(intel, INTEL_FALLBACK_STENCIL_BUFFER, GL_FALSE);
-      /* need to re-compute stencil hw state */
-      if (ctx->Driver.Enable != NULL)
-	 ctx->Driver.Enable(ctx, GL_STENCIL_TEST, ctx->Stencil.Enabled);
-      else
-	 ctx->NewState |= _NEW_STENCIL;
    }
 
    /*
-    * Update depth test state
+    * Update depth and stencil test state
     */
    if (ctx->Driver.Enable) {
-      if (ctx->Depth.Test && fb->Visual.depthBits > 0) {
-	 ctx->Driver.Enable(ctx, GL_DEPTH_TEST, GL_TRUE);
-      } else {
-	 ctx->Driver.Enable(ctx, GL_DEPTH_TEST, GL_FALSE);
-      }
-   } else {
-      ctx->NewState |= _NEW_DEPTH;
+      ctx->Driver.Enable(ctx, GL_DEPTH_TEST,
+                         (ctx->Depth.Test && fb->Visual.depthBits > 0));
+      ctx->Driver.Enable(ctx, GL_STENCIL_TEST,
+                         (ctx->Stencil.Enabled && fb->Visual.stencilBits > 0));
+   }
+   else {
+      ctx->NewState |= (_NEW_DEPTH | _NEW_STENCIL);
    }
 
    intel->vtbl.set_draw_region(intel, colorRegions, depthRegion, 
-	fb->_NumColorDrawBuffers);
+                               fb->_NumColorDrawBuffers);
 
    /* update viewport since it depends on window size */
-   if (ctx->Driver.Viewport) {
-      ctx->Driver.Viewport(ctx, ctx->Viewport.X, ctx->Viewport.Y,
-			   ctx->Viewport.Width, ctx->Viewport.Height);
-   } else {
-      ctx->NewState |= _NEW_VIEWPORT;
-   }
-
+#ifdef I915
+   intelCalcViewport(ctx);
+#else
+   ctx->NewState |= _NEW_VIEWPORT;
+#endif
    /* Set state we know depends on drawable parameters:
     */
    if (ctx->Driver.Scissor)
@@ -729,6 +300,14 @@ intel_draw_buffer(GLcontext * ctx, struct gl_framebuffer *fb)
       ctx->Driver.DepthRange(ctx,
 			     ctx->Viewport.Near,
 			     ctx->Viewport.Far);
+
+   /* Update culling direction which changes depending on the
+    * orientation of the buffer:
+    */
+   if (ctx->Driver.FrontFace)
+      ctx->Driver.FrontFace(ctx, ctx->Polygon.FrontFace);
+   else
+      ctx->NewState |= _NEW_POLYGON;
 }
 
 
@@ -759,7 +338,6 @@ intelReadBuffer(GLcontext * ctx, GLenum mode)
 void
 intelInitBufferFuncs(struct dd_function_table *functions)
 {
-   functions->Clear = intelClear;
    functions->DrawBuffer = intelDrawBuffer;
    functions->ReadBuffer = intelReadBuffer;
 }
diff --git a/src/mesa/drivers/dri/intel/intel_buffers.h b/src/mesa/drivers/dri/intel/intel_buffers.h
index 0be1cee..6069d38 100644
--- a/src/mesa/drivers/dri/intel/intel_buffers.h
+++ b/src/mesa/drivers/dri/intel/intel_buffers.h
@@ -45,10 +45,6 @@ extern struct intel_region *intel_readbuf_region(struct intel_context *intel);
 
 extern struct intel_region *intel_drawbuf_region(struct intel_context *intel);
 
-extern void intelSwapBuffers(__DRIdrawablePrivate * dPriv);
-
-extern void intelWindowMoved(struct intel_context *intel);
-
 extern void intel_draw_buffer(GLcontext * ctx, struct gl_framebuffer *fb);
 
 extern void intelInitBufferFuncs(struct dd_function_table *functions);
@@ -57,5 +53,8 @@ void intel_get_cliprects(struct intel_context *intel,
 			 struct drm_clip_rect **cliprects,
 			 unsigned int *num_cliprects,
 			 int *x_off, int *y_off);
+#ifdef I915
+void intelCalcViewport(GLcontext * ctx);
+#endif
 
 #endif /* INTEL_BUFFERS_H */
diff --git a/src/mesa/drivers/dri/intel/intel_clear.c b/src/mesa/drivers/dri/intel/intel_clear.c
new file mode 100644
index 0000000..c3ba50f
--- /dev/null
+++ b/src/mesa/drivers/dri/intel/intel_clear.c
@@ -0,0 +1,393 @@
+/**************************************************************************
+ * 
+ * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * Copyright 2009 Intel Corporation.
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ * 
+ **************************************************************************/
+
+#include "main/glheader.h"
+#include "main/enums.h"
+#include "main/image.h"
+#include "main/mtypes.h"
+#include "main/attrib.h"
+#include "main/blend.h"
+#include "main/bufferobj.h"
+#include "main/buffers.h"
+#include "main/depth.h"
+#include "main/enable.h"
+#include "main/macros.h"
+#include "main/matrix.h"
+#include "main/texstate.h"
+#include "main/shaders.h"
+#include "main/stencil.h"
+#include "main/varray.h"
+#include "glapi/dispatch.h"
+#include "swrast/swrast.h"
+
+#include "intel_context.h"
+#include "intel_blit.h"
+#include "intel_chipset.h"
+#include "intel_clear.h"
+#include "intel_fbo.h"
+#include "intel_pixel.h"
+
+#define FILE_DEBUG_FLAG DEBUG_BLIT
+
+#define TRI_CLEAR_COLOR_BITS (BUFFER_BIT_BACK_LEFT |			\
+			      BUFFER_BIT_FRONT_LEFT |			\
+			      BUFFER_BIT_COLOR0 |			\
+			      BUFFER_BIT_COLOR1 |			\
+			      BUFFER_BIT_COLOR2 |			\
+			      BUFFER_BIT_COLOR3 |			\
+			      BUFFER_BIT_COLOR4 |			\
+			      BUFFER_BIT_COLOR5 |			\
+			      BUFFER_BIT_COLOR6 |			\
+			      BUFFER_BIT_COLOR7)
+
+/**
+ * Perform glClear where mask contains only color, depth, and/or stencil.
+ *
+ * The implementation is based on calling into Mesa to set GL state and
+ * performing normal triangle rendering.  The intent of this path is to
+ * have as generic a path as possible, so that any driver could make use of
+ * it.
+ */
+void
+intel_clear_tris(GLcontext *ctx, GLbitfield mask)
+{
+   struct intel_context *intel = intel_context(ctx);
+   GLfloat vertices[4][3];
+   GLfloat color[4][4];
+   GLfloat dst_z;
+   struct gl_framebuffer *fb = ctx->DrawBuffer;
+   int i;
+   GLboolean saved_fp_enable = GL_FALSE, saved_vp_enable = GL_FALSE;
+   GLuint saved_shader_program = 0;
+   unsigned int saved_active_texture;
+
+   assert((mask & ~(TRI_CLEAR_COLOR_BITS | BUFFER_BIT_DEPTH |
+		    BUFFER_BIT_STENCIL)) == 0);
+
+   _mesa_PushAttrib(GL_COLOR_BUFFER_BIT |
+		    GL_CURRENT_BIT |
+		    GL_DEPTH_BUFFER_BIT |
+		    GL_ENABLE_BIT |
+		    GL_STENCIL_BUFFER_BIT |
+		    GL_TRANSFORM_BIT |
+		    GL_CURRENT_BIT);
+   _mesa_PushClientAttrib(GL_CLIENT_VERTEX_ARRAY_BIT);
+   saved_active_texture = ctx->Texture.CurrentUnit;
+
+   /* Disable existing GL state we don't want to apply to a clear. */
+   _mesa_Disable(GL_ALPHA_TEST);
+   _mesa_Disable(GL_BLEND);
+   _mesa_Disable(GL_CULL_FACE);
+   _mesa_Disable(GL_FOG);
+   _mesa_Disable(GL_POLYGON_SMOOTH);
+   _mesa_Disable(GL_POLYGON_STIPPLE);
+   _mesa_Disable(GL_POLYGON_OFFSET_FILL);
+   _mesa_Disable(GL_LIGHTING);
+   _mesa_Disable(GL_CLIP_PLANE0);
+   _mesa_Disable(GL_CLIP_PLANE1);
+   _mesa_Disable(GL_CLIP_PLANE2);
+   _mesa_Disable(GL_CLIP_PLANE3);
+   _mesa_Disable(GL_CLIP_PLANE4);
+   _mesa_Disable(GL_CLIP_PLANE5);
+   if (ctx->Extensions.ARB_fragment_program && ctx->FragmentProgram.Enabled) {
+      saved_fp_enable = GL_TRUE;
+      _mesa_Disable(GL_FRAGMENT_PROGRAM_ARB);
+   }
+   if (ctx->Extensions.ARB_vertex_program && ctx->VertexProgram.Enabled) {
+      saved_vp_enable = GL_TRUE;
+      _mesa_Disable(GL_VERTEX_PROGRAM_ARB);
+   }
+   if (ctx->Extensions.ARB_shader_objects && ctx->Shader.CurrentProgram) {
+      saved_shader_program = ctx->Shader.CurrentProgram->Name;
+      _mesa_UseProgramObjectARB(0);
+   }
+
+   if (ctx->Texture._EnabledUnits != 0) {
+      int i;
+
+      for (i = 0; i < ctx->Const.MaxTextureUnits; i++) {
+	 _mesa_ActiveTextureARB(GL_TEXTURE0 + i);
+	 _mesa_Disable(GL_TEXTURE_1D);
+	 _mesa_Disable(GL_TEXTURE_2D);
+	 _mesa_Disable(GL_TEXTURE_3D);
+	 if (ctx->Extensions.ARB_texture_cube_map)
+	    _mesa_Disable(GL_TEXTURE_CUBE_MAP_ARB);
+	 if (ctx->Extensions.NV_texture_rectangle)
+	    _mesa_Disable(GL_TEXTURE_RECTANGLE_NV);
+	 if (ctx->Extensions.MESA_texture_array) {
+	    _mesa_Disable(GL_TEXTURE_1D_ARRAY_EXT);
+	    _mesa_Disable(GL_TEXTURE_2D_ARRAY_EXT);
+	 }
+      }
+   }
+
+   intel_meta_set_passthrough_transform(intel);
+
+   for (i = 0; i < 4; i++) {
+      color[i][0] = ctx->Color.ClearColor[0];
+      color[i][1] = ctx->Color.ClearColor[1];
+      color[i][2] = ctx->Color.ClearColor[2];
+      color[i][3] = ctx->Color.ClearColor[3];
+   }
+
+   /* convert clear Z from [0,1] to NDC coord in [-1,1] */
+   dst_z = -1.0 + 2.0 * ctx->Depth.Clear;
+
+   /* Prepare the vertices, which are the same regardless of which buffer we're
+    * drawing to.
+    */
+   vertices[0][0] = fb->_Xmin;
+   vertices[0][1] = fb->_Ymin;
+   vertices[0][2] = dst_z;
+   vertices[1][0] = fb->_Xmax;
+   vertices[1][1] = fb->_Ymin;
+   vertices[1][2] = dst_z;
+   vertices[2][0] = fb->_Xmax;
+   vertices[2][1] = fb->_Ymax;
+   vertices[2][2] = dst_z;
+   vertices[3][0] = fb->_Xmin;
+   vertices[3][1] = fb->_Ymax;
+   vertices[3][2] = dst_z;
+
+   _mesa_ColorPointer(4, GL_FLOAT, 4 * sizeof(GLfloat), &color);
+   _mesa_VertexPointer(3, GL_FLOAT, 3 * sizeof(GLfloat), &vertices);
+   _mesa_Enable(GL_COLOR_ARRAY);
+   _mesa_Enable(GL_VERTEX_ARRAY);
+
+   while (mask != 0) {
+      GLuint this_mask = 0;
+      GLuint color_bit;
+
+      color_bit = _mesa_ffs(mask & TRI_CLEAR_COLOR_BITS);
+      if (color_bit != 0)
+	 this_mask |= (1 << (color_bit - 1));
+
+      /* Clear depth/stencil in the same pass as color. */
+      this_mask |= (mask & (BUFFER_BIT_DEPTH | BUFFER_BIT_STENCIL));
+
+      /* Select the current color buffer and use the color write mask if
+       * we have one, otherwise don't write any color channels.
+       */
+      if (this_mask & BUFFER_BIT_FRONT_LEFT)
+	 _mesa_DrawBuffer(GL_FRONT_LEFT);
+      else if (this_mask & BUFFER_BIT_BACK_LEFT)
+	 _mesa_DrawBuffer(GL_BACK_LEFT);
+      else if (color_bit != 0)
+	 _mesa_DrawBuffer(GL_COLOR_ATTACHMENT0 +
+			  (color_bit - BUFFER_COLOR0 - 1));
+      else
+	 _mesa_ColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
+
+      /* Control writing of the depth clear value to depth. */
+      if (this_mask & BUFFER_BIT_DEPTH) {
+	 _mesa_DepthFunc(GL_ALWAYS);
+	 _mesa_Enable(GL_DEPTH_TEST);
+      } else {
+	 _mesa_Disable(GL_DEPTH_TEST);
+	 _mesa_DepthMask(GL_FALSE);
+      }
+
+      /* Control writing of the stencil clear value to stencil. */
+      if (this_mask & BUFFER_BIT_STENCIL) {
+	 _mesa_Enable(GL_STENCIL_TEST);
+	 _mesa_StencilOp(GL_REPLACE, GL_REPLACE, GL_REPLACE);
+	 _mesa_StencilFuncSeparate(GL_FRONT, GL_ALWAYS, ctx->Stencil.Clear,
+				   ctx->Stencil.WriteMask[0]);
+      } else {
+	 _mesa_Disable(GL_STENCIL_TEST);
+      }
+
+      CALL_DrawArrays(ctx->Exec, (GL_TRIANGLE_FAN, 0, 4));
+
+      mask &= ~this_mask;
+   }
+
+   intel_meta_restore_transform(intel);
+
+   _mesa_ActiveTextureARB(GL_TEXTURE0 + saved_active_texture);
+   if (saved_fp_enable)
+      _mesa_Enable(GL_FRAGMENT_PROGRAM_ARB);
+   if (saved_vp_enable)
+      _mesa_Enable(GL_VERTEX_PROGRAM_ARB);
+
+   if (saved_shader_program)
+      _mesa_UseProgramObjectARB(saved_shader_program);
+
+   _mesa_PopClientAttrib();
+   _mesa_PopAttrib();
+}
+
+static const char *buffer_names[] = {
+   [BUFFER_FRONT_LEFT] = "front",
+   [BUFFER_BACK_LEFT] = "back",
+   [BUFFER_FRONT_RIGHT] = "front right",
+   [BUFFER_BACK_RIGHT] = "back right",
+   [BUFFER_AUX0] = "aux0",
+   [BUFFER_AUX1] = "aux1",
+   [BUFFER_AUX2] = "aux2",
+   [BUFFER_AUX3] = "aux3",
+   [BUFFER_DEPTH] = "depth",
+   [BUFFER_STENCIL] = "stencil",
+   [BUFFER_ACCUM] = "accum",
+   [BUFFER_COLOR0] = "color0",
+   [BUFFER_COLOR1] = "color1",
+   [BUFFER_COLOR2] = "color2",
+   [BUFFER_COLOR3] = "color3",
+   [BUFFER_COLOR4] = "color4",
+   [BUFFER_COLOR5] = "color5",
+   [BUFFER_COLOR6] = "color6",
+   [BUFFER_COLOR7] = "color7",
+};
+
+/**
+ * Called by ctx->Driver.Clear.
+ */
+static void
+intelClear(GLcontext *ctx, GLbitfield mask)
+{
+   struct intel_context *intel = intel_context(ctx);
+   const GLuint colorMask = *((GLuint *) & ctx->Color.ColorMask);
+   GLbitfield tri_mask = 0;
+   GLbitfield blit_mask = 0;
+   GLbitfield swrast_mask = 0;
+   struct gl_framebuffer *fb = ctx->DrawBuffer;
+   GLuint i;
+
+   if (0)
+      fprintf(stderr, "%s\n", __FUNCTION__);
+
+   /* HW color buffers (front, back, aux, generic FBO, etc) */
+   if (colorMask == ~0) {
+      /* clear all R,G,B,A */
+      /* XXX FBO: need to check if colorbuffers are software RBOs! */
+      blit_mask |= (mask & BUFFER_BITS_COLOR);
+   }
+   else {
+      /* glColorMask in effect */
+      tri_mask |= (mask & (BUFFER_BIT_FRONT_LEFT | BUFFER_BIT_BACK_LEFT));
+   }
+
+   /* HW stencil */
+   if (mask & BUFFER_BIT_STENCIL) {
+      const struct intel_region *stencilRegion
+         = intel_get_rb_region(fb, BUFFER_STENCIL);
+      if (stencilRegion) {
+         /* have hw stencil */
+         if (IS_965(intel->intelScreen->deviceID) ||
+	     (ctx->Stencil.WriteMask[0] & 0xff) != 0xff) {
+	    /* We have to use the 3D engine if we're clearing a partial mask
+	     * of the stencil buffer, or if we're on a 965 which has a tiled
+	     * depth/stencil buffer in a layout we can't blit to.
+	     */
+            tri_mask |= BUFFER_BIT_STENCIL;
+         }
+         else {
+            /* clearing all stencil bits, use blitting */
+            blit_mask |= BUFFER_BIT_STENCIL;
+         }
+      }
+   }
+
+   /* HW depth */
+   if (mask & BUFFER_BIT_DEPTH) {
+      /* clear depth with whatever method is used for stencil (see above) */
+      if (IS_965(intel->intelScreen->deviceID) ||
+	  tri_mask & BUFFER_BIT_STENCIL)
+         tri_mask |= BUFFER_BIT_DEPTH;
+      else
+         blit_mask |= BUFFER_BIT_DEPTH;
+   }
+
+   /* If we're doing a tri pass for depth/stencil, include a likely color
+    * buffer with it.
+    */
+   if (mask & (BUFFER_BIT_DEPTH | BUFFER_BIT_STENCIL)) {
+      int color_bit = _mesa_ffs(mask & TRI_CLEAR_COLOR_BITS);
+      if (color_bit != 0) {
+	 tri_mask |= blit_mask & (1 << (color_bit - 1));
+	 blit_mask &= ~(1 << (color_bit - 1));
+      }
+   }
+
+   /* SW fallback clearing */
+   swrast_mask = mask & ~tri_mask & ~blit_mask;
+
+   for (i = 0; i < BUFFER_COUNT; i++) {
+      GLuint bufBit = 1 << i;
+      if ((blit_mask | tri_mask) & bufBit) {
+         if (!fb->Attachment[i].Renderbuffer->ClassID) {
+            blit_mask &= ~bufBit;
+            tri_mask &= ~bufBit;
+            swrast_mask |= bufBit;
+         }
+      }
+   }
+
+   if (blit_mask) {
+      if (INTEL_DEBUG & DEBUG_BLIT) {
+	 DBG("blit clear:");
+	 for (i = 0; i < BUFFER_COUNT; i++) {
+	    if (blit_mask & (1 << i))
+	       DBG(" %s", buffer_names[i]);
+	 }
+	 DBG("\n");
+      }
+      intelClearWithBlit(ctx, blit_mask);
+   }
+
+   if (tri_mask) {
+      if (INTEL_DEBUG & DEBUG_BLIT) {
+	 DBG("tri clear:");
+	 for (i = 0; i < BUFFER_COUNT; i++) {
+	    if (tri_mask & (1 << i))
+	       DBG(" %s", buffer_names[i]);
+	 }
+	 DBG("\n");
+      }
+      intel_clear_tris(ctx, tri_mask);
+   }
+
+   if (swrast_mask) {
+      if (INTEL_DEBUG & DEBUG_BLIT) {
+	 DBG("swrast clear:");
+	 for (i = 0; i < BUFFER_COUNT; i++) {
+	    if (swrast_mask & (1 << i))
+	       DBG(" %s", buffer_names[i]);
+	 }
+	 DBG("\n");
+      }
+      _swrast_Clear(ctx, swrast_mask);
+   }
+}
+
+
+void
+intelInitClearFuncs(struct dd_function_table *functions)
+{
+   functions->Clear = intelClear;
+}
diff --git a/src/mesa/drivers/dri/intel/intel_clear.h b/src/mesa/drivers/dri/intel/intel_clear.h
new file mode 100644
index 0000000..7fd6b31
--- /dev/null
+++ b/src/mesa/drivers/dri/intel/intel_clear.h
@@ -0,0 +1,38 @@
+
+/**************************************************************************
+ * 
+ * Copyright 2006 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ * 
+ **************************************************************************/
+
+#ifndef INTEL_CLEAR_H
+#define INTEL_CLEAR_H
+
+struct dd_function_table;
+
+extern void
+intelInitClearFuncs(struct dd_function_table *functions);
+
+
+#endif /* INTEL_CLEAR_H */
diff --git a/src/mesa/drivers/dri/intel/intel_context.c b/src/mesa/drivers/dri/intel/intel_context.c
index c4a24d7..1aa173d 100644
--- a/src/mesa/drivers/dri/intel/intel_context.c
+++ b/src/mesa/drivers/dri/intel/intel_context.c
@@ -28,8 +28,6 @@
 
 #include "main/glheader.h"
 #include "main/context.h"
-#include "main/matrix.h"
-#include "main/simple_list.h"
 #include "main/extensions.h"
 #include "main/framebuffer.h"
 #include "main/imports.h"
@@ -38,66 +36,40 @@
 #include "swrast/swrast.h"
 #include "swrast_setup/swrast_setup.h"
 #include "tnl/tnl.h"
-
-#include "tnl/t_pipeline.h"
-#include "tnl/t_vertex.h"
-
 #include "drivers/common/driverfuncs.h"
 
-#include "intel_screen.h"
-
 #include "i830_dri.h"
 
 #include "intel_chipset.h"
 #include "intel_buffers.h"
 #include "intel_tex.h"
 #include "intel_batchbuffer.h"
-#include "intel_blit.h"
+#include "intel_clear.h"
+#include "intel_extensions.h"
 #include "intel_pixel.h"
 #include "intel_regions.h"
 #include "intel_buffer_objects.h"
 #include "intel_fbo.h"
 #include "intel_decode.h"
 #include "intel_bufmgr.h"
+#include "intel_screen.h"
+#include "intel_swapbuffers.h"
 
 #include "drirenderbuffer.h"
 #include "vblank.h"
 #include "utils.h"
 #include "xmlpool.h"            /* for symbolic values of enum-type options */
+
+
 #ifndef INTEL_DEBUG
 int INTEL_DEBUG = (0);
 #endif
 
-#define need_GL_ARB_multisample
-#define need_GL_ARB_occlusion_query
-#define need_GL_ARB_point_parameters
-#define need_GL_ARB_shader_objects
-#define need_GL_ARB_texture_compression
-#define need_GL_ARB_vertex_buffer_object
-#define need_GL_ARB_vertex_program
-#define need_GL_ARB_vertex_shader
-#define need_GL_ARB_window_pos
-#define need_GL_EXT_blend_color
-#define need_GL_EXT_blend_equation_separate
-#define need_GL_EXT_blend_func_separate
-#define need_GL_EXT_blend_minmax
-#define need_GL_EXT_cull_vertex
-#define need_GL_EXT_fog_coord
-#define need_GL_EXT_framebuffer_object
-#define need_GL_EXT_multi_draw_arrays
-#define need_GL_EXT_point_parameters
-#define need_GL_EXT_secondary_color
-#define need_GL_ATI_separate_stencil
-#define need_GL_NV_point_sprite
-#define need_GL_NV_vertex_program
-#define need_GL_VERSION_2_0
-#define need_GL_VERSION_2_1
-
-#include "extension_helper.h"
 
 #define DRIVER_DATE                     "20090114"
 #define DRIVER_DATE_GEM                 "GEM " DRIVER_DATE
 
+
 static const GLubyte *
 intelGetString(GLcontext * ctx, GLenum name)
 {
@@ -282,6 +254,9 @@ intel_update_renderbuffers(__DRIcontext *context, __DRIdrawable *drawable)
 	   return;
        }
 
+       if (rb == NULL)
+	  continue;
+
        if (rb->region) {
 	  dri_bo_flink(rb->region->buffer, &name);
 	  if (name == buffers[i].name)
@@ -340,112 +315,6 @@ intel_viewport(GLcontext *ctx, GLint x, GLint y, GLsizei w, GLsizei h)
     ctx->Driver.Viewport = old_viewport;
 }
 
-/**
- * Extension strings exported by the intel driver.
- *
- * Extensions supported by all chips supported by i830_dri, i915_dri, or
- * i965_dri.
- */
-static const struct dri_extension card_extensions[] = {
-   { "GL_ARB_multisample",                GL_ARB_multisample_functions },
-   { "GL_ARB_multitexture",               NULL },
-   { "GL_ARB_point_parameters",           GL_ARB_point_parameters_functions },
-   { "GL_ARB_texture_border_clamp",       NULL },
-   { "GL_ARB_texture_compression",        GL_ARB_texture_compression_functions },
-   { "GL_ARB_texture_cube_map",           NULL },
-   { "GL_ARB_texture_env_add",            NULL },
-   { "GL_ARB_texture_env_combine",        NULL },
-   { "GL_ARB_texture_env_crossbar",       NULL },
-   { "GL_ARB_texture_env_dot3",           NULL },
-   { "GL_ARB_texture_mirrored_repeat",    NULL },
-   { "GL_ARB_texture_rectangle",          NULL },
-   { "GL_ARB_vertex_buffer_object",       GL_ARB_vertex_buffer_object_functions },
-   { "GL_ARB_vertex_program",             GL_ARB_vertex_program_functions },
-   { "GL_ARB_window_pos",                 GL_ARB_window_pos_functions },
-   { "GL_EXT_blend_color",                GL_EXT_blend_color_functions },
-   { "GL_EXT_blend_equation_separate",    GL_EXT_blend_equation_separate_functions },
-   { "GL_EXT_blend_func_separate",        GL_EXT_blend_func_separate_functions },
-   { "GL_EXT_blend_minmax",               GL_EXT_blend_minmax_functions },
-   { "GL_EXT_blend_logic_op",             NULL },
-   { "GL_EXT_blend_subtract",             NULL },
-   { "GL_EXT_cull_vertex",                GL_EXT_cull_vertex_functions },
-   { "GL_EXT_fog_coord",                  GL_EXT_fog_coord_functions },
-   { "GL_EXT_multi_draw_arrays",          GL_EXT_multi_draw_arrays_functions },
-   { "GL_EXT_packed_depth_stencil",       NULL },
-   { "GL_EXT_secondary_color",            GL_EXT_secondary_color_functions },
-   { "GL_EXT_stencil_wrap",               NULL },
-   { "GL_EXT_texture_edge_clamp",         NULL },
-   { "GL_EXT_texture_env_combine",        NULL },
-   { "GL_EXT_texture_env_dot3",           NULL },
-   { "GL_EXT_texture_filter_anisotropic", NULL },
-   { "GL_EXT_texture_lod_bias",           NULL },
-   { "GL_3DFX_texture_compression_FXT1",  NULL },
-   { "GL_APPLE_client_storage",           NULL },
-   { "GL_MESA_pack_invert",               NULL },
-   { "GL_MESA_ycbcr_texture",             NULL },
-   { "GL_NV_blend_square",                NULL },
-   { "GL_NV_point_sprite",                GL_NV_point_sprite_functions },
-   { "GL_NV_vertex_program",              GL_NV_vertex_program_functions },
-   { "GL_NV_vertex_program1_1",           NULL },
-   { "GL_SGIS_generate_mipmap",           NULL },
-   { NULL, NULL }
-};
-
-static const struct dri_extension brw_extensions[] = {
-   { "GL_ARB_depth_texture",              NULL },
-   { "GL_ARB_draw_buffers",               NULL },
-   { "GL_ARB_fragment_program",           NULL },
-   { "GL_ARB_fragment_program_shadow",    NULL },
-   { "GL_ARB_fragment_shader",            NULL },
-   { "GL_ARB_occlusion_query",            GL_ARB_occlusion_query_functions },
-   { "GL_ARB_point_sprite", 		  NULL },
-   { "GL_ARB_shader_objects",             GL_ARB_shader_objects_functions },
-   { "GL_ARB_shading_language_100",       GL_VERSION_2_0_functions },
-#if 0
-   /* Support for GLSL 1.20 is currently broken in core Mesa.
-    */
-   { "GL_ARB_shading_language_120",       GL_VERSION_2_1_functions },
-#endif
-   { "GL_ARB_shadow",                     NULL },
-   { "GL_ARB_texture_non_power_of_two",   NULL },
-   { "GL_ARB_vertex_shader",              GL_ARB_vertex_shader_functions },
-   { "GL_EXT_shadow_funcs",               NULL },
-   { "GL_EXT_texture_sRGB",		  NULL },
-   { "GL_ATI_separate_stencil",           GL_ATI_separate_stencil_functions },
-   { "GL_ATI_texture_env_combine3",       NULL },
-   { NULL,                                NULL }
-};
-
-static const struct dri_extension arb_oq_extensions[] = {
-   { NULL, NULL }
-};
-
-static const struct dri_extension ttm_extensions[] = {
-   { "GL_ARB_pixel_buffer_object",        NULL },
-   { "GL_EXT_framebuffer_object",         GL_EXT_framebuffer_object_functions },
-   { NULL, NULL }
-};
-
-/**
- * Initializes potential list of extensions if ctx == NULL, or actually enables
- * extensions for a context.
- */
-void intelInitExtensions(GLcontext *ctx, GLboolean enable_imaging)
-{
-   struct intel_context *intel = ctx?intel_context(ctx):NULL;
-
-   /* Disable imaging extension until convolution is working in teximage paths.
-    */
-   enable_imaging = GL_FALSE;
-
-   driInitExtensions(ctx, card_extensions, enable_imaging);
-
-   if (intel == NULL || intel->ttm)
-      driInitExtensions(ctx, ttm_extensions, GL_FALSE);
-
-   if (intel == NULL || IS_965(intel->intelScreen->deviceID))
-      driInitExtensions(ctx, brw_extensions, GL_FALSE);
-}
 
 static const struct dri_debug_control debug_control[] = {
    { "tex",   DEBUG_TEXTURE},
@@ -496,9 +365,8 @@ intelInvalidateState(GLcontext * ctx, GLuint new_state)
       intel->vtbl.invalidate_state( intel, new_state );
 }
 
-
-void
-intelFlush(GLcontext * ctx)
+static void
+intel_flush(GLcontext *ctx, GLboolean needs_mi_flush)
 {
    struct intel_context *intel = intel_context(ctx);
 
@@ -512,13 +380,26 @@ intelFlush(GLcontext * ctx)
     * lands onscreen in a timely manner, even if the X Server doesn't trigger
     * a flush for us.
     */
-   intel_batchbuffer_emit_mi_flush(intel->batch);
+   if (needs_mi_flush)
+      intel_batchbuffer_emit_mi_flush(intel->batch);
 
    if (intel->batch->map != intel->batch->ptr)
       intel_batchbuffer_flush(intel->batch);
 }
 
 void
+intelFlush(GLcontext * ctx)
+{
+   intel_flush(ctx, GL_FALSE);
+}
+
+static void
+intel_glFlush(GLcontext *ctx)
+{
+   intel_flush(ctx, GL_TRUE);
+}
+
+void
 intelFinish(GLcontext * ctx)
 {
    struct gl_framebuffer *fb = ctx->DrawBuffer;
@@ -544,7 +425,7 @@ intelInitDriverFunctions(struct dd_function_table *functions)
 {
    _mesa_init_driver_functions(functions);
 
-   functions->Flush = intelFlush;
+   functions->Flush = intel_glFlush;
    functions->Finish = intelFinish;
    functions->GetString = intelGetString;
    functions->UpdateState = intelInvalidateState;
@@ -556,6 +437,7 @@ intelInitDriverFunctions(struct dd_function_table *functions)
 
    intelInitTextureFuncs(functions);
    intelInitStateFuncs(functions);
+   intelInitClearFuncs(functions);
    intelInitBufferFuncs(functions);
    intelInitPixelFuncs(functions);
 }
@@ -691,8 +573,6 @@ intelInitContext(struct intel_context *intel,
 
    intel->do_usleeps = (fthrottle_mode == DRI_CONF_FTHROTTLE_USLEEPS);
 
-   _math_matrix_ctr(&intel->ViewportMatrix);
-
    if (IS_965(intelScreen->deviceID) && !intel->intelScreen->irq_active) {
       _mesa_printf("IRQs not active.  Exiting\n");
       exit(1);
@@ -858,6 +738,11 @@ intelMakeCurrent(__DRIcontextPrivate * driContextPriv,
 		  ? driGetDefaultVBlankFlags(&intel->optionCache)
 		 : VBLANK_FLAG_NO_IRQ;
 
+	       /* Prevent error printf if one crtc is disabled, this will
+		* be properly calculated in intelWindowMoved() next.
+		*/
+		driDrawPriv->vblFlags = intelFixupVblank(intel, driDrawPriv);
+
 	       (*psp->systemTime->getUST) (&intel_fb->swap_ust);
 	       driDrawableInitVBlank(driDrawPriv);
 	       intel_fb->vbl_waited = driDrawPriv->vblSeq;
diff --git a/src/mesa/drivers/dri/intel/intel_context.h b/src/mesa/drivers/dri/intel/intel_context.h
index 048286c..18dc43c 100644
--- a/src/mesa/drivers/dri/intel/intel_context.h
+++ b/src/mesa/drivers/dri/intel/intel_context.h
@@ -168,6 +168,7 @@ struct intel_context
 
       GLint saved_vp_x, saved_vp_y;
       GLsizei saved_vp_width, saved_vp_height;
+      GLenum saved_matrix_mode;
    } meta;
 
    GLint refcount;
@@ -209,7 +210,6 @@ struct intel_context
    char *prevLockFile;
    int prevLockLine;
 
-   GLubyte clear_chan[4];
    GLuint ClearColor565;
    GLuint ClearColor8888;
 
@@ -437,7 +437,6 @@ extern void intelFinish(GLcontext * ctx);
 extern void intelFlush(GLcontext * ctx);
 
 extern void intelInitDriverFunctions(struct dd_function_table *functions);
-extern void intelInitExtensions(GLcontext *ctx, GLboolean enable_imaging);
 
 
 /* ================================================================
diff --git a/src/mesa/drivers/dri/intel/intel_decode.c b/src/mesa/drivers/dri/intel/intel_decode.c
index 5f90ca2..136221c 100644
--- a/src/mesa/drivers/dri/intel/intel_decode.c
+++ b/src/mesa/drivers/dri/intel/intel_decode.c
@@ -87,27 +87,28 @@ decode_mi(uint32_t *data, int count, uint32_t hw_offset, int *failures)
 
     struct {
 	uint32_t opcode;
+	int len_mask;
 	int min_len;
 	int max_len;
 	char *name;
     } opcodes_mi[] = {
-	{ 0x08, 1, 1, "MI_ARB_ON_OFF" },
-	{ 0x0a, 1, 1, "MI_BATCH_BUFFER_END" },
-	{ 0x31, 2, 2, "MI_BATCH_BUFFER_START" },
-	{ 0x14, 3, 3, "MI_DISPLAY_BUFFER_INFO" },
-	{ 0x04, 1, 1, "MI_FLUSH" },
-	{ 0x22, 3, 3, "MI_LOAD_REGISTER_IMM" },
-	{ 0x13, 2, 2, "MI_LOAD_SCAN_LINES_EXCL" },
-	{ 0x12, 2, 2, "MI_LOAD_SCAN_LINES_INCL" },
-	{ 0x00, 1, 1, "MI_NOOP" },
-	{ 0x11, 2, 2, "MI_OVERLAY_FLIP" },
-	{ 0x07, 1, 1, "MI_REPORT_HEAD" },
-	{ 0x18, 2, 2, "MI_SET_CONTEXT" },
-	{ 0x20, 3, 4, "MI_STORE_DATA_IMM" },
-	{ 0x21, 3, 4, "MI_STORE_DATA_INDEX" },
-	{ 0x24, 3, 3, "MI_STORE_REGISTER_MEM" },
-	{ 0x02, 1, 1, "MI_USER_INTERRUPT" },
-	{ 0x03, 1, 1, "MI_WAIT_FOR_EVENT" },
+	{ 0x08, 0, 1, 1, "MI_ARB_ON_OFF" },
+	{ 0x0a, 0, 1, 1, "MI_BATCH_BUFFER_END" },
+	{ 0x31, 0x3f, 2, 2, "MI_BATCH_BUFFER_START" },
+	{ 0x14, 0x3f, 3, 3, "MI_DISPLAY_BUFFER_INFO" },
+	{ 0x04, 0, 1, 1, "MI_FLUSH" },
+	{ 0x22, 0, 3, 3, "MI_LOAD_REGISTER_IMM" },
+	{ 0x13, 0x3f, 2, 2, "MI_LOAD_SCAN_LINES_EXCL" },
+	{ 0x12, 0x3f, 2, 2, "MI_LOAD_SCAN_LINES_INCL" },
+	{ 0x00, 0, 1, 1, "MI_NOOP" },
+	{ 0x11, 0x3f, 2, 2, "MI_OVERLAY_FLIP" },
+	{ 0x07, 0, 1, 1, "MI_REPORT_HEAD" },
+	{ 0x18, 0x3f, 2, 2, "MI_SET_CONTEXT" },
+	{ 0x20, 0x3f, 3, 4, "MI_STORE_DATA_IMM" },
+	{ 0x21, 0x3f, 3, 4, "MI_STORE_DATA_INDEX" },
+	{ 0x24, 0x3f, 3, 3, "MI_STORE_REGISTER_MEM" },
+	{ 0x02, 0, 1, 1, "MI_USER_INTERRUPT" },
+	{ 0x03, 0, 1, 1, "MI_WAIT_FOR_EVENT" },
     };
 
 
@@ -118,12 +119,14 @@ decode_mi(uint32_t *data, int count, uint32_t hw_offset, int *failures)
 
 	    instr_out(data, hw_offset, 0, "%s\n", opcodes_mi[opcode].name);
 	    if (opcodes_mi[opcode].max_len > 1) {
-		len = (data[0] & 0x000000ff) + 2;
+		len = (data[0] & opcodes_mi[opcode].len_mask) + 2;
 		if (len < opcodes_mi[opcode].min_len ||
 		    len > opcodes_mi[opcode].max_len)
 		{
-		    fprintf(out, "Bad length in %s\n",
-			    opcodes_mi[opcode].name);
+		    fprintf(out, "Bad length (%d) in %s, [%d, %d]\n",
+			    len, opcodes_mi[opcode].name,
+			    opcodes_mi[opcode].min_len,
+			    opcodes_mi[opcode].max_len);
 		}
 	    }
 
@@ -932,7 +935,7 @@ decode_3d_1d(uint32_t *data, int count, uint32_t hw_offset, int *failures, int i
 	instr_out(data, hw_offset, 0, "3DSTATE_PIXEL_SHADER_CONSTANTS\n");
 	len = (data[0] & 0x000000ff) + 2;
 
-	i = 1;
+	i = 2;
 	for (c = 0; c <= 31; c++) {
 	    if (data[1] & (1 << c)) {
 		if (i + 4 >= count)
@@ -952,7 +955,7 @@ decode_3d_1d(uint32_t *data, int count, uint32_t hw_offset, int *failures, int i
 	    }
 	}
 	if (len != i) {
-	    fprintf(out, "Bad count in 3DSTATE_MAP_STATE\n");
+	    fprintf(out, "Bad count in 3DSTATE_PIXEL_SHADER_CONSTANTS\n");
 	    (*failures)++;
 	}
 	return len;
diff --git a/src/mesa/drivers/dri/intel/intel_depthstencil.c b/src/mesa/drivers/dri/intel/intel_depthstencil.c
deleted file mode 100644
index 354b3bf..0000000
--- a/src/mesa/drivers/dri/intel/intel_depthstencil.c
+++ /dev/null
@@ -1,261 +0,0 @@
-/**************************************************************************
- * 
- * Copyright 2006 Tungsten Graphics, Inc., Cedar Park, Texas.
- * All Rights Reserved.
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- * 
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- * 
- **************************************************************************/
-
-#include "main/glheader.h"
-#include "main/imports.h"
-#include "main/context.h"
-#include "main/depthstencil.h"
-#include "main/fbobject.h"
-#include "main/framebuffer.h"
-#include "main/hash.h"
-#include "main/mtypes.h"
-#include "main/renderbuffer.h"
-
-#include "intel_context.h"
-#include "intel_fbo.h"
-#include "intel_depthstencil.h"
-#include "intel_regions.h"
-#include "intel_span.h"
-
-/**
- * The GL_EXT_framebuffer_object allows the user to create their own
- * framebuffer objects consisting of color renderbuffers (0 or more),
- * depth renderbuffers (0 or 1) and stencil renderbuffers (0 or 1).
- *
- * The spec considers depth and stencil renderbuffers to be totally independent
- * buffers.  In reality, most graphics hardware today uses a combined
- * depth+stencil buffer (one 32-bit pixel = 24 bits of Z + 8 bits of stencil).
- *
- * This causes difficulty because the user may create some number of depth
- * renderbuffers and some number of stencil renderbuffers and bind them
- * together in framebuffers in any combination.
- *
- * This code manages all that.
- *
- * 1. Depth renderbuffers are always allocated in hardware as 32bpp
- *    GL_DEPTH24_STENCIL8 buffers.
- *
- * 2. Stencil renderbuffers are initially allocated in software as 8bpp
- *    GL_STENCIL_INDEX8 buffers.
- *
- * 3. Depth and Stencil renderbuffers use the PairedStencil and PairedDepth
- *    fields (respectively) to indicate if the buffer's currently paired
- *    with another stencil or depth buffer (respectively).
- *
- * 4. When a depth and stencil buffer are initially both attached to the
- *    current framebuffer, we merge the stencil buffer values into the
- *    depth buffer (really a depth+stencil buffer).  The then hardware uses
- *    the combined buffer.
- *
- * 5. Whenever a depth or stencil buffer is reallocated (with
- *    glRenderbufferStorage) we undo the pairing and copy the stencil values
- *    from the combined depth/stencil buffer back to the stencil-only buffer.
- *
- * 6. We also undo the pairing when we find a change in buffer bindings.
- *
- * 7. If a framebuffer is only using a depth renderbuffer (no stencil), we
- *    just use the combined depth/stencil buffer and ignore the stencil values.
- *
- * 8. If a framebuffer is only using a stencil renderbuffer (no depth) we have
- *    to promote the 8bpp software stencil buffer to a 32bpp hardware
- *    depth+stencil buffer.
- *
- */
-
-/**
- * Undo the pairing/interleaving between depth and stencil buffers.
- * irb should be a depth/stencil or stencil renderbuffer.
- */
-void
-intel_unpair_depth_stencil(GLcontext *ctx, struct intel_renderbuffer *irb)
-{
-   struct intel_context *intel = intel_context(ctx);
-   struct gl_renderbuffer *rb = &irb->Base;
-
-   if (irb->PairedStencil) {
-      /* irb is a depth/stencil buffer */
-      struct gl_renderbuffer *stencilRb;
-      struct intel_renderbuffer *stencilIrb;
-
-      ASSERT(rb->_ActualFormat == GL_DEPTH24_STENCIL8_EXT);
-
-      stencilRb = _mesa_lookup_renderbuffer(ctx, irb->PairedStencil);
-      stencilIrb = intel_renderbuffer(stencilRb);
-      if (stencilIrb) {
-         /* need to extract stencil values from the depth buffer */
-	 ASSERT(stencilIrb->PairedDepth == rb->Name);
-	 intel_renderbuffer_map(intel, rb);
-	 intel_renderbuffer_map(intel, stencilRb);
-#if 0
-         /* disable for now */
-	 _mesa_extract_stencil(ctx, rb, stencilRb);
-#endif
-	 intel_renderbuffer_unmap(intel, stencilRb);
-	 intel_renderbuffer_unmap(intel, rb);
-         stencilIrb->PairedDepth = 0;
-      }
-      irb->PairedStencil = 0;
-   }
-   else if (irb->PairedDepth) {
-      /* irb is a stencil buffer */
-      struct gl_renderbuffer *depthRb;
-      struct intel_renderbuffer *depthIrb;
-
-      ASSERT(rb->_ActualFormat == GL_STENCIL_INDEX8_EXT ||
-             rb->_ActualFormat == GL_DEPTH24_STENCIL8_EXT);
-
-      depthRb = _mesa_lookup_renderbuffer(ctx, irb->PairedDepth);
-      depthIrb = intel_renderbuffer(depthRb);
-      if (depthIrb) {
-         /* need to extract stencil values from the depth buffer */
-	 ASSERT(depthIrb->PairedStencil == rb->Name);
-	 intel_renderbuffer_map(intel, rb);
-	 intel_renderbuffer_map(intel, depthRb);
-#if 0
-         /* disable for now */
-	 _mesa_extract_stencil(ctx, depthRb, rb);
-#endif
-	 intel_renderbuffer_unmap(intel, depthRb);
-	 intel_renderbuffer_unmap(intel, rb);
-         depthIrb->PairedStencil = 0;
-      }
-      irb->PairedDepth = 0;
-   }
-   else {
-      _mesa_problem(ctx, "Problem in undo_depth_stencil_pairing");
-   }
-
-   ASSERT(irb->PairedStencil == 0);
-   ASSERT(irb->PairedDepth == 0);
-}
-
-
-/**
- * Examine the depth and stencil renderbuffers which are attached to the
- * framebuffer.  If both depth and stencil are attached, make sure that the
- * renderbuffers are 'paired' (combined).  If only depth or only stencil is
- * attached, undo any previous pairing.
- *
- * Must be called if NewState & _NEW_BUFFER (when renderbuffer attachments
- * change, for example).
- */
-void
-intel_validate_paired_depth_stencil(GLcontext * ctx,
-                                    struct gl_framebuffer *fb)
-{
-   struct intel_context *intel = intel_context(ctx);
-   struct intel_renderbuffer *depthRb, *stencilRb;
-
-   depthRb = intel_get_renderbuffer(fb, BUFFER_DEPTH);
-   stencilRb = intel_get_renderbuffer(fb, BUFFER_STENCIL);
-
-   if (depthRb && stencilRb) {
-      if (depthRb == stencilRb) {
-         /* Using a user-created combined depth/stencil buffer.
-          * Nothing to do.
-          */
-         ASSERT(depthRb->Base._BaseFormat == GL_DEPTH_STENCIL_EXT);
-         ASSERT(depthRb->Base._ActualFormat == GL_DEPTH24_STENCIL8_EXT);
-      }
-      else {
-         /* Separate depth/stencil buffers, need to interleave now */
-         ASSERT(depthRb->Base._BaseFormat == GL_DEPTH_COMPONENT ||
-                depthRb->Base._BaseFormat == GL_DEPTH_STENCIL);
-         ASSERT(stencilRb->Base._BaseFormat == GL_STENCIL_INDEX ||
-                stencilRb->Base._BaseFormat == GL_DEPTH_STENCIL);
-
-         /* may need to interleave depth/stencil now */
-         if (depthRb->PairedStencil == stencilRb->Base.Name) {
-            /* OK, the depth and stencil buffers are already interleaved */
-            ASSERT(stencilRb->PairedDepth == depthRb->Base.Name);
-         }
-         else {
-            /* need to setup new pairing/interleaving */
-            if (depthRb->PairedStencil) {
-               intel_unpair_depth_stencil(ctx, depthRb);
-            }
-            if (stencilRb->PairedDepth) {
-               intel_unpair_depth_stencil(ctx, stencilRb);
-            }
-
-            ASSERT(depthRb->Base._ActualFormat == GL_DEPTH24_STENCIL8_EXT);
-            ASSERT(stencilRb->Base._ActualFormat == GL_STENCIL_INDEX8_EXT ||
-                   stencilRb->Base._ActualFormat == GL_DEPTH24_STENCIL8_EXT);
-
-            /* establish new pairing: interleave stencil into depth buffer */
-	    intel_renderbuffer_map(intel, &depthRb->Base);
-	    intel_renderbuffer_map(intel, &stencilRb->Base);
-            _mesa_insert_stencil(ctx, &depthRb->Base, &stencilRb->Base);
-	    intel_renderbuffer_unmap(intel, &stencilRb->Base);
-	    intel_renderbuffer_unmap(intel, &depthRb->Base);
-            depthRb->PairedStencil = stencilRb->Base.Name;
-            stencilRb->PairedDepth = depthRb->Base.Name;
-         }
-
-      }
-   }
-   else if (depthRb) {
-      /* Depth buffer but no stencil buffer.
-       * We'll use a GL_DEPTH24_STENCIL8 buffer and ignore the stencil bits.
-       */
-      /* can't assert this until storage is allocated:
-         ASSERT(depthRb->Base._ActualFormat == GL_DEPTH24_STENCIL8_EXT);
-       */
-      /* intel_undo any previous pairing */
-      if (depthRb->PairedStencil) {
-         intel_unpair_depth_stencil(ctx, depthRb);
-      }
-   }
-   else if (stencilRb) {
-      /* Stencil buffer but no depth buffer.
-       * Since h/w doesn't typically support just 8bpp stencil w/out Z,
-       * we'll use a GL_DEPTH24_STENCIL8 buffer and ignore the depth bits.
-       */
-      /* undo any previous pairing */
-      if (stencilRb->PairedDepth) {
-         intel_unpair_depth_stencil(ctx, stencilRb);
-      }
-      if (stencilRb->Base._ActualFormat == GL_STENCIL_INDEX8_EXT) {
-         /* promote buffer to GL_DEPTH24_STENCIL8 for hw rendering */
-         _mesa_promote_stencil(ctx, &stencilRb->Base);
-         ASSERT(stencilRb->Base._ActualFormat == GL_DEPTH24_STENCIL8_EXT);
-      }
-   }
-
-   /* Finally, update the fb->_DepthBuffer and fb->_StencilBuffer fields */
-   _mesa_update_depth_buffer(ctx, fb, BUFFER_DEPTH);
-   if (depthRb && depthRb->PairedStencil)
-      _mesa_update_stencil_buffer(ctx, fb, BUFFER_DEPTH);
-   else
-      _mesa_update_stencil_buffer(ctx, fb, BUFFER_STENCIL);
-
-
-   /* The hardware should use fb->Attachment[BUFFER_DEPTH].Renderbuffer
-    * first, if present, then fb->Attachment[BUFFER_STENCIL].Renderbuffer
-    * if present.
-    */
-}
diff --git a/src/mesa/drivers/dri/intel/intel_depthstencil.h b/src/mesa/drivers/dri/intel/intel_depthstencil.h
deleted file mode 100644
index 740eb0d..0000000
--- a/src/mesa/drivers/dri/intel/intel_depthstencil.h
+++ /dev/null
@@ -1,15 +0,0 @@
-
-#ifndef INTEL_DEPTH_STENCIL_H
-#define INTEL_DEPTH_STENCIL_H
-
-#include "intel_fbo.h"
-
-extern void
-intel_unpair_depth_stencil(GLcontext * ctx, struct intel_renderbuffer *irb);
-
-extern void
-intel_validate_paired_depth_stencil(GLcontext * ctx,
-                                    struct gl_framebuffer *fb);
-
-
-#endif /* INTEL_DEPTH_STENCIL_H */
diff --git a/src/mesa/drivers/dri/intel/intel_depthtmp.h b/src/mesa/drivers/dri/intel/intel_depthtmp.h
new file mode 100644
index 0000000..16d7708
--- /dev/null
+++ b/src/mesa/drivers/dri/intel/intel_depthtmp.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright © 2009 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Eric Anholt <eric@anholt.net>
+ *
+ */
+
+/**
+ * Wrapper around the depthtmp.h macrofest to generate spans code for
+ * all the tiling styles.
+ */
+
+#define VALUE_TYPE INTEL_VALUE_TYPE
+#define WRITE_DEPTH(_x, _y, d) INTEL_WRITE_DEPTH(NO_TILE(_x, _y), d)
+#define READ_DEPTH(d, _x, _y) d = INTEL_READ_DEPTH(NO_TILE(_x, _y))
+#define TAG(x) INTEL_TAG(intel##x)
+#include "depthtmp.h"
+
+#define VALUE_TYPE INTEL_VALUE_TYPE
+#define WRITE_DEPTH(_x, _y, d) INTEL_WRITE_DEPTH(X_TILE(_x, _y), d)
+#define READ_DEPTH(d, _x, _y) d = INTEL_READ_DEPTH(X_TILE(_x, _y))
+#define TAG(x) INTEL_TAG(intel_XTile_##x)
+#include "depthtmp.h"
+
+#define VALUE_TYPE INTEL_VALUE_TYPE
+#define WRITE_DEPTH(_x, _y, d) INTEL_WRITE_DEPTH(Y_TILE(_x, _y), d)
+#define READ_DEPTH(d, _x, _y) d = INTEL_READ_DEPTH(Y_TILE(_x, _y))
+#define TAG(x) INTEL_TAG(intel_YTile_##x)
+#include "depthtmp.h"
+
+#undef INTEL_VALUE_TYPE
+#undef INTEL_WRITE_DEPTH
+#undef INTEL_READ_DEPTH
+#undef INTEL_TAG
diff --git a/src/mesa/drivers/dri/intel/intel_extensions.c b/src/mesa/drivers/dri/intel/intel_extensions.c
new file mode 100644
index 0000000..9058e48
--- /dev/null
+++ b/src/mesa/drivers/dri/intel/intel_extensions.c
@@ -0,0 +1,185 @@
+/**************************************************************************
+ * 
+ * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ * 
+ **************************************************************************/
+
+#include "intel_chipset.h"
+#include "intel_context.h"
+#include "intel_extensions.h"
+
+
+#define need_GL_ARB_framebuffer_object
+#define need_GL_ARB_occlusion_query
+#define need_GL_ARB_point_parameters
+#define need_GL_ARB_shader_objects
+#define need_GL_ARB_vertex_program
+#define need_GL_ARB_vertex_shader
+#define need_GL_ARB_window_pos
+#define need_GL_EXT_blend_color
+#define need_GL_EXT_blend_equation_separate
+#define need_GL_EXT_blend_func_separate
+#define need_GL_EXT_blend_minmax
+#define need_GL_EXT_cull_vertex
+#define need_GL_EXT_fog_coord
+#define need_GL_EXT_framebuffer_object
+#define need_GL_EXT_framebuffer_blit
+#define need_GL_EXT_point_parameters
+#define need_GL_EXT_secondary_color
+#define need_GL_EXT_stencil_two_side
+#define need_GL_ATI_separate_stencil
+#define need_GL_NV_point_sprite
+#define need_GL_NV_vertex_program
+#define need_GL_VERSION_2_0
+#define need_GL_VERSION_2_1
+
+#include "extension_helper.h"
+
+
+/**
+ * Extension strings exported by the intel driver.
+ *
+ * Extensions supported by all chips supported by i830_dri, i915_dri, or
+ * i965_dri.
+ */
+static const struct dri_extension card_extensions[] = {
+   { "GL_ARB_multitexture",               NULL },
+   { "GL_ARB_point_parameters",           GL_ARB_point_parameters_functions },
+   { "GL_ARB_texture_border_clamp",       NULL },
+   { "GL_ARB_texture_cube_map",           NULL },
+   { "GL_ARB_texture_env_add",            NULL },
+   { "GL_ARB_texture_env_combine",        NULL },
+   { "GL_ARB_texture_env_crossbar",       NULL },
+   { "GL_ARB_texture_env_dot3",           NULL },
+   { "GL_ARB_texture_mirrored_repeat",    NULL },
+   { "GL_ARB_texture_rectangle",          NULL },
+   { "GL_ARB_vertex_program",             GL_ARB_vertex_program_functions },
+   { "GL_ARB_window_pos",                 GL_ARB_window_pos_functions },
+   { "GL_EXT_blend_color",                GL_EXT_blend_color_functions },
+   { "GL_EXT_blend_equation_separate",    GL_EXT_blend_equation_separate_functions },
+   { "GL_EXT_blend_func_separate",        GL_EXT_blend_func_separate_functions },
+   { "GL_EXT_blend_minmax",               GL_EXT_blend_minmax_functions },
+   { "GL_EXT_blend_logic_op",             NULL },
+   { "GL_EXT_blend_subtract",             NULL },
+   { "GL_EXT_cull_vertex",                GL_EXT_cull_vertex_functions },
+   { "GL_EXT_fog_coord",                  GL_EXT_fog_coord_functions },
+   { "GL_EXT_packed_depth_stencil",       NULL },
+   { "GL_EXT_secondary_color",            GL_EXT_secondary_color_functions },
+   { "GL_EXT_stencil_wrap",               NULL },
+   { "GL_EXT_texture_edge_clamp",         NULL },
+   { "GL_EXT_texture_env_combine",        NULL },
+   { "GL_EXT_texture_env_dot3",           NULL },
+   { "GL_EXT_texture_filter_anisotropic", NULL },
+   { "GL_EXT_texture_lod_bias",           NULL },
+   { "GL_3DFX_texture_compression_FXT1",  NULL },
+   { "GL_APPLE_client_storage",           NULL },
+   { "GL_MESA_pack_invert",               NULL },
+   { "GL_MESA_ycbcr_texture",             NULL },
+   { "GL_NV_blend_square",                NULL },
+   { "GL_NV_point_sprite",                GL_NV_point_sprite_functions },
+   { "GL_NV_vertex_program",              GL_NV_vertex_program_functions },
+   { "GL_NV_vertex_program1_1",           NULL },
+   { "GL_SGIS_generate_mipmap",           NULL },
+   { NULL, NULL }
+};
+
+
+/** i915 / i945-only extensions */
+static const struct dri_extension i915_extensions[] = {
+   { "GL_ARB_depth_texture",              NULL },
+   { "GL_ARB_fragment_program",           NULL },
+   { "GL_ARB_shadow",                     NULL },
+   { "GL_ARB_texture_non_power_of_two",   NULL },
+   { "GL_ATI_texture_env_combine3",       NULL },
+   { "GL_EXT_shadow_funcs",               NULL },
+   { "GL_NV_texture_env_combine4",        NULL },
+   { NULL,                                NULL }
+};
+
+
+/** i965-only extensions */
+static const struct dri_extension brw_extensions[] = {
+   { "GL_ARB_depth_texture",              NULL },
+   { "GL_ARB_fragment_program",           NULL },
+   { "GL_ARB_fragment_program_shadow",    NULL },
+   { "GL_ARB_fragment_shader",            NULL },
+   { "GL_ARB_framebuffer_object",         GL_ARB_framebuffer_object_functions},
+   { "GL_ARB_occlusion_query",            GL_ARB_occlusion_query_functions },
+   { "GL_ARB_point_sprite", 		  NULL },
+   { "GL_ARB_shader_objects",             GL_ARB_shader_objects_functions },
+   { "GL_ARB_shading_language_100",       GL_VERSION_2_0_functions },
+   { "GL_ARB_shading_language_120",       GL_VERSION_2_1_functions },
+   { "GL_ARB_shadow",                     NULL },
+   { "GL_ARB_texture_non_power_of_two",   NULL },
+   { "GL_ARB_vertex_shader",              GL_ARB_vertex_shader_functions },
+   { "GL_EXT_shadow_funcs",               NULL },
+   { "GL_EXT_stencil_two_side",           GL_EXT_stencil_two_side_functions },
+   { "GL_EXT_texture_sRGB",		  NULL },
+   { "GL_EXT_texture_swizzle",		  NULL },
+   { "GL_EXT_vertex_array_bgra",	  NULL },
+   { "GL_ATI_separate_stencil",           GL_ATI_separate_stencil_functions },
+   { "GL_ATI_texture_env_combine3",       NULL },
+   { "GL_NV_texture_env_combine4",        NULL },
+   { NULL,                                NULL }
+};
+
+
+static const struct dri_extension arb_oq_extensions[] = {
+   { NULL, NULL }
+};
+
+
+static const struct dri_extension ttm_extensions[] = {
+   { "GL_ARB_pixel_buffer_object",      NULL },
+   { "GL_EXT_framebuffer_blit",         GL_EXT_framebuffer_blit_functions },
+   { "GL_EXT_framebuffer_object",       GL_EXT_framebuffer_object_functions },
+   { NULL, NULL }
+};
+
+
+/**
+ * Initializes potential list of extensions if ctx == NULL, or actually enables
+ * extensions for a context.
+ */
+void
+intelInitExtensions(GLcontext *ctx, GLboolean enable_imaging)
+{
+   struct intel_context *intel = ctx?intel_context(ctx):NULL;
+
+   /* Disable imaging extension until convolution is working in teximage paths.
+    */
+   enable_imaging = GL_FALSE;
+
+   driInitExtensions(ctx, card_extensions, enable_imaging);
+
+   if (intel == NULL || intel->ttm)
+      driInitExtensions(ctx, ttm_extensions, GL_FALSE);
+
+   if (intel == NULL || IS_965(intel->intelScreen->deviceID))
+      driInitExtensions(ctx, brw_extensions, GL_FALSE);
+
+   if (intel == NULL || IS_915(intel->intelScreen->deviceID)
+       || IS_945(intel->intelScreen->deviceID))
+      driInitExtensions(ctx, i915_extensions, GL_FALSE);
+}
diff --git a/src/mesa/drivers/dri/intel/intel_extensions.h b/src/mesa/drivers/dri/intel/intel_extensions.h
new file mode 100644
index 0000000..97147ec
--- /dev/null
+++ b/src/mesa/drivers/dri/intel/intel_extensions.h
@@ -0,0 +1,36 @@
+/**************************************************************************
+ * 
+ * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ * 
+ **************************************************************************/
+
+#ifndef INTEL_EXTENSIONS_H
+#define INTEL_EXTENSIONS_H
+
+
+extern void
+intelInitExtensions(GLcontext *ctx, GLboolean enable_imaging);
+
+
+#endif
diff --git a/src/mesa/drivers/dri/intel/intel_fbo.c b/src/mesa/drivers/dri/intel/intel_fbo.c
index 7cf1261..787c290 100644
--- a/src/mesa/drivers/dri/intel/intel_fbo.c
+++ b/src/mesa/drivers/dri/intel/intel_fbo.c
@@ -27,6 +27,7 @@
 
 
 #include "main/imports.h"
+#include "main/macros.h"
 #include "main/mtypes.h"
 #include "main/fbobject.h"
 #include "main/framebuffer.h"
@@ -37,58 +38,13 @@
 
 #include "intel_context.h"
 #include "intel_buffers.h"
-#include "intel_depthstencil.h"
 #include "intel_fbo.h"
 #include "intel_mipmap_tree.h"
 #include "intel_regions.h"
-#include "intel_span.h"
 
 
 #define FILE_DEBUG_FLAG DEBUG_FBO
 
-#define INTEL_RB_CLASS 0x12345678
-
-
-/* XXX FBO: move this to intel_context.h (inlined) */
-/**
- * Return a gl_renderbuffer ptr casted to intel_renderbuffer.
- * NULL will be returned if the rb isn't really an intel_renderbuffer.
- * This is determiend by checking the ClassID.
- */
-struct intel_renderbuffer *
-intel_renderbuffer(struct gl_renderbuffer *rb)
-{
-   struct intel_renderbuffer *irb = (struct intel_renderbuffer *) rb;
-   if (irb && irb->Base.ClassID == INTEL_RB_CLASS) {
-      /*_mesa_warning(NULL, "Returning non-intel Rb\n");*/
-      return irb;
-   }
-   else
-      return NULL;
-}
-
-
-struct intel_renderbuffer *
-intel_get_renderbuffer(struct gl_framebuffer *fb, int attIndex)
-{
-   if (attIndex >= 0)
-      return intel_renderbuffer(fb->Attachment[attIndex].Renderbuffer);
-   else
-      return NULL;
-}
-
-struct intel_region *
-intel_get_rb_region(struct gl_framebuffer *fb, GLuint attIndex)
-{
-   struct intel_renderbuffer *irb = intel_get_renderbuffer(fb, attIndex);
-
-   if (irb)
-      return irb->region;
-   else
-      return NULL;
-}
-
-
 
 /**
  * Create a new framebuffer object.
@@ -103,6 +59,7 @@ intel_new_framebuffer(GLcontext * ctx, GLuint name)
 }
 
 
+/** Called by gl_renderbuffer::Delete() */
 static void
 intel_delete_renderbuffer(struct gl_renderbuffer *rb)
 {
@@ -112,10 +69,6 @@ intel_delete_renderbuffer(struct gl_renderbuffer *rb)
 
    ASSERT(irb);
 
-   if (irb->PairedStencil || irb->PairedDepth) {
-      intel_unpair_depth_stencil(ctx, irb);
-   }
-
    if (irb->span_cache != NULL)
       _mesa_free(irb->span_cache);
 
@@ -127,7 +80,6 @@ intel_delete_renderbuffer(struct gl_renderbuffer *rb)
 }
 
 
-
 /**
  * Return a pointer to a specific pixel in a renderbuffer.
  */
@@ -142,7 +94,6 @@ intel_get_pointer(GLcontext * ctx, struct gl_renderbuffer *rb,
 }
 
 
-
 /**
  * Called via glRenderbufferStorageEXT() to set the format and allocate
  * storage for a user-created renderbuffer.
@@ -211,18 +162,11 @@ intel_alloc_renderbuffer_storage(GLcontext * ctx, struct gl_renderbuffer *rb,
       cpp = 4;
       break;
    case GL_DEPTH_COMPONENT16:
-#if 0
       rb->_ActualFormat = GL_DEPTH_COMPONENT16;
       rb->DataType = GL_UNSIGNED_SHORT;
       rb->DepthBits = 16;
       cpp = 2;
       break;
-#else
-      /* fall-through.
-       * 16bpp depth renderbuffer can't be paired with a stencil buffer so
-       * always used combined depth/stencil format.
-       */
-#endif
    case GL_DEPTH_COMPONENT:
    case GL_DEPTH_COMPONENT24:
    case GL_DEPTH_COMPONENT32:
@@ -266,7 +210,8 @@ intel_alloc_renderbuffer_storage(GLcontext * ctx, struct gl_renderbuffer *rb,
       DBG("Allocating %d x %d Intel RBO (pitch %d)\n", width,
 	  height, pitch);
 
-      irb->region = intel_region_alloc(intel, cpp, width, height, pitch);
+      irb->region = intel_region_alloc(intel, cpp, width, height, pitch,
+				       GL_TRUE);
       if (!irb->region)
          return GL_FALSE;       /* out of memory? */
 
@@ -280,7 +225,6 @@ intel_alloc_renderbuffer_storage(GLcontext * ctx, struct gl_renderbuffer *rb,
 }
 
 
-
 /**
  * Called for each hardware renderbuffer when a _window_ is resized.
  * Just update fields.
@@ -298,6 +242,7 @@ intel_alloc_window_storage(GLcontext * ctx, struct gl_renderbuffer *rb,
    return GL_TRUE;
 }
 
+
 static void
 intel_resize_buffers(GLcontext *ctx, struct gl_framebuffer *fb,
 		     GLuint width, GLuint height)
@@ -324,6 +269,8 @@ intel_resize_buffers(GLcontext *ctx, struct gl_framebuffer *fb,
    }
 }
 
+
+/** Dummy function for gl_renderbuffer::AllocStorage() */
 static GLboolean
 intel_nop_alloc_storage(GLcontext * ctx, struct gl_renderbuffer *rb,
                         GLenum internalFormat, GLuint width, GLuint height)
@@ -343,10 +290,9 @@ intel_renderbuffer_set_region(struct intel_renderbuffer *rb,
    rb->region = NULL;
    intel_region_reference(&rb->region, region);
    intel_region_release(&old);
-
-   rb->pfPitch = region->pitch;
 }
 
+
 /**
  * Create a new intel_renderbuffer which corresponds to an on-screen window,
  * not a user-created renderbuffer.
@@ -377,6 +323,15 @@ intel_create_renderbuffer(GLenum intFormat)
       irb->Base.BlueBits = 5;
       irb->Base.DataType = GL_UNSIGNED_BYTE;
       break;
+   case GL_RGB8:
+      irb->Base._ActualFormat = GL_RGB8;
+      irb->Base._BaseFormat = GL_RGB;
+      irb->Base.RedBits = 8;
+      irb->Base.GreenBits = 8;
+      irb->Base.BlueBits = 8;
+      irb->Base.AlphaBits = 0;
+      irb->Base.DataType = GL_UNSIGNED_BYTE;
+      break;
    case GL_RGBA8:
       irb->Base._ActualFormat = GL_RGBA8;
       irb->Base._BaseFormat = GL_RGBA;
@@ -466,9 +421,6 @@ intel_bind_framebuffer(GLcontext * ctx, GLenum target,
 {
    if (target == GL_FRAMEBUFFER_EXT || target == GL_DRAW_FRAMEBUFFER_EXT) {
       intel_draw_buffer(ctx, fb);
-      /* Integer depth range depends on depth buffer bits */
-      if (ctx->Driver.DepthRange != NULL)
-	 ctx->Driver.DepthRange(ctx, ctx->Viewport.Near, ctx->Viewport.Far);
    }
    else {
       /* don't need to do anything if target == GL_READ_FRAMEBUFFER_EXT */
@@ -492,6 +444,7 @@ intel_framebuffer_renderbuffer(GLcontext * ctx,
    intel_draw_buffer(ctx, fb);
 }
 
+
 static GLboolean
 intel_update_wrapper(GLcontext *ctx, struct intel_renderbuffer *irb, 
 		     struct gl_texture_image *texImage)
@@ -538,11 +491,10 @@ intel_update_wrapper(GLcontext *ctx, struct intel_renderbuffer *irb,
    irb->Base.Delete = intel_delete_renderbuffer;
    irb->Base.AllocStorage = intel_nop_alloc_storage;
 
-   irb->RenderToTexture = GL_TRUE;
-
    return GL_TRUE;
 }
 
+
 /**
  * When glFramebufferTexture[123]D is called this function sets up the
  * gl_renderbuffer wrapper around the texture image.
@@ -551,7 +503,7 @@ intel_update_wrapper(GLcontext *ctx, struct intel_renderbuffer *irb,
 static struct intel_renderbuffer *
 intel_wrap_texture(GLcontext * ctx, struct gl_texture_image *texImage)
 {
-   const GLuint name = ~0;      /* not significant, but distinct for debugging */
+   const GLuint name = ~0;   /* not significant, but distinct for debugging */
    struct intel_renderbuffer *irb;
 
    /* make an intel_renderbuffer to wrap the texture image */
@@ -598,10 +550,11 @@ intel_render_texture(GLcontext * ctx,
       /* Fallback on drawing to a texture with a border, which won't have a
        * miptree.
        */
-       _mesa_reference_renderbuffer(&att->Renderbuffer, NULL);
-       _mesa_render_texture(ctx, fb, att);
-       return;
-   } else if (!irb) {
+      _mesa_reference_renderbuffer(&att->Renderbuffer, NULL);
+      _mesa_render_texture(ctx, fb, att);
+      return;
+   }
+   else if (!irb) {
       irb = intel_wrap_texture(ctx, newImage);
       if (irb) {
          /* bind the wrapper to the attachment point */
@@ -612,7 +565,9 @@ intel_render_texture(GLcontext * ctx,
          _mesa_render_texture(ctx, fb, att);
          return;
       }
-   } if (!intel_update_wrapper(ctx, irb, newImage)) {
+   }
+
+   if (!intel_update_wrapper(ctx, irb, newImage)) {
        _mesa_reference_renderbuffer(&att->Renderbuffer, NULL);
        _mesa_render_texture(ctx, fb, att);
        return;
@@ -657,19 +612,133 @@ static void
 intel_finish_render_texture(GLcontext * ctx,
                             struct gl_renderbuffer_attachment *att)
 {
-   struct intel_renderbuffer *irb = intel_renderbuffer(att->Renderbuffer);
+   /* no-op
+    * Previously we released the renderbuffer's intel_region but
+    * that's not necessary and actually caused problems when trying
+    * to do a glRead/CopyPixels from the renderbuffer later.
+    * The region will be released later if the texture is replaced
+    * or the renderbuffer deleted.
+    *
+    * The intention of this driver hook is more of a "done rendering
+    * to texture, please re-twiddle/etc if necessary".
+    */
+}
 
-   DBG("End render texture (tid %x) tex %u\n", _glthread_GetID(), att->Texture->Name);
 
-   if (irb) {
-      /* just release the region */
-      intel_region_release(&irb->region);
+/**
+ * Do additional "completeness" testing of a framebuffer object.
+ */
+static void
+intel_validate_framebuffer(GLcontext *ctx, struct gl_framebuffer *fb)
+{
+   struct intel_context *intel = intel_context(ctx);
+   const struct intel_renderbuffer *depthRb =
+      intel_get_renderbuffer(fb, BUFFER_DEPTH);
+   const struct intel_renderbuffer *stencilRb =
+      intel_get_renderbuffer(fb, BUFFER_STENCIL);
+
+   if (stencilRb && stencilRb != depthRb) {
+      /* we only support combined depth/stencil buffers, not separate
+       * stencil buffers.
+       */
+      fb->_Status = GL_FRAMEBUFFER_UNSUPPORTED_EXT;
+   }
+
+   /* check that texture color buffers are a format we can render into */
+   {
+      const struct gl_texture_format *supportedFormat;
+      GLuint i;
+
+      /* The texture format we can render into seems to depend on the
+       * screen depth.  There currently seems to be a problem when
+       * rendering into a rgb565 texture when the screen is abgr8888.
+       */
+      if (intel->front_region->cpp == 4)
+         supportedFormat = &_mesa_texformat_argb8888;
+      else 
+         supportedFormat = &_mesa_texformat_rgb565;
+
+      for (i = 0; i < ctx->Const.MaxDrawBuffers; i++) {
+         const struct gl_texture_object *texObj =
+            fb->Attachment[BUFFER_COLOR0 + i].Texture;
+         if (texObj) {
+            const struct gl_texture_image *texImg =
+               texObj->Image[0][texObj->BaseLevel];
+            if (texImg && texImg->TexFormat != supportedFormat) {
+               fb->_Status = GL_FRAMEBUFFER_UNSUPPORTED_EXT;
+               break;
+            }
+         }
+      }
+   }
+}
+
+
+/**
+ * Called from glBlitFramebuffer().
+ * For now, we're doing an approximation with glCopyPixels().
+ * XXX we need to bypass all the per-fragment operations, except scissor.
+ */
+static void
+intel_blit_framebuffer(GLcontext *ctx,
+                       GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1,
+                       GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1,
+                       GLbitfield mask, GLenum filter)
+{
+   const GLfloat xZoomSave = ctx->Pixel.ZoomX;
+   const GLfloat yZoomSave = ctx->Pixel.ZoomY;
+   GLsizei width, height;
+   GLfloat xFlip = 1.0F, yFlip = 1.0F;
+
+   if (srcX1 < srcX0) {
+      GLint tmp = srcX1;
+      srcX1 = srcX0;
+      srcX0 = tmp;
+      xFlip = -1.0F;
+   }
+
+   if (srcY1 < srcY0) {
+      GLint tmp = srcY1;
+      srcY1 = srcY0;
+      srcY0 = tmp;
+      yFlip = -1.0F;
+   }
+
+   width = srcX1 - srcX0;
+   height = srcY1 - srcY0;
+
+   ctx->Pixel.ZoomX = xFlip * (dstX1 - dstX0) / (srcX1 - srcY0);
+   ctx->Pixel.ZoomY = yFlip * (dstY1 - dstY0) / (srcY1 - srcY0);
+
+   if (ctx->Pixel.ZoomX < 0.0F) {
+      dstX0 = MAX2(dstX0, dstX1);
+   }
+   else {
+      dstX0 = MIN2(dstX0, dstX1);
+   }
+
+   if (ctx->Pixel.ZoomY < 0.0F) {
+      dstY0 = MAX2(dstY0, dstY1);
+   }
+   else {
+      dstY0 = MIN2(dstY0, dstY1);
+   }
+
+   if (mask & GL_COLOR_BUFFER_BIT) {
+      ctx->Driver.CopyPixels(ctx, srcX0, srcY0, width, height,
+                             dstX0, dstY0, GL_COLOR);
+   }
+   if (mask & GL_DEPTH_BUFFER_BIT) {
+      ctx->Driver.CopyPixels(ctx, srcX0, srcY0, width, height,
+                             dstX0, dstY0, GL_DEPTH);
    }
-   else if (att->Renderbuffer) {
-      /* software fallback */
-      _mesa_finish_render_texture(ctx, att);
-      /* XXX FBO: Need to unmap the buffer (or in intelSpanRenderStart???) */
+   if (mask & GL_STENCIL_BUFFER_BIT) {
+      ctx->Driver.CopyPixels(ctx, srcX0, srcY0, width, height,
+                             dstX0, dstY0, GL_STENCIL);
    }
+      
+   ctx->Pixel.ZoomX = xZoomSave;
+   ctx->Pixel.ZoomY = yZoomSave;
 }
 
 
@@ -687,4 +756,6 @@ intel_fbo_init(struct intel_context *intel)
    intel->ctx.Driver.RenderTexture = intel_render_texture;
    intel->ctx.Driver.FinishRenderTexture = intel_finish_render_texture;
    intel->ctx.Driver.ResizeBuffers = intel_resize_buffers;
+   intel->ctx.Driver.ValidateFramebuffer = intel_validate_framebuffer;
+   intel->ctx.Driver.BlitFramebuffer = intel_blit_framebuffer;
 }
diff --git a/src/mesa/drivers/dri/intel/intel_fbo.h b/src/mesa/drivers/dri/intel/intel_fbo.h
index b7e9280..7226ee0 100644
--- a/src/mesa/drivers/dri/intel/intel_fbo.h
+++ b/src/mesa/drivers/dri/intel/intel_fbo.h
@@ -55,19 +55,11 @@ struct intel_framebuffer
 
 /**
  * Intel renderbuffer, derived from gl_renderbuffer.
- * Note: The PairedDepth and PairedStencil fields use renderbuffer IDs,
- * not pointers because in some circumstances a deleted renderbuffer could
- * result in a dangling pointer here.
  */
 struct intel_renderbuffer
 {
    struct gl_renderbuffer Base;
    struct intel_region *region;
-   GLuint pfPitch;              /* possibly paged flipped pitch */
-   GLboolean RenderToTexture;   /* RTT? */
-
-   GLuint PairedDepth;   /**< only used if this is a depth renderbuffer */
-   GLuint PairedStencil; /**< only used if this is a stencil renderbuffer */
 
    GLuint vbl_pending;   /**< vblank sequence number of pending flip */
 
@@ -75,48 +67,70 @@ struct intel_renderbuffer
    unsigned long span_cache_offset;
 };
 
-extern struct intel_renderbuffer *intel_renderbuffer(struct gl_renderbuffer
-                                                     *rb);
+
+/**
+ * gl_renderbuffer is a base class which we subclass.  The Class field
+ * is used for simple run-time type checking.
+ */
+#define INTEL_RB_CLASS 0x12345678
+
+
+/**
+ * Return a gl_renderbuffer ptr casted to intel_renderbuffer.
+ * NULL will be returned if the rb isn't really an intel_renderbuffer.
+ * This is determined by checking the ClassID.
+ */
+static INLINE struct intel_renderbuffer *
+intel_renderbuffer(struct gl_renderbuffer *rb)
+{
+   struct intel_renderbuffer *irb = (struct intel_renderbuffer *) rb;
+   if (irb && irb->Base.ClassID == INTEL_RB_CLASS) {
+      /*_mesa_warning(NULL, "Returning non-intel Rb\n");*/
+      return irb;
+   }
+   else
+      return NULL;
+}
+
+
+/**
+ * Return a framebuffer's renderbuffer, named by a BUFFER_x index.
+ */
+static INLINE struct intel_renderbuffer *
+intel_get_renderbuffer(struct gl_framebuffer *fb, int attIndex)
+{
+   if (attIndex >= 0)
+      return intel_renderbuffer(fb->Attachment[attIndex].Renderbuffer);
+   else
+      return NULL;
+}
+
 
 extern void
 intel_renderbuffer_set_region(struct intel_renderbuffer *irb,
 			      struct intel_region *region);
 
+
 extern struct intel_renderbuffer *
 intel_create_renderbuffer(GLenum intFormat);
 
-extern void intel_fbo_init(struct intel_context *intel);
-
-
-/* XXX make inline or macro */
-extern struct intel_renderbuffer *intel_get_renderbuffer(struct gl_framebuffer
-                                                         *fb,
-                                                         int attIndex);
-
-extern void intel_flip_renderbuffers(struct intel_framebuffer *intel_fb);
 
+extern void
+intel_fbo_init(struct intel_context *intel);
 
-/* XXX make inline or macro */
-extern struct intel_region *intel_get_rb_region(struct gl_framebuffer *fb,
-                                                GLuint attIndex);
 
+extern void
+intel_flip_renderbuffers(struct intel_framebuffer *intel_fb);
 
 
-/**
- * Are we currently rendering into a texture?
- */
-static INLINE GLboolean
-intel_rendering_to_texture(const GLcontext *ctx)
+static INLINE struct intel_region *
+intel_get_rb_region(struct gl_framebuffer *fb, GLuint attIndex)
 {
-   if (ctx->DrawBuffer->Name) {
-      /* User-created FBO */
-      const struct intel_renderbuffer *irb =
-         intel_renderbuffer(ctx->DrawBuffer->_ColorDrawBuffers[0]);
-      return irb && irb->RenderToTexture;
-   }
-   else {
-      return GL_FALSE;
-   }
+   struct intel_renderbuffer *irb = intel_get_renderbuffer(fb, attIndex);
+   if (irb)
+      return irb->region;
+   else
+      return NULL;
 }
 
 
diff --git a/src/mesa/drivers/dri/intel/intel_mipmap_tree.c b/src/mesa/drivers/dri/intel/intel_mipmap_tree.c
index bf1c3f0..6e1e034 100644
--- a/src/mesa/drivers/dri/intel/intel_mipmap_tree.c
+++ b/src/mesa/drivers/dri/intel/intel_mipmap_tree.c
@@ -103,7 +103,8 @@ intel_miptree_create(struct intel_context *intel,
 		     GLuint last_level,
 		     GLuint width0,
 		     GLuint height0,
-		     GLuint depth0, GLuint cpp, GLuint compress_byte)
+		     GLuint depth0, GLuint cpp, GLuint compress_byte,
+		     GLboolean expect_accelerated_upload)
 {
    struct intel_mipmap_tree *mt;
 
@@ -120,7 +121,8 @@ intel_miptree_create(struct intel_context *intel,
 				   mt->cpp,
 				   mt->pitch,
 				   mt->total_height,
-				   mt->pitch);
+				   mt->pitch,
+				   expect_accelerated_upload);
 
    if (!mt->region) {
        free(mt);
diff --git a/src/mesa/drivers/dri/intel/intel_mipmap_tree.h b/src/mesa/drivers/dri/intel/intel_mipmap_tree.h
index c9537db..4060b9d 100644
--- a/src/mesa/drivers/dri/intel/intel_mipmap_tree.h
+++ b/src/mesa/drivers/dri/intel/intel_mipmap_tree.h
@@ -133,7 +133,8 @@ struct intel_mipmap_tree *intel_miptree_create(struct intel_context *intel,
                                                GLuint height0,
                                                GLuint depth0,
                                                GLuint cpp,
-                                               GLuint compress_byte);
+                                               GLuint compress_byte,
+					       GLboolean expect_accelerated_upload);
 
 struct intel_mipmap_tree *
 intel_miptree_create_for_region(struct intel_context *intel,
diff --git a/src/mesa/drivers/dri/intel/intel_pixel.c b/src/mesa/drivers/dri/intel/intel_pixel.c
index cf2f32d..5e32288 100644
--- a/src/mesa/drivers/dri/intel/intel_pixel.c
+++ b/src/mesa/drivers/dri/intel/intel_pixel.c
@@ -181,6 +181,7 @@ intel_meta_set_passthrough_transform(struct intel_context *intel)
    intel->meta.saved_vp_y = ctx->Viewport.Y;
    intel->meta.saved_vp_width = ctx->Viewport.Width;
    intel->meta.saved_vp_height = ctx->Viewport.Height;
+   intel->meta.saved_matrix_mode = ctx->Transform.MatrixMode;
 
    _mesa_Viewport(0, 0, ctx->DrawBuffer->Width, ctx->DrawBuffer->Height);
 
@@ -202,6 +203,8 @@ intel_meta_restore_transform(struct intel_context *intel)
    _mesa_MatrixMode(GL_MODELVIEW);
    _mesa_PopMatrix();
 
+   _mesa_MatrixMode(intel->meta.saved_matrix_mode);
+
    _mesa_Viewport(intel->meta.saved_vp_x, intel->meta.saved_vp_y,
 		  intel->meta.saved_vp_width, intel->meta.saved_vp_height);
 }
diff --git a/src/mesa/drivers/dri/intel/intel_pixel.h b/src/mesa/drivers/dri/intel/intel_pixel.h
index 76b8781..cb41fa1 100644
--- a/src/mesa/drivers/dri/intel/intel_pixel.h
+++ b/src/mesa/drivers/dri/intel/intel_pixel.h
@@ -76,4 +76,6 @@ void intelBitmap(GLcontext * ctx,
 		 const struct gl_pixelstore_attrib *unpack,
 		 const GLubyte * pixels);
 
+void intel_clear_tris(GLcontext *ctx, GLbitfield mask);
+
 #endif
diff --git a/src/mesa/drivers/dri/intel/intel_pixel_bitmap.c b/src/mesa/drivers/dri/intel/intel_pixel_bitmap.c
index 3a01f63..1db7f55 100644
--- a/src/mesa/drivers/dri/intel/intel_pixel_bitmap.c
+++ b/src/mesa/drivers/dri/intel/intel_pixel_bitmap.c
@@ -495,6 +495,7 @@ intel_texture_bitmap(GLcontext * ctx,
    texcoords[3][1] = 1.0;
 
    _mesa_VertexPointer(4, GL_FLOAT, 4 * sizeof(GLfloat), &vertices);
+   _mesa_ClientActiveTextureARB(GL_TEXTURE0);
    _mesa_TexCoordPointer(2, GL_FLOAT, 2 * sizeof(GLfloat), &texcoords);
    _mesa_Enable(GL_VERTEX_ARRAY);
    _mesa_Enable(GL_TEXTURE_COORD_ARRAY);
diff --git a/src/mesa/drivers/dri/intel/intel_pixel_draw.c b/src/mesa/drivers/dri/intel/intel_pixel_draw.c
index 0e83afa..7be7ea8 100644
--- a/src/mesa/drivers/dri/intel/intel_pixel_draw.c
+++ b/src/mesa/drivers/dri/intel/intel_pixel_draw.c
@@ -72,6 +72,8 @@ intel_texture_drawpixels(GLcontext * ctx,
    GLfloat vertices[4][4];
    GLfloat texcoords[4][2];
    GLfloat z;
+   GLint old_active_texture;
+   GLenum internalFormat;
 
    /* We're going to mess with texturing with no regard to existing texture
     * state, so if there is some set up we have to bail.
@@ -92,7 +94,7 @@ intel_texture_drawpixels(GLcontext * ctx,
       return GL_FALSE;
    }
 
-   /* We don't have a way to generate fragments with stencil values which *
+   /* We don't have a way to generate fragments with stencil values which
     * will set the resulting stencil value.
     */
    if (format == GL_STENCIL_INDEX)
@@ -125,6 +127,7 @@ intel_texture_drawpixels(GLcontext * ctx,
    /* XXX: pixel store stuff */
    _mesa_Disable(GL_POLYGON_STIPPLE);
 
+   old_active_texture = ctx->Texture.CurrentUnit;
    _mesa_ActiveTextureARB(GL_TEXTURE0_ARB);
    _mesa_Enable(GL_TEXTURE_2D);
    _mesa_GenTextures(1, &texname);
@@ -132,11 +135,11 @@ intel_texture_drawpixels(GLcontext * ctx,
    _mesa_TexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    _mesa_TexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    _mesa_TexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
-   /*
-   _mesa_TexEnvf(GL_TEXTURE_ENV, GL_COMBINE_RGB, GL_REPLACE);
-   _mesa_TexEnvf(GL_TEXTURE_ENV, GL_COMBINE_ALPHA, GL_REPLACE);
-   */
-   _mesa_TexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, format,
+   if (type == GL_ALPHA)
+      internalFormat = GL_ALPHA;
+   else
+      internalFormat = GL_RGBA;
+   _mesa_TexImage2D(GL_TEXTURE_2D, 0, internalFormat, width, height, 0, format,
 		    type, pixels);
 
    intel_meta_set_passthrough_transform(intel);
@@ -176,12 +179,15 @@ intel_texture_drawpixels(GLcontext * ctx,
    texcoords[3][1] = 1.0;
 
    _mesa_VertexPointer(4, GL_FLOAT, 4 * sizeof(GLfloat), &vertices);
+   _mesa_ClientActiveTextureARB(GL_TEXTURE0);
    _mesa_TexCoordPointer(2, GL_FLOAT, 2 * sizeof(GLfloat), &texcoords);
    _mesa_Enable(GL_VERTEX_ARRAY);
    _mesa_Enable(GL_TEXTURE_COORD_ARRAY);
    CALL_DrawArrays(ctx->Exec, (GL_TRIANGLE_FAN, 0, 4));
 
    intel_meta_restore_transform(intel);
+
+   _mesa_ActiveTextureARB(GL_TEXTURE0_ARB + old_active_texture);
    _mesa_PopClientAttrib();
    _mesa_PopAttrib();
 
@@ -209,6 +215,7 @@ intel_stencil_drawpixels(GLcontext * ctx,
    struct gl_pixelstore_attrib old_unpack;
    GLstencil *stencil_pixels;
    int row;
+   GLint old_active_texture;
 
    if (format != GL_STENCIL_INDEX)
       return GL_FALSE;
@@ -225,6 +232,10 @@ intel_stencil_drawpixels(GLcontext * ctx,
       return GL_FALSE;
    }
 
+   /* We don't support stencil testing/ops here */
+   if (ctx->Stencil.Enabled)
+      return GL_FALSE;
+
    /* We use FBOs for our wrapping of the depthbuffer into a color
     * destination.
     */
@@ -266,6 +277,7 @@ intel_stencil_drawpixels(GLcontext * ctx,
 		    GL_CURRENT_BIT | GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    _mesa_PushClientAttrib(GL_CLIENT_VERTEX_ARRAY_BIT);
    old_fb_name = ctx->DrawBuffer->Name;
+   old_active_texture = ctx->Texture.CurrentUnit;
 
    _mesa_Disable(GL_POLYGON_STIPPLE);
    _mesa_Disable(GL_DEPTH_TEST);
@@ -351,6 +363,7 @@ intel_stencil_drawpixels(GLcontext * ctx,
    texcoords[3][1] = 1.0;
 
    _mesa_VertexPointer(2, GL_FLOAT, 2 * sizeof(GLfloat), &vertices);
+   _mesa_ClientActiveTextureARB(GL_TEXTURE0);
    _mesa_TexCoordPointer(2, GL_FLOAT, 2 * sizeof(GLfloat), &texcoords);
    _mesa_Enable(GL_VERTEX_ARRAY);
    _mesa_Enable(GL_TEXTURE_COORD_ARRAY);
@@ -358,6 +371,7 @@ intel_stencil_drawpixels(GLcontext * ctx,
 
    intel_meta_restore_transform(intel);
 
+   _mesa_ActiveTextureARB(GL_TEXTURE0_ARB + old_active_texture);
    _mesa_BindFramebufferEXT(GL_FRAMEBUFFER_EXT, old_fb_name);
 
    _mesa_PopClientAttrib();
diff --git a/src/mesa/drivers/dri/intel/intel_regions.c b/src/mesa/drivers/dri/intel/intel_regions.c
index 51ce32a..0aa5b8c 100644
--- a/src/mesa/drivers/dri/intel/intel_regions.c
+++ b/src/mesa/drivers/dri/intel/intel_regions.c
@@ -109,12 +109,18 @@ intel_region_alloc_internal(struct intel_context *intel,
 
 struct intel_region *
 intel_region_alloc(struct intel_context *intel,
-                   GLuint cpp, GLuint width, GLuint height, GLuint pitch)
+                   GLuint cpp, GLuint width, GLuint height, GLuint pitch,
+		   GLboolean expect_accelerated_upload)
 {
    dri_bo *buffer;
 
-   buffer = dri_bo_alloc(intel->bufmgr, "region",
-			 pitch * cpp * height, 64);
+   if (expect_accelerated_upload) {
+      buffer = drm_intel_bo_alloc_for_render(intel->bufmgr, "region",
+					     pitch * cpp * height, 64);
+   } else {
+      buffer = drm_intel_bo_alloc(intel->bufmgr, "region",
+				  pitch * cpp * height, 64);
+   }
 
    return intel_region_alloc_internal(intel, cpp, width, height, pitch, buffer);
 }
@@ -152,7 +158,7 @@ void
 intel_region_reference(struct intel_region **dst, struct intel_region *src)
 {
    if (src)
-      DBG("%s %d\n", __FUNCTION__, src->refcount);
+      DBG("%s %p %d\n", __FUNCTION__, src, src->refcount);
 
    assert(*dst == NULL);
    if (src) {
@@ -169,7 +175,7 @@ intel_region_release(struct intel_region **region_handle)
    if (region == NULL)
       return;
 
-   DBG("%s %d\n", __FUNCTION__, region->refcount - 1);
+   DBG("%s %p %d\n", __FUNCTION__, region, region->refcount - 1);
 
    ASSERT(region->refcount > 0);
    region->refcount--;
@@ -460,7 +466,8 @@ intel_recreate_static(struct intel_context *intel,
    else
       region->cpp = intel->ctx.Visual.rgbBits / 8;
    region->pitch = intelScreen->pitch;
-   region->height = intelScreen->height;     /* needed? */
+   region->width = intelScreen->width;
+   region->height = intelScreen->height;
 
    if (region->buffer != NULL) {
       dri_bo_unreference(region->buffer);
diff --git a/src/mesa/drivers/dri/intel/intel_regions.h b/src/mesa/drivers/dri/intel/intel_regions.h
index 4b120ba..45e2bf4 100644
--- a/src/mesa/drivers/dri/intel/intel_regions.h
+++ b/src/mesa/drivers/dri/intel/intel_regions.h
@@ -74,7 +74,8 @@ struct intel_region
  */
 struct intel_region *intel_region_alloc(struct intel_context *intel,
                                         GLuint cpp, GLuint width,
-                                        GLuint height, GLuint pitch);
+                                        GLuint height, GLuint pitch,
+					GLboolean expect_accelerated_upload);
 
 struct intel_region *
 intel_region_alloc_for_handle(struct intel_context *intel,
diff --git a/src/mesa/drivers/dri/intel/intel_screen.c b/src/mesa/drivers/dri/intel/intel_screen.c
index 7042c25..09eba13 100644
--- a/src/mesa/drivers/dri/intel/intel_screen.c
+++ b/src/mesa/drivers/dri/intel/intel_screen.c
@@ -28,27 +28,27 @@
 #include "main/glheader.h"
 #include "main/context.h"
 #include "main/framebuffer.h"
-#include "main/matrix.h"
 #include "main/renderbuffer.h"
-#include "main/simple_list.h"
+
 #include "utils.h"
 #include "vblank.h"
 #include "xmlpool.h"
 
-
-#include "intel_screen.h"
-
+#include "intel_batchbuffer.h"
 #include "intel_buffers.h"
-#include "intel_tex.h"
-#include "intel_span.h"
-#include "intel_fbo.h"
+#include "intel_bufmgr.h"
 #include "intel_chipset.h"
+#include "intel_extensions.h"
+#include "intel_fbo.h"
+#include "intel_regions.h"
+#include "intel_swapbuffers.h"
+#include "intel_screen.h"
+#include "intel_span.h"
+#include "intel_tex.h"
 
 #include "i915_drm.h"
 #include "i830_dri.h"
-#include "intel_regions.h"
-#include "intel_batchbuffer.h"
-#include "intel_bufmgr.h"
+
 
 PUBLIC const char __driConfigOptions[] =
    DRI_CONF_BEGIN
@@ -159,7 +159,7 @@ intelPrintSAREA(const drm_i915_sarea_t * sarea)
  * A number of the screen parameters are obtained/computed from
  * information in the SAREA.  This function updates those parameters.
  */
-void
+static void
 intelUpdateScreenFromSAREA(intelScreenPrivate * intelScreen,
                            drm_i915_sarea_t * sarea)
 {
@@ -302,6 +302,7 @@ intelDestroyScreen(__DRIscreenPrivate * sPriv)
 
    dri_bufmgr_destroy(intelScreen->bufmgr);
    intelUnmapScreenRegions(intelScreen);
+   driDestroyOptionCache(&intelScreen->optionCache);
 
    FREE(intelScreen);
    sPriv->private = NULL;
@@ -316,15 +317,13 @@ intelCreateBuffer(__DRIscreenPrivate * driScrnPriv,
                   __DRIdrawablePrivate * driDrawPriv,
                   const __GLcontextModes * mesaVis, GLboolean isPixmap)
 {
-   intelScreenPrivate *screen = (intelScreenPrivate *) driScrnPriv->private;
-
    if (isPixmap) {
       return GL_FALSE;          /* not implemented */
    }
    else {
       GLboolean swStencil = (mesaVis->stencilBits > 0 &&
                              mesaVis->depthBits != 24);
-      GLenum rgbFormat = (mesaVis->redBits == 5 ? GL_RGB5 : GL_RGBA8);
+      GLenum rgbFormat;
 
       struct intel_framebuffer *intel_fb = CALLOC_STRUCT(intel_framebuffer);
 
@@ -333,6 +332,13 @@ intelCreateBuffer(__DRIscreenPrivate * driScrnPriv,
 
       _mesa_initialize_framebuffer(&intel_fb->Base, mesaVis);
 
+      if (mesaVis->redBits == 5)
+	 rgbFormat = GL_RGB5;
+      else if (mesaVis->alphaBits == 0)
+	 rgbFormat = GL_RGB8;
+      else
+	 rgbFormat = GL_RGBA8;
+
       /* setup the hardware-based renderbuffers */
       intel_fb->color_rb[0] = intel_create_renderbuffer(rgbFormat);
       _mesa_add_renderbuffer(&intel_fb->Base, BUFFER_FRONT_LEFT,
@@ -467,8 +473,6 @@ intelFillInModes(__DRIscreenPrivate *psp,
    __GLcontextModes *m;
    unsigned depth_buffer_factor;
    unsigned back_buffer_factor;
-   GLenum fb_format;
-   GLenum fb_type;
    int i;
 
    /* GLX_SWAP_COPY_OML is only supported because the Intel driver doesn't
@@ -480,6 +484,7 @@ intelFillInModes(__DRIscreenPrivate *psp,
 
    uint8_t depth_bits_array[3];
    uint8_t stencil_bits_array[3];
+   uint8_t msaa_samples_array[1];
 
    depth_bits_array[0] = 0;
    depth_bits_array[1] = depth_bits;
@@ -496,22 +501,39 @@ intelFillInModes(__DRIscreenPrivate *psp,
 
    stencil_bits_array[2] = (stencil_bits == 0) ? 8 : stencil_bits;
 
+   msaa_samples_array[0] = 0;
+
    depth_buffer_factor = ((depth_bits != 0) || (stencil_bits != 0)) ? 3 : 1;
    back_buffer_factor = (have_back_buffer) ? 3 : 1;
 
    if (pixel_bits == 16) {
-      fb_format = GL_RGB;
-      fb_type = GL_UNSIGNED_SHORT_5_6_5;
+      configs = driCreateConfigs(GL_RGB, GL_UNSIGNED_SHORT_5_6_5,
+				 depth_bits_array, stencil_bits_array,
+				 depth_buffer_factor, back_buffer_modes,
+				 back_buffer_factor,
+				 msaa_samples_array, 1);
    }
    else {
-      fb_format = GL_BGRA;
-      fb_type = GL_UNSIGNED_INT_8_8_8_8_REV;
+      __DRIconfig **configs_a8r8g8b8;
+      __DRIconfig **configs_x8r8g8b8;
+
+      configs_a8r8g8b8 = driCreateConfigs(GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV,
+					  depth_bits_array,
+					  stencil_bits_array,
+					  depth_buffer_factor,
+					  back_buffer_modes,
+					  back_buffer_factor,
+					  msaa_samples_array, 1);
+      configs_x8r8g8b8 = driCreateConfigs(GL_BGR, GL_UNSIGNED_INT_8_8_8_8_REV,
+					  depth_bits_array,
+					  stencil_bits_array,
+					  depth_buffer_factor,
+					  back_buffer_modes,
+					  back_buffer_factor,
+					  msaa_samples_array, 1);
+      configs = driConcatConfigs(configs_a8r8g8b8, configs_x8r8g8b8);
    }
 
-   configs = driCreateConfigs(fb_format, fb_type,
-			      depth_bits_array, stencil_bits_array,
-			      depth_buffer_factor, back_buffer_modes,
-			      back_buffer_factor);
    if (configs == NULL) {
     fprintf(stderr, "[%s:%u] Error creating FBConfig!\n", __func__,
               __LINE__);
@@ -673,6 +695,17 @@ static const
 __DRIconfig **intelInitScreen2(__DRIscreenPrivate *psp)
 {
    intelScreenPrivate *intelScreen;
+   GLenum fb_format[3];
+   GLenum fb_type[3];
+   /* GLX_SWAP_COPY_OML is only supported because the Intel driver doesn't
+    * support pageflipping at all.
+    */
+   static const GLenum back_buffer_modes[] = {
+      GLX_NONE, GLX_SWAP_UNDEFINED_OML, GLX_SWAP_COPY_OML
+   };
+   uint8_t depth_bits[4], stencil_bits[4], msaa_samples_array[1];
+   int color;
+   __DRIconfig **configs = NULL;
 
    /* Calling driInitExtensions here, with a NULL context pointer,
     * does not actually enable the extensions.  It just makes sure
@@ -712,8 +745,71 @@ __DRIconfig **intelInitScreen2(__DRIscreenPrivate *psp)
    intelScreen->irq_active = 1;
    psp->extensions = intelScreenExtensions;
 
-   return driConcatConfigs(intelFillInModes(psp, 16, 16, 0, 1),
-			   intelFillInModes(psp, 32, 24, 8, 1));
+   depth_bits[0] = 0;
+   stencil_bits[0] = 0;
+   depth_bits[1] = 16;
+   stencil_bits[1] = 0;
+   depth_bits[2] = 24;
+   stencil_bits[2] = 0;
+   depth_bits[3] = 24;
+   stencil_bits[3] = 8;
+
+   msaa_samples_array[0] = 0;
+
+   fb_format[0] = GL_RGB;
+   fb_type[0] = GL_UNSIGNED_SHORT_5_6_5;
+
+   fb_format[1] = GL_BGR;
+   fb_type[1] = GL_UNSIGNED_INT_8_8_8_8_REV;
+
+   fb_format[2] = GL_BGRA;
+   fb_type[2] = GL_UNSIGNED_INT_8_8_8_8_REV;
+
+   depth_bits[0] = 0;
+   stencil_bits[0] = 0;
+
+   for (color = 0; color < ARRAY_SIZE(fb_format); color++) {
+      __DRIconfig **new_configs;
+      int depth_factor;
+
+      /* With DRI2 right now, GetBuffers always returns a depth/stencil buffer
+       * with the same cpp as the drawable.  So we can't support depth cpp !=
+       * color cpp currently.
+       */
+      if (fb_type[color] == GL_UNSIGNED_SHORT_5_6_5) {
+	 depth_bits[1] = 16;
+	 stencil_bits[1] = 0;
+
+	 depth_factor = 2;
+      } else {
+	 depth_bits[1] = 24;
+	 stencil_bits[1] = 0;
+	 depth_bits[2] = 24;
+	 stencil_bits[2] = 8;
+
+	 depth_factor = 3;
+      }
+      new_configs = driCreateConfigs(fb_format[color], fb_type[color],
+				     depth_bits,
+				     stencil_bits,
+				     depth_factor,
+				     back_buffer_modes,
+				     ARRAY_SIZE(back_buffer_modes),
+				     msaa_samples_array,
+				     ARRAY_SIZE(msaa_samples_array));
+      if (configs == NULL)
+	 configs = new_configs;
+      else
+	 configs = driConcatConfigs(configs, new_configs);
+   }
+
+   if (configs == NULL) {
+      fprintf(stderr, "[%s:%u] Error creating FBConfig!\n", __func__,
+              __LINE__);
+      return NULL;
+   }
+
+   return (const __DRIconfig **)configs;
 }
 
 const struct __DriverAPIRec driDriverAPI = {
diff --git a/src/mesa/drivers/dri/intel/intel_screen.h b/src/mesa/drivers/dri/intel/intel_screen.h
index fcd0d9c..e1036de 100644
--- a/src/mesa/drivers/dri/intel/intel_screen.h
+++ b/src/mesa/drivers/dri/intel/intel_screen.h
@@ -92,10 +92,6 @@ extern GLboolean intelMapScreenRegions(__DRIscreenPrivate * sPriv);
 
 extern void intelUnmapScreenRegions(intelScreenPrivate * intelScreen);
 
-extern void
-intelUpdateScreenFromSAREA(intelScreenPrivate * intelScreen,
-                           drm_i915_sarea_t * sarea);
-
 extern void intelDestroyContext(__DRIcontextPrivate * driContextPriv);
 
 extern GLboolean intelUnbindContext(__DRIcontextPrivate * driContextPriv);
@@ -105,11 +101,6 @@ intelMakeCurrent(__DRIcontextPrivate * driContextPriv,
                  __DRIdrawablePrivate * driDrawPriv,
                  __DRIdrawablePrivate * driReadPriv);
 
-extern void intelSwapBuffers(__DRIdrawablePrivate * dPriv);
-
-extern void
-intelCopySubBuffer(__DRIdrawablePrivate * dPriv, int x, int y, int w, int h);
-
 extern struct intel_context *intelScreenContext(intelScreenPrivate *intelScreen);
 
 #endif
diff --git a/src/mesa/drivers/dri/intel/intel_span.c b/src/mesa/drivers/dri/intel/intel_span.c
index d931504..c3a873f 100644
--- a/src/mesa/drivers/dri/intel/intel_span.c
+++ b/src/mesa/drivers/dri/intel/intel_span.c
@@ -131,6 +131,18 @@ pwrite_8(struct intel_renderbuffer *irb, uint32_t offset, uint8_t val)
    dri_bo_subdata(irb->region->buffer, offset, 1, &val);
 }
 
+static uint32_t
+z24s8_to_s8z24(uint32_t val)
+{
+   return (val << 24) | (val >> 8);
+}
+
+static uint32_t
+s8z24_to_z24s8(uint32_t val)
+{
+   return (val >> 24) | (val << 8);
+}
+
 static uint32_t no_tile_swizzle(struct intel_renderbuffer *irb,
 				int x, int y)
 {
@@ -150,7 +162,7 @@ static uint32_t x_tile_swizzle(struct intel_renderbuffer *irb,
 	int	x_tile_number, y_tile_number;
 	int	tile_off, tile_base;
 	
-	tile_stride = (irb->pfPitch * irb->region->cpp) << 3;
+	tile_stride = (irb->region->pitch * irb->region->cpp) << 3;
 
 	xbyte = x * irb->region->cpp;
 
@@ -190,7 +202,7 @@ static uint32_t x_tile_swizzle(struct intel_renderbuffer *irb,
 	printf("(%d,%d) -> %d + %d = %d (pitch = %d, tstride = %d)\n",
 	       x, y, tile_off, tile_base,
 	       tile_off + tile_base,
-	       irb->pfPitch, tile_stride);
+	       irb->region->pitch, tile_stride);
 #endif
 
 	return tile_base + tile_off;
@@ -205,7 +217,7 @@ static uint32_t y_tile_swizzle(struct intel_renderbuffer *irb,
 	int	x_tile_number, y_tile_number;
 	int	tile_off, tile_base;
 	
-	tile_stride = (irb->pfPitch * irb->region->cpp) << 5;
+	tile_stride = (irb->region->pitch * irb->region->cpp) << 5;
 
 	xbyte = x * irb->region->cpp;
 
@@ -255,8 +267,8 @@ static uint32_t y_tile_swizzle(struct intel_renderbuffer *irb,
 #define LOCAL_VARS							\
    struct intel_context *intel = intel_context(ctx);			\
    struct intel_renderbuffer *irb = intel_renderbuffer(rb);		\
-   const GLint yScale = irb->RenderToTexture ? 1 : -1;			\
-   const GLint yBias = irb->RenderToTexture ? 0 : irb->Base.Height - 1;	\
+   const GLint yScale = ctx->DrawBuffer->Name ? 1 : -1;			\
+   const GLint yBias = ctx->DrawBuffer->Name ? 0 : irb->Base.Height - 1;\
    unsigned int num_cliprects;						\
    struct drm_clip_rect *cliprects;					\
    int x_off, y_off;							\
@@ -293,107 +305,35 @@ static uint32_t y_tile_swizzle(struct intel_renderbuffer *irb,
 #define X_TILE(_X, _Y) x_tile_swizzle(irb, (_X) + x_off, (_Y) + y_off)
 #define Y_TILE(_X, _Y) y_tile_swizzle(irb, (_X) + x_off, (_Y) + y_off)
 
-/* 16 bit, RGB565 color spanline and pixel functions
- */
-#define SPANTMP_PIXEL_FMT GL_RGB
-#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_SHORT_5_6_5
-
-#define TAG(x)    intel##x##_RGB565
-#define TAG2(x,y) intel##x##_RGB565##y
-#define GET_VALUE(X, Y) pread_16(irb, NO_TILE(X, Y))
-#define PUT_VALUE(X, Y, V) pwrite_16(irb, NO_TILE(X, Y), V)
-#include "spantmp2.h"
-
-/* 32 bit, ARGB8888 color spanline and pixel functions
- */
-#define SPANTMP_PIXEL_FMT GL_BGRA
-#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_INT_8_8_8_8_REV
-
-#define TAG(x)    intel##x##_ARGB8888
-#define TAG2(x,y) intel##x##_ARGB8888##y
-#define GET_VALUE(X, Y) pread_32(irb, NO_TILE(X, Y))
-#define PUT_VALUE(X, Y, V) pwrite_32(irb, NO_TILE(X, Y), V)
-#include "spantmp2.h"
-
-/* 32 bit, xRGB8888 color spanline and pixel functions
- */
-#define SPANTMP_PIXEL_FMT GL_BGRA
-#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_INT_8_8_8_8_REV
-
-#define TAG(x)    intel##x##_xRGB8888
-#define TAG2(x,y) intel##x##_xRGB8888##y
-#define GET_VALUE(X, Y) pread_xrgb8888(irb, NO_TILE(X, Y))
-#define PUT_VALUE(X, Y, V) pwrite_xrgb8888(irb, NO_TILE(X, Y), V)
-#include "spantmp2.h"
-
-/* 16 bit RGB565 color tile spanline and pixel functions
- */
-
-#define SPANTMP_PIXEL_FMT GL_RGB
-#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_SHORT_5_6_5
-
-#define TAG(x)    intel_XTile_##x##_RGB565
-#define TAG2(x,y) intel_XTile_##x##_RGB565##y
-#define GET_VALUE(X, Y) pread_16(irb, X_TILE(X, Y))
-#define PUT_VALUE(X, Y, V) pwrite_16(irb, X_TILE(X, Y), V)
-#include "spantmp2.h"
-
-#define SPANTMP_PIXEL_FMT GL_RGB
-#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_SHORT_5_6_5
-
-#define TAG(x)    intel_YTile_##x##_RGB565
-#define TAG2(x,y) intel_YTile_##x##_RGB565##y
-#define GET_VALUE(X, Y) pread_16(irb, Y_TILE(X, Y))
-#define PUT_VALUE(X, Y, V) pwrite_16(irb, Y_TILE(X, Y), V)
-#include "spantmp2.h"
-
-/* 32 bit ARGB888 color tile spanline and pixel functions
- */
-
-#define SPANTMP_PIXEL_FMT GL_BGRA
-#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_INT_8_8_8_8_REV
-
-#define TAG(x)    intel_XTile_##x##_ARGB8888
-#define TAG2(x,y) intel_XTile_##x##_ARGB8888##y
-#define GET_VALUE(X, Y) pread_32(irb, X_TILE(X, Y))
-#define PUT_VALUE(X, Y, V) pwrite_32(irb, X_TILE(X, Y), V)
-#include "spantmp2.h"
-
-#define SPANTMP_PIXEL_FMT GL_BGRA
-#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_INT_8_8_8_8_REV
-
-#define TAG(x)    intel_YTile_##x##_ARGB8888
-#define TAG2(x,y) intel_YTile_##x##_ARGB8888##y
-#define GET_VALUE(X, Y) pread_32(irb, Y_TILE(X, Y))
-#define PUT_VALUE(X, Y, V) pwrite_32(irb, Y_TILE(X, Y), V)
-#include "spantmp2.h"
-
-/* 32 bit xRGB888 color tile spanline and pixel functions
- */
-
-#define SPANTMP_PIXEL_FMT GL_BGRA
-#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_INT_8_8_8_8_REV
-
-#define TAG(x)    intel_XTile_##x##_xRGB8888
-#define TAG2(x,y) intel_XTile_##x##_xRGB8888##y
-#define GET_VALUE(X, Y) pread_xrgb8888(irb, X_TILE(X, Y))
-#define PUT_VALUE(X, Y, V) pwrite_xrgb8888(irb, X_TILE(X, Y), V)
-#include "spantmp2.h"
-
-#define SPANTMP_PIXEL_FMT GL_BGRA
-#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_INT_8_8_8_8_REV
-
-#define TAG(x)    intel_YTile_##x##_xRGB8888
-#define TAG2(x,y) intel_YTile_##x##_xRGB8888##y
-#define GET_VALUE(X, Y) pread_xrgb8888(irb, Y_TILE(X, Y))
-#define PUT_VALUE(X, Y, V) pwrite_xrgb8888(irb, Y_TILE(X, Y), V)
-#include "spantmp2.h"
+/* r5g6b5 color span and pixel functions */
+#define INTEL_PIXEL_FMT GL_RGB
+#define INTEL_PIXEL_TYPE GL_UNSIGNED_SHORT_5_6_5
+#define INTEL_READ_VALUE(offset) pread_16(irb, offset)
+#define INTEL_WRITE_VALUE(offset, v) pwrite_16(irb, offset, v)
+#define INTEL_TAG(x) x##_RGB565
+#include "intel_spantmp.h"
+
+/* a8r8g8b8 color span and pixel functions */
+#define INTEL_PIXEL_FMT GL_BGRA
+#define INTEL_PIXEL_TYPE GL_UNSIGNED_INT_8_8_8_8_REV
+#define INTEL_READ_VALUE(offset) pread_32(irb, offset)
+#define INTEL_WRITE_VALUE(offset, v) pwrite_32(irb, offset, v)
+#define INTEL_TAG(x) x##_ARGB8888
+#include "intel_spantmp.h"
+
+/* x8r8g8b8 color span and pixel functions */
+#define INTEL_PIXEL_FMT GL_BGRA
+#define INTEL_PIXEL_TYPE GL_UNSIGNED_INT_8_8_8_8_REV
+#define INTEL_READ_VALUE(offset) pread_xrgb8888(irb, offset)
+#define INTEL_WRITE_VALUE(offset, v) pwrite_xrgb8888(irb, offset, v)
+#define INTEL_TAG(x) x##_xRGB8888
+#include "intel_spantmp.h"
 
 #define LOCAL_DEPTH_VARS						\
    struct intel_context *intel = intel_context(ctx);			\
    struct intel_renderbuffer *irb = intel_renderbuffer(rb);		\
-   const GLint yScale = irb->RenderToTexture ? 1 : -1;			\
-   const GLint yBias = irb->RenderToTexture ? 0 : irb->Base.Height - 1; \
+   const GLint yScale = ctx->DrawBuffer->Name ? 1 : -1;			\
+   const GLint yBias = ctx->DrawBuffer->Name ? 0 : irb->Base.Height - 1;\
    unsigned int num_cliprects;						\
    struct drm_clip_rect *cliprects;					\
    int x_off, y_off;							\
@@ -402,98 +342,26 @@ static uint32_t y_tile_swizzle(struct intel_renderbuffer *irb,
 
 #define LOCAL_STENCIL_VARS LOCAL_DEPTH_VARS
 
-/**
- ** 16-bit depthbuffer functions.
- **/
-#define VALUE_TYPE GLushort
-#define WRITE_DEPTH(_x, _y, d) pwrite_16(irb, NO_TILE(_x, _y), d)
-#define READ_DEPTH(d, _x, _y) d = pread_16(irb, NO_TILE(_x, _y))
-#define TAG(x) intel##x##_z16
-#include "depthtmp.h"
-
-
-/**
- ** 16-bit x tile depthbuffer functions.
- **/
-#define VALUE_TYPE GLushort
-#define WRITE_DEPTH(_x, _y, d) pwrite_16(irb, X_TILE(_x, _y), d)
-#define READ_DEPTH(d, _x, _y) d = pread_16(irb, X_TILE(_x, _y))
-#define TAG(x) intel_XTile_##x##_z16
-#include "depthtmp.h"
-
-/**
- ** 16-bit y tile depthbuffer functions.
- **/
-#define VALUE_TYPE GLushort
-#define WRITE_DEPTH(_x, _y, d) pwrite_16(irb, Y_TILE(_x, _y), d)
-#define READ_DEPTH(d, _x, _y) d = pread_16(irb, Y_TILE(_x, _y))
-#define TAG(x) intel_YTile_##x##_z16
-#include "depthtmp.h"
-
-
-/**
- ** 24/8-bit interleaved depth/stencil functions
- ** Note: we're actually reading back combined depth+stencil values.
- ** The wrappers in main/depthstencil.c are used to extract the depth
- ** and stencil values.
- **/
-#define VALUE_TYPE GLuint
-
-/* Change ZZZS -> SZZZ */
-#define WRITE_DEPTH(_x, _y, d)					\
-   pwrite_32(irb, NO_TILE(_x, _y), ((d) >> 8) | ((d) << 24))
-
-/* Change SZZZ -> ZZZS */
-#define READ_DEPTH( d, _x, _y ) {				\
-   GLuint tmp = pread_32(irb, NO_TILE(_x, _y));			\
-   d = (tmp << 8) | (tmp >> 24);				\
-}
-
-#define TAG(x) intel##x##_z24_s8
-#include "depthtmp.h"
-
-
-/**
- ** 24/8-bit x-tile interleaved depth/stencil functions
- ** Note: we're actually reading back combined depth+stencil values.
- ** The wrappers in main/depthstencil.c are used to extract the depth
- ** and stencil values.
- **/
-#define VALUE_TYPE GLuint
+/* z16 depthbuffer functions. */
+#define INTEL_VALUE_TYPE GLushort
+#define INTEL_WRITE_DEPTH(offset, d) pwrite_16(irb, offset, d)
+#define INTEL_READ_DEPTH(offset) pread_16(irb, offset)
+#define INTEL_TAG(name) name##_z16
+#include "intel_depthtmp.h"
 
-/* Change ZZZS -> SZZZ */
-#define WRITE_DEPTH(_x, _y, d)					\
-   pwrite_32(irb, X_TILE(_x, _y), ((d) >> 8) | ((d) << 24))
+/* z24 depthbuffer functions. */
+#define INTEL_VALUE_TYPE GLuint
+#define INTEL_WRITE_DEPTH(offset, d) pwrite_32(irb, offset, d)
+#define INTEL_READ_DEPTH(offset) pread_32(irb, offset)
+#define INTEL_TAG(name) name##_z24
+#include "intel_depthtmp.h"
 
-/* Change SZZZ -> ZZZS */
-#define READ_DEPTH( d, _x, _y ) {				\
-   GLuint tmp = pread_32(irb, X_TILE(_x, _y));		\
-   d = (tmp << 8) | (tmp >> 24);				\
-}
-
-#define TAG(x) intel_XTile_##x##_z24_s8
-#include "depthtmp.h"
-
-/**
- ** 24/8-bit y-tile interleaved depth/stencil functions
- ** Note: we're actually reading back combined depth+stencil values.
- ** The wrappers in main/depthstencil.c are used to extract the depth
- ** and stencil values.
- **/
-#define VALUE_TYPE GLuint
-
-/* Change ZZZS -> SZZZ */
-#define WRITE_DEPTH(_x, _y, d)					\
-   pwrite_32(irb, Y_TILE(_x, _y), ((d) >> 8) | ((d) << 24))
-
-/* Change SZZZ -> ZZZS */
-#define READ_DEPTH( d, _x, _y ) {				\
-   GLuint tmp = pread_32(irb, Y_TILE(_x, _y));			\
-   d = (tmp << 8) | (tmp >> 24);				\
-}
-
-#define TAG(x) intel_YTile_##x##_z24_s8
-#include "depthtmp.h"
+/* z24s8 depthbuffer functions. */
+#define INTEL_VALUE_TYPE GLuint
+#define INTEL_WRITE_DEPTH(offset, d) pwrite_32(irb, offset, z24s8_to_s8z24(d))
+#define INTEL_READ_DEPTH(offset) s8z24_to_z24s8(pread_32(irb, offset))
+#define INTEL_TAG(name) name##_z24_s8
+#include "intel_depthtmp.h"
 
 
 /**
@@ -528,8 +396,6 @@ intel_renderbuffer_map(struct intel_context *intel, struct gl_renderbuffer *rb)
    if (irb == NULL || irb->region == NULL)
       return;
 
-   irb->pfPitch = irb->region->pitch;
-
    intel_set_span_functions(intel, rb);
 }
 
@@ -543,7 +409,6 @@ intel_renderbuffer_unmap(struct intel_context *intel,
       return;
 
    clear_span_cache(irb);
-   irb->pfPitch = 0;
 
    rb->GetRow = NULL;
    rb->PutRow = NULL;
@@ -755,8 +620,21 @@ intel_set_span_functions(struct intel_context *intel,
 	 break;
       }
    }
-   else if (rb->_ActualFormat == GL_DEPTH_COMPONENT24 ||        /* XXX FBO remove */
-            rb->_ActualFormat == GL_DEPTH24_STENCIL8_EXT) {
+   else if (rb->_ActualFormat == GL_DEPTH_COMPONENT24) {
+      switch (tiling) {
+      case I915_TILING_NONE:
+      default:
+	 intelInitDepthPointers_z24(rb);
+	 break;
+      case I915_TILING_X:
+	 intel_XTile_InitDepthPointers_z24(rb);
+	 break;
+      case I915_TILING_Y:
+	 intel_YTile_InitDepthPointers_z24(rb);
+	 break;
+      }
+   }
+   else if (rb->_ActualFormat == GL_DEPTH24_STENCIL8_EXT) {
       switch (tiling) {
       case I915_TILING_NONE:
       default:
diff --git a/src/mesa/drivers/dri/intel/intel_spantmp.h b/src/mesa/drivers/dri/intel/intel_spantmp.h
new file mode 100644
index 0000000..ead0b1c
--- /dev/null
+++ b/src/mesa/drivers/dri/intel/intel_spantmp.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright © 2009 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Eric Anholt <eric@anholt.net>
+ *
+ */
+
+/**
+ * Wrapper around the spantmp.h macrofest to generate spans code for
+ * all the tiling styles.
+ */
+
+#define SPANTMP_PIXEL_FMT INTEL_PIXEL_FMT
+#define SPANTMP_PIXEL_TYPE INTEL_PIXEL_TYPE
+#define PUT_VALUE(_x, _y, v) INTEL_WRITE_VALUE(NO_TILE(_x, _y), v)
+#define GET_VALUE(_x, _y) INTEL_READ_VALUE(NO_TILE(_x, _y))
+#define TAG(x) INTEL_TAG(intel##x)
+#define TAG2(x, y) INTEL_TAG(intel##x)##y
+#include "spantmp2.h"
+
+#define SPANTMP_PIXEL_FMT INTEL_PIXEL_FMT
+#define SPANTMP_PIXEL_TYPE INTEL_PIXEL_TYPE
+#define PUT_VALUE(_x, _y, v) INTEL_WRITE_VALUE(X_TILE(_x, _y), v)
+#define GET_VALUE(_x, _y) INTEL_READ_VALUE(X_TILE(_x, _y))
+#define TAG(x) INTEL_TAG(intel_XTile_##x)
+#define TAG2(x, y) INTEL_TAG(intel_XTile_##x)##y
+#include "spantmp2.h"
+
+#define SPANTMP_PIXEL_FMT INTEL_PIXEL_FMT
+#define SPANTMP_PIXEL_TYPE INTEL_PIXEL_TYPE
+#define PUT_VALUE(_x, _y, v) INTEL_WRITE_VALUE(X_TILE(_x, _y), v)
+#define GET_VALUE(_x, _y) INTEL_READ_VALUE(X_TILE(_x, _y))
+#define TAG(x) INTEL_TAG(intel_YTile_##x)
+#define TAG2(x, y) INTEL_TAG(intel_YTile_##x)##y
+#include "spantmp2.h"
+
+#undef INTEL_PIXEL_FMT
+#undef INTEL_PIXEL_TYPE
+#undef INTEL_WRITE_VALUE
+#undef INTEL_READ_VALUE
+#undef INTEL_TAG
diff --git a/src/mesa/drivers/dri/intel/intel_state.c b/src/mesa/drivers/dri/intel/intel_state.c
new file mode 100644
index 0000000..4ee7423
--- /dev/null
+++ b/src/mesa/drivers/dri/intel/intel_state.c
@@ -0,0 +1,233 @@
+/**************************************************************************
+ * 
+ * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ * 
+ **************************************************************************/
+
+
+#include "main/glheader.h"
+#include "main/context.h"
+#include "main/macros.h"
+#include "main/enums.h"
+#include "main/colormac.h"
+#include "main/dd.h"
+
+#include "intel_screen.h"
+#include "intel_context.h"
+#include "intel_regions.h"
+#include "swrast/swrast.h"
+
+int
+intel_translate_shadow_compare_func(GLenum func)
+{
+   switch (func) {
+   case GL_NEVER: 
+       return COMPAREFUNC_ALWAYS;
+   case GL_LESS: 
+       return COMPAREFUNC_LEQUAL;
+   case GL_LEQUAL: 
+       return COMPAREFUNC_LESS;
+   case GL_GREATER: 
+       return COMPAREFUNC_GEQUAL;
+   case GL_GEQUAL: 
+      return COMPAREFUNC_GREATER;
+   case GL_NOTEQUAL: 
+      return COMPAREFUNC_EQUAL;
+   case GL_EQUAL: 
+      return COMPAREFUNC_NOTEQUAL;
+   case GL_ALWAYS: 
+       return COMPAREFUNC_NEVER;
+   }
+
+   fprintf(stderr, "Unknown value in %s: %x\n", __FUNCTION__, func);
+   return COMPAREFUNC_NEVER;
+}
+
+int
+intel_translate_compare_func(GLenum func)
+{
+   switch (func) {
+   case GL_NEVER:
+      return COMPAREFUNC_NEVER;
+   case GL_LESS:
+      return COMPAREFUNC_LESS;
+   case GL_LEQUAL:
+      return COMPAREFUNC_LEQUAL;
+   case GL_GREATER:
+      return COMPAREFUNC_GREATER;
+   case GL_GEQUAL:
+      return COMPAREFUNC_GEQUAL;
+   case GL_NOTEQUAL:
+      return COMPAREFUNC_NOTEQUAL;
+   case GL_EQUAL:
+      return COMPAREFUNC_EQUAL;
+   case GL_ALWAYS:
+      return COMPAREFUNC_ALWAYS;
+   }
+
+   fprintf(stderr, "Unknown value in %s: %x\n", __FUNCTION__, func);
+   return COMPAREFUNC_ALWAYS;
+}
+
+int
+intel_translate_stencil_op(GLenum op)
+{
+   switch (op) {
+   case GL_KEEP:
+      return STENCILOP_KEEP;
+   case GL_ZERO:
+      return STENCILOP_ZERO;
+   case GL_REPLACE:
+      return STENCILOP_REPLACE;
+   case GL_INCR:
+      return STENCILOP_INCRSAT;
+   case GL_DECR:
+      return STENCILOP_DECRSAT;
+   case GL_INCR_WRAP:
+      return STENCILOP_INCR;
+   case GL_DECR_WRAP:
+      return STENCILOP_DECR;
+   case GL_INVERT:
+      return STENCILOP_INVERT;
+   default:
+      return STENCILOP_ZERO;
+   }
+}
+
+int
+intel_translate_blend_factor(GLenum factor)
+{
+   switch (factor) {
+   case GL_ZERO:
+      return BLENDFACT_ZERO;
+   case GL_SRC_ALPHA:
+      return BLENDFACT_SRC_ALPHA;
+   case GL_ONE:
+      return BLENDFACT_ONE;
+   case GL_SRC_COLOR:
+      return BLENDFACT_SRC_COLR;
+   case GL_ONE_MINUS_SRC_COLOR:
+      return BLENDFACT_INV_SRC_COLR;
+   case GL_DST_COLOR:
+      return BLENDFACT_DST_COLR;
+   case GL_ONE_MINUS_DST_COLOR:
+      return BLENDFACT_INV_DST_COLR;
+   case GL_ONE_MINUS_SRC_ALPHA:
+      return BLENDFACT_INV_SRC_ALPHA;
+   case GL_DST_ALPHA:
+      return BLENDFACT_DST_ALPHA;
+   case GL_ONE_MINUS_DST_ALPHA:
+      return BLENDFACT_INV_DST_ALPHA;
+   case GL_SRC_ALPHA_SATURATE:
+      return BLENDFACT_SRC_ALPHA_SATURATE;
+   case GL_CONSTANT_COLOR:
+      return BLENDFACT_CONST_COLOR;
+   case GL_ONE_MINUS_CONSTANT_COLOR:
+      return BLENDFACT_INV_CONST_COLOR;
+   case GL_CONSTANT_ALPHA:
+      return BLENDFACT_CONST_ALPHA;
+   case GL_ONE_MINUS_CONSTANT_ALPHA:
+      return BLENDFACT_INV_CONST_ALPHA;
+   }
+
+   fprintf(stderr, "Unknown value in %s: %x\n", __FUNCTION__, factor);
+   return BLENDFACT_ZERO;
+}
+
+int
+intel_translate_logic_op(GLenum opcode)
+{
+   switch (opcode) {
+   case GL_CLEAR:
+      return LOGICOP_CLEAR;
+   case GL_AND:
+      return LOGICOP_AND;
+   case GL_AND_REVERSE:
+      return LOGICOP_AND_RVRSE;
+   case GL_COPY:
+      return LOGICOP_COPY;
+   case GL_COPY_INVERTED:
+      return LOGICOP_COPY_INV;
+   case GL_AND_INVERTED:
+      return LOGICOP_AND_INV;
+   case GL_NOOP:
+      return LOGICOP_NOOP;
+   case GL_XOR:
+      return LOGICOP_XOR;
+   case GL_OR:
+      return LOGICOP_OR;
+   case GL_OR_INVERTED:
+      return LOGICOP_OR_INV;
+   case GL_NOR:
+      return LOGICOP_NOR;
+   case GL_EQUIV:
+      return LOGICOP_EQUIV;
+   case GL_INVERT:
+      return LOGICOP_INV;
+   case GL_OR_REVERSE:
+      return LOGICOP_OR_RVRSE;
+   case GL_NAND:
+      return LOGICOP_NAND;
+   case GL_SET:
+      return LOGICOP_SET;
+   default:
+      return LOGICOP_SET;
+   }
+}
+
+
+static void
+intelClearColor(GLcontext *ctx, const GLfloat color[4])
+{
+   struct intel_context *intel = intel_context(ctx);
+   GLubyte clear[4];
+
+   CLAMPED_FLOAT_TO_UBYTE(clear[0], color[0]);
+   CLAMPED_FLOAT_TO_UBYTE(clear[1], color[1]);
+   CLAMPED_FLOAT_TO_UBYTE(clear[2], color[2]);
+   CLAMPED_FLOAT_TO_UBYTE(clear[3], color[3]);
+
+   /* compute both 32 and 16-bit clear values */
+   intel->ClearColor8888 = INTEL_PACKCOLOR8888(clear[0], clear[1],
+                                               clear[2], clear[3]);
+   intel->ClearColor565 = INTEL_PACKCOLOR565(clear[0], clear[1], clear[2]);
+}
+
+
+/* Fallback to swrast for select and feedback.
+ */
+static void
+intelRenderMode(GLcontext *ctx, GLenum mode)
+{
+   struct intel_context *intel = intel_context(ctx);
+   FALLBACK(intel, INTEL_FALLBACK_RENDERMODE, (mode != GL_RENDER));
+}
+
+
+void
+intelInitStateFuncs(struct dd_function_table *functions)
+{
+   functions->RenderMode = intelRenderMode;
+   functions->ClearColor = intelClearColor;
+}
diff --git a/src/mesa/drivers/dri/intel/intel_swapbuffers.c b/src/mesa/drivers/dri/intel/intel_swapbuffers.c
new file mode 100644
index 0000000..7d035b9
--- /dev/null
+++ b/src/mesa/drivers/dri/intel/intel_swapbuffers.c
@@ -0,0 +1,248 @@
+/**************************************************************************
+ * 
+ * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ * 
+ **************************************************************************/
+
+#include "intel_blit.h"
+#include "intel_buffers.h"
+#include "intel_swapbuffers.h"
+#include "intel_fbo.h"
+#include "intel_batchbuffer.h"
+#include "drirenderbuffer.h"
+#include "vblank.h"
+#include "i915_drm.h"
+
+
+
+/*
+ * Correct a drawablePrivate's set of vblank flags WRT the current context.
+ * When considering multiple crtcs.
+ */
+GLuint
+intelFixupVblank(struct intel_context *intel, __DRIdrawablePrivate *dPriv)
+{
+   if (!intel->intelScreen->driScrnPriv->dri2.enabled &&
+       intel->intelScreen->driScrnPriv->ddx_version.minor >= 7) {
+      volatile drm_i915_sarea_t *sarea = intel->sarea;
+      drm_clip_rect_t drw_rect = { .x1 = dPriv->x, .x2 = dPriv->x + dPriv->w,
+				   .y1 = dPriv->y, .y2 = dPriv->y + dPriv->h };
+      drm_clip_rect_t planeA_rect = { .x1 = sarea->planeA_x, .y1 = sarea->planeA_y,
+				     .x2 = sarea->planeA_x + sarea->planeA_w,
+				     .y2 = sarea->planeA_y + sarea->planeA_h };
+      drm_clip_rect_t planeB_rect = { .x1 = sarea->planeB_x, .y1 = sarea->planeB_y,
+				     .x2 = sarea->planeB_x + sarea->planeB_w,
+				     .y2 = sarea->planeB_y + sarea->planeB_h };
+      GLint areaA = driIntersectArea( drw_rect, planeA_rect );
+      GLint areaB = driIntersectArea( drw_rect, planeB_rect );
+      GLuint flags = dPriv->vblFlags;
+
+      /* Update vblank info
+       */
+      if (areaB > areaA || (areaA == areaB && areaB > 0)) {
+	 flags = dPriv->vblFlags | VBLANK_FLAG_SECONDARY;
+      } else {
+	 flags = dPriv->vblFlags & ~VBLANK_FLAG_SECONDARY;
+      }
+
+      /* Do the stupid test: Is one of them actually disabled?
+       */
+      if (sarea->planeA_w == 0 || sarea->planeA_h == 0) {
+	 flags = dPriv->vblFlags | VBLANK_FLAG_SECONDARY;
+      } else if (sarea->planeB_w == 0 || sarea->planeB_h == 0) {
+	 flags = dPriv->vblFlags & ~VBLANK_FLAG_SECONDARY;
+      }
+
+      return flags;
+   } else {
+      return dPriv->vblFlags & ~VBLANK_FLAG_SECONDARY;
+   }
+}
+
+
+/**
+ * Called from driSwapBuffers()
+ */
+void
+intelSwapBuffers(__DRIdrawablePrivate * dPriv)
+{
+   __DRIscreenPrivate *psp = dPriv->driScreenPriv;
+
+   if (dPriv->driContextPriv && dPriv->driContextPriv->driverPrivate) {
+      GET_CURRENT_CONTEXT(ctx);
+      struct intel_context *intel;
+
+      if (ctx == NULL)
+	 return;
+
+      intel = intel_context(ctx);
+
+      if (ctx->Visual.doubleBufferMode) {
+	 GLboolean missed_target;
+	 struct intel_framebuffer *intel_fb = dPriv->driverPrivate;
+	 int64_t ust;
+         
+	 _mesa_notifySwapBuffers(ctx);  /* flush pending rendering comands */
+
+	/*
+	 * The old swapping ioctl was incredibly racy, just wait for vblank
+	 * and do the swap ourselves.
+	 */
+	 driWaitForVBlank(dPriv, &missed_target);
+
+	 /*
+	  * Update each buffer's vbl_pending so we don't get too out of
+	  * sync
+	  */
+	 intel_get_renderbuffer(&intel_fb->Base,
+		   		BUFFER_BACK_LEFT)->vbl_pending = dPriv->vblSeq;
+         intel_get_renderbuffer(&intel_fb->Base,
+		   		BUFFER_FRONT_LEFT)->vbl_pending = dPriv->vblSeq;
+
+	 intelCopyBuffer(dPriv, NULL);
+
+	 intel_fb->swap_count++;
+	 (*psp->systemTime->getUST) (&ust);
+	 if (missed_target) {
+	    intel_fb->swap_missed_count++;
+	    intel_fb->swap_missed_ust = ust - intel_fb->swap_ust;
+	 }
+
+	 intel_fb->swap_ust = ust;
+      }
+      drmCommandNone(intel->driFd, DRM_I915_GEM_THROTTLE);
+   }
+   else {
+      /* XXX this shouldn't be an error but we can't handle it for now */
+      fprintf(stderr, "%s: drawable has no context!\n", __FUNCTION__);
+   }
+}
+
+
+/**
+ * Called from driCopySubBuffer()
+ */
+void
+intelCopySubBuffer(__DRIdrawablePrivate * dPriv, int x, int y, int w, int h)
+{
+   if (dPriv->driContextPriv && dPriv->driContextPriv->driverPrivate) {
+      struct intel_context *intel =
+         (struct intel_context *) dPriv->driContextPriv->driverPrivate;
+      GLcontext *ctx = &intel->ctx;
+
+      if (ctx->Visual.doubleBufferMode) {
+         drm_clip_rect_t rect;
+         rect.x1 = x + dPriv->x;
+         rect.y1 = (dPriv->h - y - h) + dPriv->y;
+         rect.x2 = rect.x1 + w;
+         rect.y2 = rect.y1 + h;
+         _mesa_notifySwapBuffers(ctx);  /* flush pending rendering comands */
+         intelCopyBuffer(dPriv, &rect);
+      }
+   }
+   else {
+      /* XXX this shouldn't be an error but we can't handle it for now */
+      fprintf(stderr, "%s: drawable has no context!\n", __FUNCTION__);
+   }
+}
+
+
+/**
+ * This will be called whenever the currently bound window is moved/resized.
+ * XXX: actually, it seems to NOT be called when the window is only moved (BP).
+ */
+void
+intelWindowMoved(struct intel_context *intel)
+{
+   GLcontext *ctx = &intel->ctx;
+   __DRIdrawablePrivate *dPriv = intel->driDrawable;
+   struct intel_framebuffer *intel_fb = dPriv->driverPrivate;
+
+   if (!intel->intelScreen->driScrnPriv->dri2.enabled &&
+       intel->intelScreen->driScrnPriv->ddx_version.minor >= 7) {
+      GLuint flags = intelFixupVblank(intel, dPriv);
+
+      /* Check to see if we changed pipes */
+      if (flags != dPriv->vblFlags && dPriv->vblFlags &&
+	  !(dPriv->vblFlags & VBLANK_FLAG_NO_IRQ)) {
+	 int64_t count;
+	 drmVBlank vbl;
+	 int i;
+
+	 /*
+	  * Deal with page flipping
+	  */
+	 vbl.request.type = DRM_VBLANK_ABSOLUTE;
+
+	 if ( dPriv->vblFlags & VBLANK_FLAG_SECONDARY ) {
+	    vbl.request.type |= DRM_VBLANK_SECONDARY;
+	 }
+
+	 for (i = 0; i < 2; i++) {
+	    if (!intel_fb->color_rb[i] ||
+		(intel_fb->vbl_waited - intel_fb->color_rb[i]->vbl_pending) <=
+		(1<<23))
+	       continue;
+
+	    vbl.request.sequence = intel_fb->color_rb[i]->vbl_pending;
+	    drmWaitVBlank(intel->driFd, &vbl);
+	 }
+
+	 /*
+	  * Update msc_base from old pipe
+	  */
+	 driDrawableGetMSC32(dPriv->driScreenPriv, dPriv, &count);
+	 dPriv->msc_base = count;
+	 /*
+	  * Then get new vblank_base and vblSeq values
+	  */
+	 dPriv->vblFlags = flags;
+	 driGetCurrentVBlank(dPriv);
+	 dPriv->vblank_base = dPriv->vblSeq;
+
+	 intel_fb->vbl_waited = dPriv->vblSeq;
+
+	 for (i = 0; i < 2; i++) {
+	    if (intel_fb->color_rb[i])
+	       intel_fb->color_rb[i]->vbl_pending = intel_fb->vbl_waited;
+	 }
+      }
+   } else {
+      dPriv->vblFlags &= ~VBLANK_FLAG_SECONDARY;
+   }
+
+   /* Update Mesa's notion of window size */
+   driUpdateFramebufferSize(ctx, dPriv);
+   intel_fb->Base.Initialized = GL_TRUE; /* XXX remove someday */
+
+   /* Update hardware scissor */
+   if (ctx->Driver.Scissor != NULL) {
+      ctx->Driver.Scissor(ctx, ctx->Scissor.X, ctx->Scissor.Y,
+			  ctx->Scissor.Width, ctx->Scissor.Height);
+   }
+
+   /* Re-calculate viewport related state */
+   if (ctx->Driver.DepthRange != NULL)
+      ctx->Driver.DepthRange( ctx, ctx->Viewport.Near, ctx->Viewport.Far );
+}
diff --git a/src/mesa/drivers/dri/intel/intel_swapbuffers.h b/src/mesa/drivers/dri/intel/intel_swapbuffers.h
new file mode 100644
index 0000000..75bb624
--- /dev/null
+++ b/src/mesa/drivers/dri/intel/intel_swapbuffers.h
@@ -0,0 +1,52 @@
+
+/**************************************************************************
+ * 
+ * Copyright 2006 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ * 
+ **************************************************************************/
+
+#ifndef INTEL_SWAPBUFFERS_H
+#define INTEL_SWAPBUFFERS_H
+
+#include "dri_util.h"
+#include "drm.h"
+
+struct intel_context;
+struct intel_framebuffer;
+
+
+extern void
+intelSwapBuffers(__DRIdrawablePrivate * dPriv);
+
+extern void
+intelCopySubBuffer(__DRIdrawablePrivate * dPriv, int x, int y, int w, int h);
+
+extern GLuint
+intelFixupVblank(struct intel_context *intel, __DRIdrawablePrivate *dPriv);
+
+extern void
+intelWindowMoved(struct intel_context *intel);
+
+
+#endif /* INTEL_SWAPBUFFERS_H */
diff --git a/src/mesa/drivers/dri/intel/intel_tex.c b/src/mesa/drivers/dri/intel/intel_tex.c
index e64d8a1..ae0994b 100644
--- a/src/mesa/drivers/dri/intel/intel_tex.c
+++ b/src/mesa/drivers/dri/intel/intel_tex.c
@@ -93,7 +93,7 @@ intelFreeTextureImageData(GLcontext * ctx, struct gl_texture_image *texImage)
 static void *
 do_memcpy(void *dest, const void *src, size_t n)
 {
-   if ((((unsigned) src) & 63) || (((unsigned) dest) & 63)) {
+   if ((((unsigned long) src) & 63) || (((unsigned long) dest) & 63)) {
       return __memcpy(dest, src, n);
    }
    else
diff --git a/src/mesa/drivers/dri/intel/intel_tex_format.c b/src/mesa/drivers/dri/intel/intel_tex_format.c
index 5e418ac..2d57c67 100644
--- a/src/mesa/drivers/dri/intel/intel_tex_format.c
+++ b/src/mesa/drivers/dri/intel/intel_tex_format.c
@@ -3,11 +3,15 @@
 #include "main/texformat.h"
 #include "main/enums.h"
 
-/* It works out that this function is fine for all the supported
+
+/**
+ * Choose hardware texture format given the user's glTexImage parameters.
+ *
+ * It works out that this function is fine for all the supported
  * hardware.  However, there is still a need to map the formats onto
  * hardware descriptors.
- */
-/* Note that the i915 can actually support many more formats than
+ *
+ * Note that the i915 can actually support many more formats than
  * these if we take the step of simply swizzling the colors
  * immediately after sampling...
  */
@@ -16,7 +20,12 @@ intelChooseTextureFormat(GLcontext * ctx, GLint internalFormat,
                          GLenum format, GLenum type)
 {
    struct intel_context *intel = intel_context(ctx);
-   const GLboolean do32bpt = (intel->ctx.Visual.rgbBits == 32);
+   const GLboolean do32bpt = (intel->ctx.Visual.rgbBits >= 24);
+
+#if 0
+   printf("%s intFmt=0x%x format=0x%x type=0x%x\n",
+          __FUNCTION__, internalFormat, format, type);
+#endif
 
    switch (internalFormat) {
    case 4:
diff --git a/src/mesa/drivers/dri/intel/intel_tex_image.c b/src/mesa/drivers/dri/intel/intel_tex_image.c
index 2ac7dce..943636c 100644
--- a/src/mesa/drivers/dri/intel/intel_tex_image.c
+++ b/src/mesa/drivers/dri/intel/intel_tex_image.c
@@ -62,7 +62,8 @@ logbase2(int n)
 static void
 guess_and_alloc_mipmap_tree(struct intel_context *intel,
                             struct intel_texture_object *intelObj,
-                            struct intel_texture_image *intelImage)
+                            struct intel_texture_image *intelImage,
+			    GLboolean expect_accelerated_upload)
 {
    GLuint firstLevel;
    GLuint lastLevel;
@@ -136,7 +137,8 @@ guess_and_alloc_mipmap_tree(struct intel_context *intel,
                                        height,
                                        depth,
                                        intelImage->base.TexFormat->TexelBytes,
-                                       comp_byte);
+                                       comp_byte,
+				       expect_accelerated_upload);
 
    DBG("%s - success\n", __FUNCTION__);
 }
@@ -209,7 +211,8 @@ try_pbo_upload(struct intel_context *intel,
       return GL_FALSE;
    }
 
-   src_offset = (GLuint) pixels;
+   /* note: potential 64-bit ptr to 32-bit int cast */
+   src_offset = (GLuint) (unsigned long) pixels;
 
    if (unpack->RowLength > 0)
       src_stride = unpack->RowLength;
@@ -264,7 +267,8 @@ try_pbo_zcopy(struct intel_context *intel,
       return GL_FALSE;
    }
 
-   src_offset = (GLuint) pixels;
+   /* note: potential 64-bit ptr to 32-bit int cast */
+   src_offset = (GLuint) (unsigned long) pixels;
 
    if (unpack->RowLength > 0)
       src_stride = unpack->RowLength;
@@ -383,7 +387,7 @@ intelTexImage(GLcontext * ctx,
    }
 
    if (!intelObj->mt) {
-      guess_and_alloc_mipmap_tree(intel, intelObj, intelImage);
+      guess_and_alloc_mipmap_tree(intel, intelObj, intelImage, pixels == NULL);
       if (!intelObj->mt) {
 	 DBG("guess_and_alloc_mipmap_tree: failed\n");
       }
@@ -413,7 +417,7 @@ intelTexImage(GLcontext * ctx,
 					    level, level,
 					    width, height, depth,
 					    intelImage->base.TexFormat->TexelBytes,
-					    comp_byte);
+					    comp_byte, pixels == NULL);
 
    }
 
@@ -751,16 +755,21 @@ intelSetTexBuffer(__DRIcontext *pDRICtx, GLint target, __DRIdrawable *dPriv)
 
    _mesa_lock_texture(&intel->ctx, texObj);
 
+   texImage = _mesa_get_tex_image(&intel->ctx, texObj, target, level);
+   intelImage = intel_texture_image(texImage);
+
+   if (intelImage->mt) {
+      intel_miptree_release(intel, &intelImage->mt);
+      assert(!texImage->Data);
+   }
    if (intelObj->mt)
       intel_miptree_release(intel, &intelObj->mt);
 
    intelObj->mt = mt;
-   texImage = _mesa_get_tex_image(&intel->ctx, texObj, target, level);
    _mesa_init_teximage_fields(&intel->ctx, target, texImage,
 			      rb->region->width, rb->region->height, 1,
 			      0, internalFormat);
 
-   intelImage = intel_texture_image(texImage);
    intelImage->face = target_to_face(target);
    intelImage->level = level;
    texImage->TexFormat = intelChooseTextureFormat(&intel->ctx, internalFormat,
diff --git a/src/mesa/drivers/dri/intel/intel_tex_validate.c b/src/mesa/drivers/dri/intel/intel_tex_validate.c
index 820683d..05a375e 100644
--- a/src/mesa/drivers/dri/intel/intel_tex_validate.c
+++ b/src/mesa/drivers/dri/intel/intel_tex_validate.c
@@ -206,7 +206,8 @@ intel_finalize_mipmap_tree(struct intel_context *intel, GLuint unit)
                                           firstImage->base.Height,
                                           firstImage->base.Depth,
                                           cpp,
-                                          comp_byte);
+                                          comp_byte,
+					  GL_TRUE);
    }
 
    /* Pull in any images not in the object's tree:
diff --git a/src/mesa/drivers/dri/mach64/mach64_context.c b/src/mesa/drivers/dri/mach64/mach64_context.c
index 99abd20..9c7f513 100644
--- a/src/mesa/drivers/dri/mach64/mach64_context.c
+++ b/src/mesa/drivers/dri/mach64/mach64_context.c
@@ -57,10 +57,6 @@
 #include "utils.h"
 #include "vblank.h"
 
-#define need_GL_ARB_multisample
-#define need_GL_ARB_vertex_buffer_object
-#include "extension_helper.h"
-
 #ifndef MACH64_DEBUG
 int MACH64_DEBUG = (0);
 #endif
@@ -82,9 +78,7 @@ static const struct dri_debug_control debug_control[] =
 
 const struct dri_extension card_extensions[] =
 {
-    { "GL_ARB_multisample",                GL_ARB_multisample_functions },
     { "GL_ARB_multitexture",               NULL },
-    { "GL_ARB_vertex_buffer_object",       GL_ARB_vertex_buffer_object_functions },
     { "GL_EXT_texture_edge_clamp",         NULL },
     { "GL_MESA_ycbcr_texture",             NULL },
     { "GL_SGIS_generate_mipmap",           NULL },
@@ -196,6 +190,7 @@ GLboolean mach64CreateContext( const __GLcontextModes *glVisual,
    ctx->Const.MaxTextureUnits = 2;
    ctx->Const.MaxTextureImageUnits = 2;
    ctx->Const.MaxTextureCoordUnits = 2;
+   ctx->Const.MaxDrawBuffers = 1;
 
    heap = mach64Screen->IsPCI ? MACH64_CARD_HEAP : MACH64_AGP_HEAP;
 
diff --git a/src/mesa/drivers/dri/mach64/mach64_screen.c b/src/mesa/drivers/dri/mach64/mach64_screen.c
index 6bfb4c3..43e5959 100644
--- a/src/mesa/drivers/dri/mach64/mach64_screen.c
+++ b/src/mesa/drivers/dri/mach64/mach64_screen.c
@@ -93,6 +93,7 @@ mach64FillInModes( __DRIscreenPrivate *psp,
 
     uint8_t depth_bits_array[2];
     uint8_t stencil_bits_array[2];
+    uint8_t msaa_samples_array[1];
 
     depth_bits_array[0] = depth_bits;
     depth_bits_array[1] = depth_bits;
@@ -104,6 +105,8 @@ mach64FillInModes( __DRIscreenPrivate *psp,
     stencil_bits_array[0] = 0;
     stencil_bits_array[1] = (stencil_bits == 0) ? 8 : stencil_bits;
 
+    msaa_samples_array[0] = 0;
+
     depth_buffer_factor = ((depth_bits != 0) || (stencil_bits != 0)) ? 2 : 1;
     back_buffer_factor  = (have_back_buffer) ? 2 : 1;
 
@@ -119,7 +122,8 @@ mach64FillInModes( __DRIscreenPrivate *psp,
     configs = driCreateConfigs(fb_format, fb_type,
 			       depth_bits_array, stencil_bits_array,
 			       depth_buffer_factor, back_buffer_modes,
-			       back_buffer_factor);
+			       back_buffer_factor,
+                               msaa_samples_array, 1);
     if (configs == NULL) {
        fprintf(stderr, "[%s:%u] Error creating FBConfig!\n",
 	       __func__, __LINE__);
diff --git a/src/mesa/drivers/dri/mach64/mach64_tex.c b/src/mesa/drivers/dri/mach64/mach64_tex.c
index 1f9d3c5..9fe267e 100644
--- a/src/mesa/drivers/dri/mach64/mach64_tex.c
+++ b/src/mesa/drivers/dri/mach64/mach64_tex.c
@@ -152,6 +152,7 @@ mach64ChooseTextureFormat( GLcontext *ctx, GLint internalFormat,
    case GL_ALPHA8:
    case GL_ALPHA12:
    case GL_ALPHA16:
+   case GL_COMPRESSED_ALPHA:
    case 2:
    case GL_LUMINANCE_ALPHA:
    case GL_LUMINANCE4_ALPHA4:
@@ -160,9 +161,11 @@ mach64ChooseTextureFormat( GLcontext *ctx, GLint internalFormat,
    case GL_LUMINANCE12_ALPHA4:
    case GL_LUMINANCE12_ALPHA12:
    case GL_LUMINANCE16_ALPHA16:
+   case GL_COMPRESSED_LUMINANCE_ALPHA:
    case 4:
    case GL_RGBA:
    case GL_RGBA2:
+   case GL_COMPRESSED_RGBA:
       if (mmesa->mach64Screen->cpp == 4)
          return &_mesa_texformat_argb8888;
       else
@@ -193,6 +196,7 @@ mach64ChooseTextureFormat( GLcontext *ctx, GLint internalFormat,
    case GL_RGB10:
    case GL_RGB12:
    case GL_RGB16:
+   case GL_COMPRESSED_RGB:
       if (mmesa->mach64Screen->cpp == 4)
          return &_mesa_texformat_argb8888;
       else
@@ -204,6 +208,7 @@ mach64ChooseTextureFormat( GLcontext *ctx, GLint internalFormat,
    case GL_LUMINANCE8:
    case GL_LUMINANCE12:
    case GL_LUMINANCE16:
+   case GL_COMPRESSED_LUMINANCE:
       if (mmesa->mach64Screen->cpp == 4)
          return &_mesa_texformat_argb8888; /* inefficient but accurate */
       else
@@ -214,6 +219,7 @@ mach64ChooseTextureFormat( GLcontext *ctx, GLint internalFormat,
    case GL_INTENSITY8:
    case GL_INTENSITY12:
    case GL_INTENSITY16:
+   case GL_COMPRESSED_INTENSITY:
       if (mmesa->mach64Screen->cpp == 4)
          return &_mesa_texformat_argb8888; /* inefficient but accurate */
       else
diff --git a/src/mesa/drivers/dri/mga/mga_texstate.c b/src/mesa/drivers/dri/mga/mga_texstate.c
index d4c5b6f..ad765d1 100644
diff --git a/src/mesa/drivers/dri/mga/mga_xmesa.c b/src/mesa/drivers/dri/mga/mga_xmesa.c
index 86da3a2..926534d 100644
--- a/src/mesa/drivers/dri/mga/mga_xmesa.c
+++ b/src/mesa/drivers/dri/mga/mga_xmesa.c
@@ -69,13 +69,9 @@
 
 #include "GL/internal/dri_interface.h"
 
-#define need_GL_ARB_multisample
-#define need_GL_ARB_texture_compression
-#define need_GL_ARB_vertex_buffer_object
 #define need_GL_ARB_vertex_program
 #define need_GL_EXT_fog_coord
 #define need_GL_EXT_gpu_program_parameters
-#define need_GL_EXT_multi_draw_arrays
 #define need_GL_EXT_secondary_color
 #if 0
 #define need_GL_EXT_paletted_texture
@@ -133,6 +129,7 @@ mgaFillInModes( __DRIscreenPrivate *psp,
 
     uint8_t depth_bits_array[3];
     uint8_t stencil_bits_array[3];
+    uint8_t msaa_samples_array[1];
 
 
     depth_bits_array[0] = 0;
@@ -147,6 +144,8 @@ mgaFillInModes( __DRIscreenPrivate *psp,
     stencil_bits_array[1] = 0;
     stencil_bits_array[2] = (stencil_bits == 0) ? 8 : stencil_bits;
 
+    msaa_samples_array[0] = 0;
+
     depth_buffer_factor = ((depth_bits != 0) || (stencil_bits != 0)) ? 3 : 1;
     back_buffer_factor  = (have_back_buffer) ? 2 : 1;
 
@@ -162,7 +161,8 @@ mgaFillInModes( __DRIscreenPrivate *psp,
     configs = driCreateConfigs(fb_format, fb_type,
 			       depth_bits_array, stencil_bits_array,
 			       depth_buffer_factor,
-			       back_buffer_modes, back_buffer_factor);
+			       back_buffer_modes, back_buffer_factor,
+                               msaa_samples_array, 1);
     if (configs == NULL) {
 	fprintf( stderr, "[%s:%u] Error creating FBConfig!\n",
 		 __func__, __LINE__ );
@@ -385,13 +385,9 @@ static const struct dri_extension g400_extensions[] =
 
 static const struct dri_extension card_extensions[] =
 {
-   { "GL_ARB_multisample",            GL_ARB_multisample_functions },
-   { "GL_ARB_texture_compression",    GL_ARB_texture_compression_functions },
    { "GL_ARB_texture_rectangle",      NULL },
-   { "GL_ARB_vertex_buffer_object",   GL_ARB_vertex_buffer_object_functions },
    { "GL_EXT_blend_logic_op",         NULL },
    { "GL_EXT_fog_coord",              GL_EXT_fog_coord_functions },
-   { "GL_EXT_multi_draw_arrays",      GL_EXT_multi_draw_arrays_functions },
    /* paletted_textures currently doesn't work, but we could fix them later */
 #if defined( need_GL_EXT_paletted_texture )
    { "GL_EXT_shared_texture_palette", NULL },
@@ -539,6 +535,8 @@ mgaCreateContext( const __GLcontextModes *mesaVis,
    ctx->Const.MaxLineWidthAA = 10.0;
    ctx->Const.LineWidthGranularity = 1.0;
 
+   ctx->Const.MaxDrawBuffers = 1;
+
    mmesa->texture_depth = driQueryOptioni (&mmesa->optionCache,
 					   "texture_depth");
    if (mmesa->texture_depth == DRI_CONF_TEXTURE_DEPTH_FB)
diff --git a/src/mesa/drivers/dri/r128/r128_context.c b/src/mesa/drivers/dri/r128/r128_context.c
index 535a98c..f511a67 100644
--- a/src/mesa/drivers/dri/r128/r128_context.c
+++ b/src/mesa/drivers/dri/r128/r128_context.c
@@ -65,9 +65,6 @@ USE OR OTHER DEALINGS IN THE SOFTWARE.
 int R128_DEBUG = 0;
 #endif
 
-#define need_GL_ARB_multisample
-#define need_GL_ARB_texture_compression
-#define need_GL_ARB_vertex_buffer_object
 #define need_GL_EXT_blend_minmax
 #define need_GL_EXT_fog_coord
 #define need_GL_EXT_secondary_color
@@ -75,12 +72,9 @@ int R128_DEBUG = 0;
 
 const struct dri_extension card_extensions[] =
 {
-    { "GL_ARB_multisample",                GL_ARB_multisample_functions },
     { "GL_ARB_multitexture",               NULL },
-    { "GL_ARB_texture_compression",        GL_ARB_texture_compression_functions },
     { "GL_ARB_texture_env_add",            NULL },
     { "GL_ARB_texture_mirrored_repeat",    NULL },
-    { "GL_ARB_vertex_buffer_object",       GL_ARB_vertex_buffer_object_functions },
     { "GL_EXT_blend_subtract",             GL_EXT_blend_minmax_functions },
     { "GL_EXT_fog_coord",                  GL_EXT_fog_coord_functions },
     { "GL_EXT_texture_edge_clamp",         NULL },
@@ -229,6 +223,8 @@ GLboolean r128CreateContext( const __GLcontextModes *glVisual,
    ctx->Const.MaxLineWidthAA = 1.0;
    ctx->Const.LineWidthGranularity = 1.0;
 
+   ctx->Const.MaxDrawBuffers = 1;
+
 #if ENABLE_PERF_BOXES
    rmesa->boxes = driQueryOptionb(&rmesa->optionCache, "performance_boxes");
 #endif
diff --git a/src/mesa/drivers/dri/r128/r128_screen.c b/src/mesa/drivers/dri/r128/r128_screen.c
index cb3a147..7cda4ca 100644
--- a/src/mesa/drivers/dri/r128/r128_screen.c
+++ b/src/mesa/drivers/dri/r128/r128_screen.c
@@ -422,7 +422,7 @@ r128FillInModes( __DRIscreenPrivate *psp,
 
     uint8_t depth_bits_array[2];
     uint8_t stencil_bits_array[2];
-
+    uint8_t msaa_samples_array[1];
 
     depth_bits_array[0] = depth_bits;
     depth_bits_array[1] = depth_bits;
@@ -434,6 +434,8 @@ r128FillInModes( __DRIscreenPrivate *psp,
     stencil_bits_array[0] = 0;
     stencil_bits_array[1] = (stencil_bits == 0) ? 8 : stencil_bits;
 
+    msaa_samples_array[0] = 0;
+
     depth_buffer_factor = ((depth_bits != 0) || (stencil_bits != 0)) ? 2 : 1;
     back_buffer_factor  = (have_back_buffer) ? 2 : 1;
 
@@ -446,26 +448,27 @@ r128FillInModes( __DRIscreenPrivate *psp,
         fb_type = GL_UNSIGNED_INT_8_8_8_8_REV;
     }
 
-   configs = driCreateConfigs(fb_format, fb_type,
-			      depth_bits_array, stencil_bits_array,
-			      depth_buffer_factor, back_buffer_modes,
-			      back_buffer_factor);
-   if (configs == NULL) {
-    fprintf(stderr, "[%s:%u] Error creating FBConfig!\n", __func__,
-              __LINE__);
-      return NULL;
-   }
+    configs = driCreateConfigs(fb_format, fb_type,
+                               depth_bits_array, stencil_bits_array,
+                               depth_buffer_factor, back_buffer_modes,
+                               back_buffer_factor,
+                               msaa_samples_array, 1);
+    if (configs == NULL) {
+        fprintf(stderr, "[%s:%u] Error creating FBConfig!\n", __func__,
+                __LINE__);
+        return NULL;
+    }
 
-   /* Mark the visual as slow if there are "fake" stencil bits.
-    */
-   for (i = 0; configs[i]; i++) {
-      m = &configs[i]->modes;
-      if ((m->stencilBits != 0) && (m->stencilBits != stencil_bits)) {
-         m->visualRating = GLX_SLOW_CONFIG;
-      }
-   }
+    /* Mark the visual as slow if there are "fake" stencil bits.
+     */
+    for (i = 0; configs[i]; i++) {
+        m = &configs[i]->modes;
+        if ((m->stencilBits != 0) && (m->stencilBits != stencil_bits)) {
+            m->visualRating = GLX_SLOW_CONFIG;
+        }
+    }
 
-   return (const __DRIconfig **) configs;
+    return (const __DRIconfig **) configs;
 }
 
 
diff --git a/src/mesa/drivers/dri/r200/r200_context.c b/src/mesa/drivers/dri/r200/r200_context.c
index 5531e0a..c067515 100644
--- a/src/mesa/drivers/dri/r200/r200_context.c
+++ b/src/mesa/drivers/dri/r200/r200_context.c
@@ -62,14 +62,10 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "r200_maos.h"
 #include "r200_vertprog.h"
 
-#define need_GL_ARB_multisample
-#define need_GL_ARB_texture_compression
-#define need_GL_ARB_vertex_buffer_object
 #define need_GL_ARB_vertex_program
 #define need_GL_ATI_fragment_shader
 #define need_GL_EXT_blend_minmax
 #define need_GL_EXT_fog_coord
-#define need_GL_EXT_multi_draw_arrays
 #define need_GL_EXT_secondary_color
 #define need_GL_EXT_blend_equation_separate
 #define need_GL_EXT_blend_func_separate
@@ -120,20 +116,16 @@ static const GLubyte *r200GetString( GLcontext *ctx, GLenum name )
  */
 const struct dri_extension card_extensions[] =
 {
-    { "GL_ARB_multisample",                GL_ARB_multisample_functions },
     { "GL_ARB_multitexture",               NULL },
     { "GL_ARB_texture_border_clamp",       NULL },
-    { "GL_ARB_texture_compression",        GL_ARB_texture_compression_functions },
     { "GL_ARB_texture_env_add",            NULL },
     { "GL_ARB_texture_env_combine",        NULL },
     { "GL_ARB_texture_env_dot3",           NULL },
     { "GL_ARB_texture_env_crossbar",       NULL },
     { "GL_ARB_texture_mirrored_repeat",    NULL },
-    { "GL_ARB_vertex_buffer_object",       GL_ARB_vertex_buffer_object_functions },
     { "GL_EXT_blend_minmax",               GL_EXT_blend_minmax_functions },
     { "GL_EXT_blend_subtract",             NULL },
     { "GL_EXT_fog_coord",                  GL_EXT_fog_coord_functions },
-    { "GL_EXT_multi_draw_arrays",          GL_EXT_multi_draw_arrays_functions },
     { "GL_EXT_secondary_color",            GL_EXT_secondary_color_functions },
     { "GL_EXT_stencil_wrap",               NULL },
     { "GL_EXT_texture_edge_clamp",         NULL },
@@ -411,6 +403,8 @@ GLboolean r200CreateContext( const __GLcontextModes *glVisual,
    ctx->Const.VertexProgram.MaxNativeParameters = R200_VSF_MAX_PARAM;
    ctx->Const.VertexProgram.MaxNativeAddressRegs = 1;
 
+   ctx->Const.MaxDrawBuffers = 1;
+
    /* Initialize the software rasterizer and helper modules.
     */
    _swrast_CreateContext( ctx );
diff --git a/src/mesa/drivers/dri/r200/r200_texstate.c b/src/mesa/drivers/dri/r200/r200_texstate.c
index 3f9a2f4..0ad5651 100644
--- a/src/mesa/drivers/dri/r200/r200_texstate.c
+++ b/src/mesa/drivers/dri/r200/r200_texstate.c
@@ -1366,27 +1366,27 @@ static GLboolean r200_validate_texgen( GLcontext *ctx, GLuint unit )
       fprintf(stderr, "%s unit %d\n", __FUNCTION__, unit);
 
    if (texUnit->TexGenEnabled & S_BIT) {
-      mode = texUnit->GenModeS;
+      mode = texUnit->GenS.Mode;
    } else {
       tgcm |= R200_TEXGEN_COMP_S << (unit * 4);
    }
 
    if (texUnit->TexGenEnabled & T_BIT) {
-      if (texUnit->GenModeT != mode)
+      if (texUnit->GenT.Mode != mode)
 	 mixed_fallback = GL_TRUE;
    } else {
       tgcm |= R200_TEXGEN_COMP_T << (unit * 4);
    }
 
    if (texUnit->TexGenEnabled & R_BIT) {
-      if (texUnit->GenModeR != mode)
+      if (texUnit->GenR.Mode != mode)
 	 mixed_fallback = GL_TRUE;
    } else {
       tgcm |= R200_TEXGEN_COMP_R << (unit * 4);
    }
 
    if (texUnit->TexGenEnabled & Q_BIT) {
-      if (texUnit->GenModeQ != mode)
+      if (texUnit->GenQ.Mode != mode)
 	 mixed_fallback = GL_TRUE;
    } else {
       tgcm |= R200_TEXGEN_COMP_Q << (unit * 4);
@@ -1395,8 +1395,8 @@ static GLboolean r200_validate_texgen( GLcontext *ctx, GLuint unit )
    if (mixed_fallback) {
       if (R200_DEBUG & DEBUG_FALLBACKS)
 	 fprintf(stderr, "fallback mixed texgen, 0x%x (0x%x 0x%x 0x%x 0x%x)\n",
-		 texUnit->TexGenEnabled, texUnit->GenModeS, texUnit->GenModeT,
-		 texUnit->GenModeR, texUnit->GenModeQ);
+		 texUnit->TexGenEnabled, texUnit->GenS.Mode, texUnit->GenT.Mode,
+		 texUnit->GenR.Mode, texUnit->GenQ.Mode);
       return GL_FALSE;
    }
 
@@ -1414,8 +1414,10 @@ static GLboolean r200_validate_texgen( GLcontext *ctx, GLuint unit )
    switch (mode) {
    case GL_OBJECT_LINEAR: {
       GLuint needtgenable = r200_need_dis_texgen( texUnit->TexGenEnabled,
-				texUnit->ObjectPlaneS, texUnit->ObjectPlaneT,
-				texUnit->ObjectPlaneR, texUnit->ObjectPlaneQ );
+                                                  texUnit->GenS.ObjectPlane,
+                                                  texUnit->GenT.ObjectPlane,
+                                                  texUnit->GenR.ObjectPlane,
+                                                  texUnit->GenQ.ObjectPlane );
       if (needtgenable & (S_BIT | T_BIT)) {
 	 if (R200_DEBUG & DEBUG_FALLBACKS)
 	 fprintf(stderr, "fallback mixed texgen / obj plane, 0x%x\n",
@@ -1431,17 +1433,19 @@ static GLboolean r200_validate_texgen( GLcontext *ctx, GLuint unit )
 
       tgi |= R200_TEXGEN_INPUT_OBJ << inputshift;
       set_texgen_matrix( rmesa, unit, 
-	 (texUnit->TexGenEnabled & S_BIT) ? texUnit->ObjectPlaneS : I,
-	 (texUnit->TexGenEnabled & T_BIT) ? texUnit->ObjectPlaneT : I + 4,
-	 (texUnit->TexGenEnabled & R_BIT) ? texUnit->ObjectPlaneR : I + 8,
-	 (texUnit->TexGenEnabled & Q_BIT) ? texUnit->ObjectPlaneQ : I + 12);
+	 (texUnit->TexGenEnabled & S_BIT) ? texUnit->GenS.ObjectPlane : I,
+	 (texUnit->TexGenEnabled & T_BIT) ? texUnit->GenT.ObjectPlane : I + 4,
+	 (texUnit->TexGenEnabled & R_BIT) ? texUnit->GenR.ObjectPlane : I + 8,
+	 (texUnit->TexGenEnabled & Q_BIT) ? texUnit->GenQ.ObjectPlane : I + 12);
       }
       break;
 
    case GL_EYE_LINEAR: {
       GLuint needtgenable = r200_need_dis_texgen( texUnit->TexGenEnabled,
-				texUnit->EyePlaneS, texUnit->EyePlaneT,
-				texUnit->EyePlaneR, texUnit->EyePlaneQ );
+                                                  texUnit->GenS.EyePlane,
+                                                  texUnit->GenT.EyePlane,
+                                                  texUnit->GenR.EyePlane,
+                                                  texUnit->GenQ.EyePlane );
       if (needtgenable & (S_BIT | T_BIT)) {
 	 if (R200_DEBUG & DEBUG_FALLBACKS)
 	 fprintf(stderr, "fallback mixed texgen / eye plane, 0x%x\n",
@@ -1456,10 +1460,10 @@ static GLboolean r200_validate_texgen( GLcontext *ctx, GLuint unit )
       }
       tgi |= R200_TEXGEN_INPUT_EYE << inputshift;
       set_texgen_matrix( rmesa, unit,
-	 (texUnit->TexGenEnabled & S_BIT) ? texUnit->EyePlaneS : I,
-	 (texUnit->TexGenEnabled & T_BIT) ? texUnit->EyePlaneT : I + 4,
-	 (texUnit->TexGenEnabled & R_BIT) ? texUnit->EyePlaneR : I + 8,
-	 (texUnit->TexGenEnabled & Q_BIT) ? texUnit->EyePlaneQ : I + 12);
+	 (texUnit->TexGenEnabled & S_BIT) ? texUnit->GenS.EyePlane : I,
+	 (texUnit->TexGenEnabled & T_BIT) ? texUnit->GenT.EyePlane : I + 4,
+	 (texUnit->TexGenEnabled & R_BIT) ? texUnit->GenR.EyePlane : I + 8,
+	 (texUnit->TexGenEnabled & Q_BIT) ? texUnit->GenQ.EyePlane : I + 12);
       }
       break;
 
@@ -1495,7 +1499,7 @@ static GLboolean r200_validate_texgen( GLcontext *ctx, GLuint unit )
        */
       if (R200_DEBUG & DEBUG_FALLBACKS)
 	 fprintf(stderr, "fallback unsupported texgen, %d\n",
-		 texUnit->GenModeS);
+		 texUnit->GenS.Mode);
       return GL_FALSE;
    }
 
diff --git a/src/mesa/drivers/dri/r300/r300_context.c b/src/mesa/drivers/dri/r300/r300_context.c
index 3743627..4c14c7e 100644
--- a/src/mesa/drivers/dri/r300/r300_context.c
+++ b/src/mesa/drivers/dri/r300/r300_context.c
@@ -77,19 +77,17 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 int future_hw_tcl_on = 1;
 int hw_tcl_on = 1;
 
-#define need_GL_EXT_stencil_two_side
-#define need_GL_ARB_multisample
+#define need_GL_VERSION_2_0
 #define need_GL_ARB_point_parameters
-#define need_GL_ARB_texture_compression
-#define need_GL_ARB_vertex_buffer_object
 #define need_GL_ARB_vertex_program
-#define need_GL_EXT_blend_minmax
-//#define need_GL_EXT_fog_coord
-#define need_GL_EXT_multi_draw_arrays
-#define need_GL_EXT_secondary_color
 #define need_GL_EXT_blend_equation_separate
 #define need_GL_EXT_blend_func_separate
+#define need_GL_EXT_blend_minmax
+//#define need_GL_EXT_fog_coord
 #define need_GL_EXT_gpu_program_parameters
+#define need_GL_EXT_secondary_color
+#define need_GL_EXT_stencil_two_side
+#define need_GL_ATI_separate_stencil
 #define need_GL_NV_vertex_program
 #include "extension_helper.h"
 
@@ -97,27 +95,23 @@ const struct dri_extension card_extensions[] = {
   /* *INDENT-OFF* */
   {"GL_ARB_depth_texture",		NULL},
   {"GL_ARB_fragment_program",		NULL},
-  {"GL_ARB_multisample",		GL_ARB_multisample_functions},
   {"GL_ARB_multitexture",		NULL},
   {"GL_ARB_point_parameters",		GL_ARB_point_parameters_functions},
   {"GL_ARB_shadow",			NULL},
   {"GL_ARB_shadow_ambient",		NULL},
   {"GL_ARB_texture_border_clamp",	NULL},
-  {"GL_ARB_texture_compression",	GL_ARB_texture_compression_functions},
   {"GL_ARB_texture_cube_map",		NULL},
   {"GL_ARB_texture_env_add",		NULL},
   {"GL_ARB_texture_env_combine",	NULL},
   {"GL_ARB_texture_env_crossbar",	NULL},
   {"GL_ARB_texture_env_dot3",		NULL},
   {"GL_ARB_texture_mirrored_repeat",	NULL},
-  {"GL_ARB_vertex_buffer_object",	GL_ARB_vertex_buffer_object_functions},
   {"GL_ARB_vertex_program",		GL_ARB_vertex_program_functions},
   {"GL_EXT_blend_equation_separate",	GL_EXT_blend_equation_separate_functions},
   {"GL_EXT_blend_func_separate",	GL_EXT_blend_func_separate_functions},
   {"GL_EXT_blend_minmax",		GL_EXT_blend_minmax_functions},
   {"GL_EXT_blend_subtract",		NULL},
 //  {"GL_EXT_fog_coord",			GL_EXT_fog_coord_functions },
-  {"GL_EXT_multi_draw_arrays",		GL_EXT_multi_draw_arrays_functions},
   {"GL_EXT_gpu_program_parameters",     GL_EXT_gpu_program_parameters_functions},
   {"GL_EXT_secondary_color", 		GL_EXT_secondary_color_functions},
   {"GL_EXT_shadow_funcs",		NULL},
@@ -130,6 +124,7 @@ const struct dri_extension card_extensions[] = {
   {"GL_EXT_texture_lod_bias",		NULL},
   {"GL_EXT_texture_mirror_clamp",	NULL},
   {"GL_EXT_texture_rectangle",		NULL},
+  {"GL_ATI_separate_stencil",		GL_ATI_separate_stencil_functions},
   {"GL_ATI_texture_env_combine3",	NULL},
   {"GL_ATI_texture_mirror_once",	NULL},
   {"GL_MESA_pack_invert",		NULL},
@@ -142,6 +137,16 @@ const struct dri_extension card_extensions[] = {
   /* *INDENT-ON* */
 };
 
+
+/**
+ * The GL 2.0 functions are needed to make display lists work with
+ * functions added by GL_ATI_separate_stencil.
+ */
+const struct dri_extension gl_20_extension[] = {
+  {"GL_VERSION_2_0",			GL_VERSION_2_0_functions },
+};
+
+
 extern struct tnl_pipeline_stage _r300_render_stage;
 extern const struct tnl_pipeline_stage _r300_tcl_stage;
 
@@ -306,6 +311,8 @@ GLboolean r300CreateContext(const __GLcontextModes * glVisual,
 #endif
 #endif
 
+	ctx->Const.MaxDrawBuffers = 1;
+
 	/* Initialize the software rasterizer and helper modules.
 	 */
 	_swrast_CreateContext(ctx);
diff --git a/src/mesa/drivers/dri/r300/r300_fragprog.c b/src/mesa/drivers/dri/r300/r300_fragprog.c
index 4ef7f2b..8d030c6 100644
--- a/src/mesa/drivers/dri/r300/r300_fragprog.c
+++ b/src/mesa/drivers/dri/r300/r300_fragprog.c
@@ -163,6 +163,19 @@ static GLboolean transform_TEX(
 		}
 	}
 
+	if (inst.SrcReg[0].File != PROGRAM_TEMPORARY && inst.SrcReg[0].File != PROGRAM_INPUT) {
+		int tmpreg = radeonFindFreeTemporary(t);
+		tgt = radeonAppendInstructions(t->Program, 1);
+		tgt->Opcode = OPCODE_MOV;
+		tgt->DstReg.File = PROGRAM_TEMPORARY;
+		tgt->DstReg.Index = tmpreg;
+		tgt->SrcReg[0] = inst.SrcReg[0];
+
+		reset_srcreg(&inst.SrcReg[0]);
+		inst.SrcReg[0].File = PROGRAM_TEMPORARY;
+		inst.SrcReg[0].Index = tmpreg;
+	}
+	
 	tgt = radeonAppendInstructions(t->Program, 1);
 	_mesa_copy_instructions(tgt, &inst, 1);
 
diff --git a/src/mesa/drivers/dri/r300/r300_reg.h b/src/mesa/drivers/dri/r300/r300_reg.h
index 7c6485e..872a33e 100644
--- a/src/mesa/drivers/dri/r300/r300_reg.h
+++ b/src/mesa/drivers/dri/r300/r300_reg.h
@@ -656,7 +656,7 @@ USE OR OTHER DEALINGS IN THE SOFTWARE.
 #	define R300_GB_FOG_SELECT_C3A           (3 << 0)
 #	define R300_GB_FOG_SELECT_1_1_W         (4 << 0)
 #	define R300_GB_FOG_SELECT_Z		(5 << 0)
-#	define R300_GB_DEPTH_SELECT_Z		(0 << 3
+#	define R300_GB_DEPTH_SELECT_Z		(0 << 3)
 #	define R300_GB_DEPTH_SELECT_1_1_W	(1 << 3)
 #	define R300_GB_W_SELECT_1_W		(0 << 4)
 #	define R300_GB_W_SELECT_1		(1 << 4)
@@ -730,8 +730,8 @@ USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define R500_RS_IP_TEX_PTR_Q_SHIFT 			18
 #define R500_RS_IP_COL_PTR_SHIFT 			24
 #define R500_RS_IP_COL_FMT_SHIFT 			27
-#	define R500_RS_COL_PTR(x)		        (x << 24)
-#       define R500_RS_COL_FMT(x)                       (x << 27)
+#	define R500_RS_COL_PTR(x)		        ((x) << 24)
+#       define R500_RS_COL_FMT(x)                       ((x) << 27)
 /* gap */
 #define R500_RS_IP_OFFSET_DIS 				(0 << 31)
 #define R500_RS_IP_OFFSET_EN 				(1 << 31)
@@ -1172,9 +1172,9 @@ USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define R300_RS_IP_3				        0x431C
 #       define R300_RS_INTERP_SRC_SHIFT          2 /* TODO: check for removal */
 #       define R300_RS_INTERP_SRC_MASK           (7 << 2) /* TODO: check for removal */
-#	define R300_RS_TEX_PTR(x)		        (x << 0)
-#	define R300_RS_COL_PTR(x)		        (x << 6)
-#	define R300_RS_COL_FMT(x)		        (x << 9)
+#	define R300_RS_TEX_PTR(x)		        ((x) << 0)
+#	define R300_RS_COL_PTR(x)		        ((x) << 6)
+#	define R300_RS_COL_FMT(x)		        ((x) << 9)
 #	define R300_RS_COL_FMT_RGBA		        0
 #	define R300_RS_COL_FMT_RGB0		        1
 #	define R300_RS_COL_FMT_RGB1		        2
@@ -1184,10 +1184,10 @@ USE OR OTHER DEALINGS IN THE SOFTWARE.
 #	define R300_RS_COL_FMT_111A		        8
 #	define R300_RS_COL_FMT_1110		        9
 #	define R300_RS_COL_FMT_1111		        10
-#	define R300_RS_SEL_S(x)		                (x << 13)
-#	define R300_RS_SEL_T(x)		                (x << 16)
-#	define R300_RS_SEL_R(x)		                (x << 19)
-#	define R300_RS_SEL_Q(x)		                (x << 22)
+#	define R300_RS_SEL_S(x)		                ((x) << 13)
+#	define R300_RS_SEL_T(x)		                ((x) << 16)
+#	define R300_RS_SEL_R(x)		                ((x) << 19)
+#	define R300_RS_SEL_Q(x)		                ((x) << 22)
 #	define R300_RS_SEL_C0		                0
 #	define R300_RS_SEL_C1		                1
 #	define R300_RS_SEL_C2		                2
@@ -2705,7 +2705,7 @@ enum {
 #   define R500_ALPHA_OP_COS				13
 #   define R500_ALPHA_OP_MDH				14
 #   define R500_ALPHA_OP_MDV				15
-#   define R500_ALPHA_ADDRD(x)				(x << 4)
+#   define R500_ALPHA_ADDRD(x)				((x) << 4)
 #   define R500_ALPHA_ADDRD_REL				(1 << 11)
 #  define R500_ALPHA_SEL_A_SHIFT			12
 #   define R500_ALPHA_SEL_A_SRC0			(0 << 12)
@@ -2749,16 +2749,16 @@ enum {
 #   define R500_ALPHA_OMOD_DIV_4			(5 << 26)
 #   define R500_ALPHA_OMOD_DIV_8			(6 << 26)
 #   define R500_ALPHA_OMOD_DISABLE			(7 << 26)
-#   define R500_ALPHA_TARGET(x)				(x << 29)
+#   define R500_ALPHA_TARGET(x)				((x) << 29)
 #   define R500_ALPHA_W_OMASK				(1 << 31)
 #define R500_US_ALU_ALPHA_ADDR_0			0x9800
-#   define R500_ALPHA_ADDR0(x)				(x << 0)
+#   define R500_ALPHA_ADDR0(x)				((x) << 0)
 #   define R500_ALPHA_ADDR0_CONST			(1 << 8)
 #   define R500_ALPHA_ADDR0_REL				(1 << 9)
-#   define R500_ALPHA_ADDR1(x)				(x << 10)
+#   define R500_ALPHA_ADDR1(x)				((x) << 10)
 #   define R500_ALPHA_ADDR1_CONST			(1 << 18)
 #   define R500_ALPHA_ADDR1_REL				(1 << 19)
-#   define R500_ALPHA_ADDR2(x)				(x << 20)
+#   define R500_ALPHA_ADDR2(x)				((x) << 20)
 #   define R500_ALPHA_ADDR2_CONST			(1 << 28)
 #   define R500_ALPHA_ADDR2_REL				(1 << 29)
 #   define R500_ALPHA_SRCP_OP_1_MINUS_2A0		(0 << 30)
@@ -2779,7 +2779,7 @@ enum {
 #   define R500_ALU_RGBA_OP_SOP				(10 << 0)
 #   define R500_ALU_RGBA_OP_MDH				(11 << 0)
 #   define R500_ALU_RGBA_OP_MDV				(12 << 0)
-#   define R500_ALU_RGBA_ADDRD(x)			(x << 4)
+#   define R500_ALU_RGBA_ADDRD(x)			((x) << 4)
 #   define R500_ALU_RGBA_ADDRD_REL			(1 << 11)
 #  define R500_ALU_RGBA_SEL_C_SHIFT			12
 #   define R500_ALU_RGBA_SEL_C_SRC0			(0 << 12)
@@ -2906,16 +2906,16 @@ enum {
 #   define R500_ALU_RGB_OMOD_DIV_4			(5 << 26)
 #   define R500_ALU_RGB_OMOD_DIV_8			(6 << 26)
 #   define R500_ALU_RGB_OMOD_DISABLE			(7 << 26)
-#   define R500_ALU_RGB_TARGET(x)			(x << 29)
+#   define R500_ALU_RGB_TARGET(x)			((x) << 29)
 #   define R500_ALU_RGB_WMASK				(1 << 31)
 #define R500_US_ALU_RGB_ADDR_0				0x9000
-#   define R500_RGB_ADDR0(x)				(x << 0)
+#   define R500_RGB_ADDR0(x)				((x) << 0)
 #   define R500_RGB_ADDR0_CONST				(1 << 8)
 #   define R500_RGB_ADDR0_REL				(1 << 9)
-#   define R500_RGB_ADDR1(x)				(x << 10)
+#   define R500_RGB_ADDR1(x)				((x) << 10)
 #   define R500_RGB_ADDR1_CONST				(1 << 18)
 #   define R500_RGB_ADDR1_REL				(1 << 19)
-#   define R500_RGB_ADDR2(x)				(x << 20)
+#   define R500_RGB_ADDR2(x)				((x) << 20)
 #   define R500_RGB_ADDR2_CONST				(1 << 28)
 #   define R500_RGB_ADDR2_REL				(1 << 29)
 #   define R500_RGB_SRCP_OP_1_MINUS_2RGB0		(0 << 30)
@@ -2970,19 +2970,19 @@ enum {
 
 /* note that these are 8 bit lengths, despite the offsets, at least for R500 */
 #define R500_US_CODE_ADDR				0x4630
-#   define R500_US_CODE_START_ADDR(x)			(x << 0)
-#   define R500_US_CODE_END_ADDR(x)			(x << 16)
+#   define R500_US_CODE_START_ADDR(x)			((x) << 0)
+#   define R500_US_CODE_END_ADDR(x)			((x) << 16)
 #define R500_US_CODE_OFFSET				0x4638
-#   define R500_US_CODE_OFFSET_ADDR(x)			(x << 0)
+#   define R500_US_CODE_OFFSET_ADDR(x)			((x) << 0)
 #define R500_US_CODE_RANGE				0x4634
-#   define R500_US_CODE_RANGE_ADDR(x)			(x << 0)
-#   define R500_US_CODE_RANGE_SIZE(x)			(x << 16)
+#   define R500_US_CODE_RANGE_ADDR(x)			((x) << 0)
+#   define R500_US_CODE_RANGE_SIZE(x)			((x) << 16)
 #define R500_US_CONFIG					0x4600
 #   define R500_ZERO_TIMES_ANYTHING_EQUALS_ZERO		(1 << 1)
 #define R500_US_FC_ADDR_0				0xa000
-#   define R500_FC_BOOL_ADDR(x)				(x << 0)
-#   define R500_FC_INT_ADDR(x)				(x << 8)
-#   define R500_FC_JUMP_ADDR(x)				(x << 16)
+#   define R500_FC_BOOL_ADDR(x)				((x) << 0)
+#   define R500_FC_INT_ADDR(x)				((x) << 8)
+#   define R500_FC_JUMP_ADDR(x)				((x) << 16)
 #   define R500_FC_JUMP_GLOBAL				(1 << 31)
 #define R500_US_FC_BOOL_CONST				0x4620
 #   define R500_FC_KBOOL(x)				(x)
@@ -3003,8 +3003,8 @@ enum {
 #   define R500_FC_A_OP_NONE				(0 << 6)
 #   define R500_FC_A_OP_POP				(1 << 6)
 #   define R500_FC_A_OP_PUSH				(2 << 6)
-#   define R500_FC_JUMP_FUNC(x)				(x << 8)
-#   define R500_FC_B_POP_CNT(x)				(x << 16)
+#   define R500_FC_JUMP_FUNC(x)				((x) << 8)
+#   define R500_FC_B_POP_CNT(x)				((x) << 16)
 #   define R500_FC_B_OP0_NONE				(0 << 24)
 #   define R500_FC_B_OP0_DECR				(1 << 24)
 #   define R500_FC_B_OP0_INCR				(2 << 24)
@@ -3013,14 +3013,14 @@ enum {
 #   define R500_FC_B_OP1_INCR				(2 << 26)
 #   define R500_FC_IGNORE_UNCOVERED			(1 << 28)
 #define R500_US_FC_INT_CONST_0				0x4c00
-#   define R500_FC_INT_CONST_KR(x)			(x << 0)
-#   define R500_FC_INT_CONST_KG(x)			(x << 8)
-#   define R500_FC_INT_CONST_KB(x)			(x << 16)
+#   define R500_FC_INT_CONST_KR(x)			((x) << 0)
+#   define R500_FC_INT_CONST_KG(x)			((x) << 8)
+#   define R500_FC_INT_CONST_KB(x)			((x) << 16)
 /* _0 through _15 */
 #define R500_US_FORMAT0_0				0x4640
-#   define R500_FORMAT_TXWIDTH(x)			(x << 0)
-#   define R500_FORMAT_TXHEIGHT(x)			(x << 11)
-#   define R500_FORMAT_TXDEPTH(x)			(x << 22)
+#   define R500_FORMAT_TXWIDTH(x)			((x) << 0)
+#   define R500_FORMAT_TXHEIGHT(x)			((x) << 11)
+#   define R500_FORMAT_TXDEPTH(x)			((x) << 22)
 /* _0 through _3 */
 #define R500_US_OUT_FMT_0				0x46a4
 #   define R500_OUT_FMT_C4_8				(0 << 0)
@@ -3061,12 +3061,12 @@ enum {
 #   define R500_C3_SEL_R				(1 << 14)
 #   define R500_C3_SEL_G				(2 << 14)
 #   define R500_C3_SEL_B				(3 << 14)
-#   define R500_OUT_SIGN(x)				(x << 16)
+#   define R500_OUT_SIGN(x)				((x) << 16)
 #   define R500_ROUND_ADJ				(1 << 20)
 #define R500_US_PIXSIZE					0x4604
 #   define R500_PIX_SIZE(x)				(x)
 #define R500_US_TEX_ADDR_0				0x9800
-#   define R500_TEX_SRC_ADDR(x)				(x << 0)
+#   define R500_TEX_SRC_ADDR(x)				((x) << 0)
 #   define R500_TEX_SRC_ADDR_REL			(1 << 7)
 #   define R500_TEX_SRC_S_SWIZ_R			(0 << 8)
 #   define R500_TEX_SRC_S_SWIZ_G			(1 << 8)
@@ -3084,7 +3084,7 @@ enum {
 #   define R500_TEX_SRC_Q_SWIZ_G			(1 << 14)
 #   define R500_TEX_SRC_Q_SWIZ_B			(2 << 14)
 #   define R500_TEX_SRC_Q_SWIZ_A			(3 << 14)
-#   define R500_TEX_DST_ADDR(x)				(x << 16)
+#   define R500_TEX_DST_ADDR(x)				((x) << 16)
 #   define R500_TEX_DST_ADDR_REL			(1 << 23)
 #   define R500_TEX_DST_R_SWIZ_R			(0 << 24)
 #   define R500_TEX_DST_R_SWIZ_G			(1 << 24)
@@ -3103,7 +3103,7 @@ enum {
 #   define R500_TEX_DST_A_SWIZ_B			(2 << 30)
 #   define R500_TEX_DST_A_SWIZ_A			(3 << 30)
 #define R500_US_TEX_ADDR_DXDY_0				0xa000
-#   define R500_DX_ADDR(x)				(x << 0)
+#   define R500_DX_ADDR(x)				((x) << 0)
 #   define R500_DX_ADDR_REL				(1 << 7)
 #   define R500_DX_S_SWIZ_R				(0 << 8)
 #   define R500_DX_S_SWIZ_G				(1 << 8)
@@ -3121,7 +3121,7 @@ enum {
 #   define R500_DX_Q_SWIZ_G				(1 << 14)
 #   define R500_DX_Q_SWIZ_B				(2 << 14)
 #   define R500_DX_Q_SWIZ_A				(3 << 14)
-#   define R500_DY_ADDR(x)				(x << 16)
+#   define R500_DY_ADDR(x)				((x) << 16)
 #   define R500_DY_ADDR_REL				(1 << 17)
 #   define R500_DY_S_SWIZ_R				(0 << 24)
 #   define R500_DY_S_SWIZ_G				(1 << 24)
@@ -3140,7 +3140,7 @@ enum {
 #   define R500_DY_Q_SWIZ_B				(2 << 30)
 #   define R500_DY_Q_SWIZ_A				(3 << 30)
 #define R500_US_TEX_INST_0				0x9000
-#   define R500_TEX_ID(x)				(x << 16)
+#   define R500_TEX_ID(x)				((x) << 16)
 #   define R500_TEX_INST_NOP				(0 << 22)
 #   define R500_TEX_INST_LD				(1 << 22)
 #   define R500_TEX_INST_TEXKILL			(2 << 22)
diff --git a/src/mesa/drivers/dri/r300/r300_render.c b/src/mesa/drivers/dri/r300/r300_render.c
index f9266e4..16ce4a1 100644
--- a/src/mesa/drivers/dri/r300/r300_render.c
+++ b/src/mesa/drivers/dri/r300/r300_render.c
@@ -347,6 +347,8 @@ static GLboolean r300RunRender(GLcontext * ctx,
 static int r300Fallback(GLcontext * ctx)
 {
 	r300ContextPtr r300 = R300_CONTEXT(ctx);
+	const unsigned back = ctx->Stencil._BackFace;
+
 	/* Do we need to use new-style shaders?
 	 * Also is there a better way to do this? */
 	if (r300->radeon.radeonScreen->chip_family >= CHIP_FAMILY_RV515) {
@@ -371,12 +373,14 @@ static int r300Fallback(GLcontext * ctx)
 
 	FALLBACK_IF(ctx->RenderMode != GL_RENDER);
 
-	FALLBACK_IF(ctx->Stencil._TestTwoSide
-		    && (ctx->Stencil.Ref[0] != ctx->Stencil.Ref[1]
-			|| ctx->Stencil.ValueMask[0] !=
-			ctx->Stencil.ValueMask[1]
-			|| ctx->Stencil.WriteMask[0] !=
-			ctx->Stencil.WriteMask[1]));
+	/* If GL_EXT_stencil_two_side is disabled, this fallback check can
+	 * be removed.
+	 */
+	FALLBACK_IF(ctx->Stencil.Ref[0] != ctx->Stencil.Ref[back]
+		    || ctx->Stencil.ValueMask[0] !=
+		    ctx->Stencil.ValueMask[back]
+		    || ctx->Stencil.WriteMask[0] !=
+		    ctx->Stencil.WriteMask[back]);
 
 	if (ctx->Extensions.NV_point_sprite || ctx->Extensions.ARB_point_sprite)
 		FALLBACK_IF(ctx->Point.PointSprite);
diff --git a/src/mesa/drivers/dri/r300/r300_state.c b/src/mesa/drivers/dri/r300/r300_state.c
index a63dbac..ade45f5 100644
--- a/src/mesa/drivers/dri/r300/r300_state.c
+++ b/src/mesa/drivers/dri/r300/r300_state.c
@@ -783,6 +783,7 @@ static void r300Fogfv(GLcontext * ctx, GLenum pname, const GLfloat * param)
 			    R300_FG_FOG_BLEND_FN_EXP2;
 			fogScale.f = 0.3 * ctx->Fog.Density;
 			fogStart.f = 0.0;
+                        break;
 		default:
 			return;
 		}
@@ -974,15 +975,9 @@ static void r300StencilFuncSeparate(GLcontext * ctx, GLenum face,
 {
 	r300ContextPtr rmesa = R300_CONTEXT(ctx);
 	GLuint refmask =
-	    (((ctx->Stencil.
-	       Ref[0] & 0xff) << R300_STENCILREF_SHIFT) | ((ctx->
-							    Stencil.
-							    ValueMask
-							    [0] &
-							    0xff)
-							   <<
-							   R300_STENCILMASK_SHIFT));
-
+	    ((ctx->Stencil.Ref[0] & 0xff) << R300_STENCILREF_SHIFT)
+	     | ((ctx->Stencil.ValueMask[0] & 0xff) << R300_STENCILMASK_SHIFT);
+	const unsigned back = ctx->Stencil._BackFace;
 	GLuint flag;
 
 	R300_STATECHANGE(rmesa, zs);
@@ -1000,8 +995,7 @@ static void r300StencilFuncSeparate(GLcontext * ctx, GLenum face,
 	rmesa->hw.zs.cmd[R300_ZS_CNTL_1] |=
 	    (flag << R300_S_FRONT_FUNC_SHIFT);
 
-	if (ctx->Stencil._TestTwoSide)
-		flag = translate_func(ctx->Stencil.Function[1]);
+	flag = translate_func(ctx->Stencil.Function[back]);
 
 	rmesa->hw.zs.cmd[R300_ZS_CNTL_1] |=
 	    (flag << R300_S_BACK_FUNC_SHIFT);
@@ -1026,6 +1020,7 @@ static void r300StencilOpSeparate(GLcontext * ctx, GLenum face,
 				  GLenum fail, GLenum zfail, GLenum zpass)
 {
 	r300ContextPtr rmesa = R300_CONTEXT(ctx);
+	const unsigned back = ctx->Stencil._BackFace;
 
 	R300_STATECHANGE(rmesa, zs);
 	/* It is easier to mask what's left.. */
@@ -1042,23 +1037,13 @@ static void r300StencilOpSeparate(GLcontext * ctx, GLenum face,
 	    | (translate_stencil_op(ctx->Stencil.ZPassFunc[0]) <<
 	       R300_S_FRONT_ZPASS_OP_SHIFT);
 
-	if (ctx->Stencil._TestTwoSide) {
-		rmesa->hw.zs.cmd[R300_ZS_CNTL_1] |=
-		    (translate_stencil_op(ctx->Stencil.FailFunc[1]) <<
-		     R300_S_BACK_SFAIL_OP_SHIFT)
-		    | (translate_stencil_op(ctx->Stencil.ZFailFunc[1]) <<
-		       R300_S_BACK_ZFAIL_OP_SHIFT)
-		    | (translate_stencil_op(ctx->Stencil.ZPassFunc[1]) <<
-		       R300_S_BACK_ZPASS_OP_SHIFT);
-	} else {
-		rmesa->hw.zs.cmd[R300_ZS_CNTL_1] |=
-		    (translate_stencil_op(ctx->Stencil.FailFunc[0]) <<
-		     R300_S_BACK_SFAIL_OP_SHIFT)
-		    | (translate_stencil_op(ctx->Stencil.ZFailFunc[0]) <<
-		       R300_S_BACK_ZFAIL_OP_SHIFT)
-		    | (translate_stencil_op(ctx->Stencil.ZPassFunc[0]) <<
-		       R300_S_BACK_ZPASS_OP_SHIFT);
-	}
+	rmesa->hw.zs.cmd[R300_ZS_CNTL_1] |=
+	    (translate_stencil_op(ctx->Stencil.FailFunc[back]) <<
+	     R300_S_BACK_SFAIL_OP_SHIFT)
+	    | (translate_stencil_op(ctx->Stencil.ZFailFunc[back]) <<
+	       R300_S_BACK_ZFAIL_OP_SHIFT)
+	    | (translate_stencil_op(ctx->Stencil.ZPassFunc[back]) <<
+	       R300_S_BACK_ZPASS_OP_SHIFT);
 }
 
 /* =============================================================
diff --git a/src/mesa/drivers/dri/r300/r500_fragprog.c b/src/mesa/drivers/dri/r300/r500_fragprog.c
index 75dae86..926ddd5 100644
--- a/src/mesa/drivers/dri/r300/r500_fragprog.c
+++ b/src/mesa/drivers/dri/r300/r500_fragprog.c
@@ -31,6 +31,12 @@
 #include "radeon_program_alu.h"
 
 
+static void reset_srcreg(struct prog_src_register* reg)
+{
+	_mesa_bzero(reg, sizeof(*reg));
+	reg->Swizzle = SWIZZLE_NOOP;
+}
+
 static struct prog_src_register shadow_ambient(struct gl_program *program, int tmu)
 {
 	gl_state_index fail_value_tokens[STATE_LENGTH] = {
@@ -99,6 +105,19 @@ static GLboolean transform_TEX(
 		destredirect = GL_TRUE;
 	}
 
+	if (inst.SrcReg[0].File != PROGRAM_TEMPORARY && inst.SrcReg[0].File != PROGRAM_INPUT) {
+		int tmpreg = radeonFindFreeTemporary(t);
+		tgt = radeonAppendInstructions(t->Program, 1);
+		tgt->Opcode = OPCODE_MOV;
+		tgt->DstReg.File = PROGRAM_TEMPORARY;
+		tgt->DstReg.Index = tmpreg;
+		tgt->SrcReg[0] = inst.SrcReg[0];
+
+		reset_srcreg(&inst.SrcReg[0]);
+		inst.SrcReg[0].File = PROGRAM_TEMPORARY;
+		inst.SrcReg[0].Index = tmpreg;
+	}
+
 	tgt = radeonAppendInstructions(t->Program, 1);
 	_mesa_copy_instructions(tgt, &inst, 1);
 
diff --git a/src/mesa/drivers/dri/radeon/radeon_chipset.h b/src/mesa/drivers/dri/radeon/radeon_chipset.h
index 55a73ea..f6bd1eb 100644
--- a/src/mesa/drivers/dri/radeon/radeon_chipset.h
+++ b/src/mesa/drivers/dri/radeon/radeon_chipset.h
@@ -247,6 +247,9 @@
 #define PCI_CHIP_RS350_7835		0x7835
 #define PCI_CHIP_RS690_791E             0x791E
 #define PCI_CHIP_RS690_791F             0x791F
+#define PCI_CHIP_RS600_793F             0x793F
+#define PCI_CHIP_RS600_7941             0x7941
+#define PCI_CHIP_RS600_7942             0x7942
 #define PCI_CHIP_RS740_796C             0x796C
 #define PCI_CHIP_RS740_796D             0x796D
 #define PCI_CHIP_RS740_796E             0x796E
@@ -270,6 +273,7 @@ enum {
    CHIP_FAMILY_R420,
    CHIP_FAMILY_RV410,
    CHIP_FAMILY_RS400,
+   CHIP_FAMILY_RS600,
    CHIP_FAMILY_RS690,
    CHIP_FAMILY_RS740,
    CHIP_FAMILY_RV515,
diff --git a/src/mesa/drivers/dri/radeon/radeon_context.c b/src/mesa/drivers/dri/radeon/radeon_context.c
index 1e992c0..ea81a32 100644
--- a/src/mesa/drivers/dri/radeon/radeon_context.c
+++ b/src/mesa/drivers/dri/radeon/radeon_context.c
@@ -62,9 +62,6 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "radeon_tcl.h"
 #include "radeon_maos.h"
 
-#define need_GL_ARB_multisample
-#define need_GL_ARB_texture_compression
-#define need_GL_ARB_vertex_buffer_object
 #define need_GL_EXT_blend_minmax
 #define need_GL_EXT_fog_coord
 #define need_GL_EXT_secondary_color
@@ -114,16 +111,13 @@ static const GLubyte *radeonGetString( GLcontext *ctx, GLenum name )
  */
 const struct dri_extension card_extensions[] =
 {
-    { "GL_ARB_multisample",                GL_ARB_multisample_functions },
     { "GL_ARB_multitexture",               NULL },
     { "GL_ARB_texture_border_clamp",       NULL },
-    { "GL_ARB_texture_compression",        GL_ARB_texture_compression_functions },
     { "GL_ARB_texture_env_add",            NULL },
     { "GL_ARB_texture_env_combine",        NULL },
     { "GL_ARB_texture_env_crossbar",       NULL },
     { "GL_ARB_texture_env_dot3",           NULL },
     { "GL_ARB_texture_mirrored_repeat",    NULL },
-    { "GL_ARB_vertex_buffer_object",       GL_ARB_vertex_buffer_object_functions },
     { "GL_EXT_blend_logic_op",             NULL },
     { "GL_EXT_blend_subtract",             GL_EXT_blend_minmax_functions },
     { "GL_EXT_fog_coord",                  GL_EXT_fog_coord_functions },
@@ -359,6 +353,8 @@ radeonCreateContext( const __GLcontextModes *glVisual,
 
    rmesa->boxes = 0;
 
+   ctx->Const.MaxDrawBuffers = 1;
+
    /* Initialize the software rasterizer and helper modules.
     */
    _swrast_CreateContext( ctx );
diff --git a/src/mesa/drivers/dri/radeon/radeon_maos_arrays.c b/src/mesa/drivers/dri/radeon/radeon_maos_arrays.c
index de3c3a1..31eea13 100644
--- a/src/mesa/drivers/dri/radeon/radeon_maos_arrays.c
+++ b/src/mesa/drivers/dri/radeon/radeon_maos_arrays.c
@@ -40,7 +40,6 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "swrast_setup/swrast_setup.h"
 #include "math/m_translate.h"
 #include "tnl/tnl.h"
-#include "tnl/tcontext.h"
 
 #include "radeon_context.h"
 #include "radeon_ioctl.h"
diff --git a/src/mesa/drivers/dri/radeon/radeon_screen.c b/src/mesa/drivers/dri/radeon/radeon_screen.c
index 5f32dd5..f7cba50 100644
--- a/src/mesa/drivers/dri/radeon/radeon_screen.c
+++ b/src/mesa/drivers/dri/radeon/radeon_screen.c
@@ -206,6 +206,8 @@ DRI_CONF_BEGIN
 DRI_CONF_END;
 static const GLuint __driNConfigOptions = 17;
 
+extern const struct dri_extension gl_20_extension[];
+
 #ifndef RADEON_DEBUG
 int RADEON_DEBUG = 0;
 
@@ -274,7 +276,7 @@ radeonFillInModes( __DRIscreenPrivate *psp,
 
     uint8_t depth_bits_array[2];
     uint8_t stencil_bits_array[2];
-
+    uint8_t msaa_samples_array[1];
 
     depth_bits_array[0] = depth_bits;
     depth_bits_array[1] = depth_bits;
@@ -286,6 +288,8 @@ radeonFillInModes( __DRIscreenPrivate *psp,
     stencil_bits_array[0] = 0;
     stencil_bits_array[1] = (stencil_bits == 0) ? 8 : stencil_bits;
 
+    msaa_samples_array[0] = 0;
+
     depth_buffer_factor = ((depth_bits != 0) || (stencil_bits != 0)) ? 2 : 1;
     back_buffer_factor  = (have_back_buffer) ? 2 : 1;
 
@@ -301,7 +305,8 @@ radeonFillInModes( __DRIscreenPrivate *psp,
     configs = driCreateConfigs(fb_format, fb_type,
 			       depth_bits_array, stencil_bits_array,
 			       depth_buffer_factor,
-			       back_buffer_modes, back_buffer_factor);
+			       back_buffer_modes, back_buffer_factor,
+			       msaa_samples_array, 1);
     if (configs == NULL) {
 	fprintf( stderr, "[%s:%u] Error creating FBConfig!\n",
 		 __func__, __LINE__ );
@@ -680,6 +685,12 @@ radeonCreateScreen( __DRIscreenPrivate *sPriv )
       screen->chip_family = CHIP_FAMILY_RS400;
       break;
 
+   case PCI_CHIP_RS600_793F:
+   case PCI_CHIP_RS600_7941:
+   case PCI_CHIP_RS600_7942:
+      screen->chip_family = CHIP_FAMILY_RS600;
+      break;
+
    case PCI_CHIP_RS690_791E:
    case PCI_CHIP_RS690_791F:
       screen->chip_family = CHIP_FAMILY_RS690;
@@ -838,7 +849,7 @@ radeonCreateScreen( __DRIscreenPrivate *sPriv )
    ret = radeonGetParam( sPriv->fd, RADEON_PARAM_FB_LOCATION,
                          &temp);
    if (ret) {
-       if (screen->chip_family < CHIP_FAMILY_RS690)
+       if (screen->chip_family < CHIP_FAMILY_RS600)
 	   screen->fbLocation      = ( INREG( RADEON_MC_FB_LOCATION ) & 0xffff) << 16;
        else {
            FREE( screen );
@@ -849,7 +860,7 @@ radeonCreateScreen( __DRIscreenPrivate *sPriv )
        screen->fbLocation = (temp & 0xffff) << 16;
    }
 
-   if (screen->chip_family >= CHIP_FAMILY_RV515) {
+   if (screen->chip_family >= CHIP_FAMILY_R300) {
        ret = radeonGetParam( sPriv->fd, RADEON_PARAM_NUM_GB_PIPES,
 			     &temp);
        if (ret) {
@@ -1140,6 +1151,7 @@ static void radeonDestroyContext(__DRIcontextPrivate * driContextPriv)
 
 #endif
 
+
 /**
  * This is the driver specific part of the createNewScreen entry point.
  *
@@ -1192,6 +1204,8 @@ radeonInitScreen(__DRIscreenPrivate *psp)
    driInitSingleExtension( NULL, NV_vp_extension );
    driInitSingleExtension( NULL, ATI_fs_extension );
    driInitExtensions( NULL, point_extensions, GL_FALSE );
+#elif defined(RADEON_COMMON_FOR_R300)
+   driInitSingleExtension( NULL, gl_20_extension );
 #endif
 
    if (!radeonInitDriver(psp))
diff --git a/src/mesa/drivers/dri/radeon/radeon_texstate.c b/src/mesa/drivers/dri/radeon/radeon_texstate.c
index 1e2f654..b165205 100644
--- a/src/mesa/drivers/dri/radeon/radeon_texstate.c
+++ b/src/mesa/drivers/dri/radeon/radeon_texstate.c
@@ -1023,11 +1023,11 @@ static GLboolean radeon_validate_texgen( GLcontext *ctx, GLuint unit )
     */
    else if ( (texUnit->TexGenEnabled & S_BIT) &&
 	     (texUnit->TexGenEnabled & T_BIT) &&
-	     (texUnit->GenModeS == texUnit->GenModeT) ) {
+	     (texUnit->GenS.Mode == texUnit->GenT.Mode) ) {
       if ( ((texUnit->TexGenEnabled & R_BIT) &&
-	    (texUnit->GenModeS != texUnit->GenModeR)) ||
+	    (texUnit->GenS.Mode != texUnit->GenR.Mode)) ||
 	   ((texUnit->TexGenEnabled & Q_BIT) &&
-	    (texUnit->GenModeS != texUnit->GenModeQ)) ) {
+	    (texUnit->GenS.Mode != texUnit->GenQ.Mode)) ) {
 	 /* Mixed modes, fallback:
 	  */
 	 if (RADEON_DEBUG & DEBUG_FALLBACKS)
@@ -1051,23 +1051,23 @@ static GLboolean radeon_validate_texgen( GLcontext *ctx, GLuint unit )
       rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXFMT] |= RADEON_Q_BIT(unit);
    }
 
-   switch (texUnit->GenModeS) {
+   switch (texUnit->GenS.Mode) {
    case GL_OBJECT_LINEAR:
       rmesa->TexGenEnabled |= RADEON_TEXGEN_INPUT_OBJ << inputshift;
       set_texgen_matrix( rmesa, unit,
-			 texUnit->ObjectPlaneS,
-			 texUnit->ObjectPlaneT,
-			 texUnit->ObjectPlaneR,
-			 texUnit->ObjectPlaneQ);
+			 texUnit->GenS.ObjectPlane,
+			 texUnit->GenT.ObjectPlane,
+			 texUnit->GenR.ObjectPlane,
+			 texUnit->GenQ.ObjectPlane);
       break;
 
    case GL_EYE_LINEAR:
       rmesa->TexGenEnabled |= RADEON_TEXGEN_INPUT_EYE << inputshift;
       set_texgen_matrix( rmesa, unit,
-			 texUnit->EyePlaneS,
-			 texUnit->EyePlaneT,
-			 texUnit->EyePlaneR,
-			 texUnit->EyePlaneQ);
+			 texUnit->GenS.EyePlane,
+			 texUnit->GenT.EyePlane,
+			 texUnit->GenR.EyePlane,
+			 texUnit->GenQ.EyePlane);
       break;
 
    case GL_REFLECTION_MAP_NV:
diff --git a/src/mesa/drivers/dri/s3v/s3v_context.c b/src/mesa/drivers/dri/s3v/s3v_context.c
index 14502f9..0a3bf72 100644
--- a/src/mesa/drivers/dri/s3v/s3v_context.c
+++ b/src/mesa/drivers/dri/s3v/s3v_context.c
@@ -108,6 +108,8 @@ GLboolean s3vCreateContext(const __GLcontextModes *glVisual,
 	ctx->Const.MaxLineWidthAA = 1.0;
 	ctx->Const.LineWidthGranularity = 1.0;
 
+	ctx->Const.MaxDrawBuffers = 1;
+
 	vmesa->texHeap = mmInit( 0, vmesa->s3vScreen->textureSize );
 	DEBUG(("vmesa->s3vScreen->textureSize = 0x%x\n",
 		vmesa->s3vScreen->textureSize));
diff --git a/src/mesa/drivers/dri/savage/savage_xmesa.c b/src/mesa/drivers/dri/savage/savage_xmesa.c
index a344aab..326d595 100644
--- a/src/mesa/drivers/dri/savage/savage_xmesa.c
+++ b/src/mesa/drivers/dri/savage/savage_xmesa.c
@@ -59,9 +59,6 @@
 #include "drirenderbuffer.h"
 #include "texmem.h"
 
-#define need_GL_ARB_multisample
-#define need_GL_ARB_texture_compression
-#define need_GL_ARB_vertex_buffer_object
 #define need_GL_EXT_secondary_color
 #include "extension_helper.h"
 
@@ -133,10 +130,7 @@ struct timeval tv_s1,tv_f1;
 
 static const struct dri_extension card_extensions[] =
 {
-    { "GL_ARB_multisample",                GL_ARB_multisample_functions },
     { "GL_ARB_multitexture",               NULL },
-    { "GL_ARB_texture_compression",        GL_ARB_texture_compression_functions },
-    { "GL_ARB_vertex_buffer_object",       GL_ARB_vertex_buffer_object_functions },
     { "GL_EXT_stencil_wrap",               NULL },
     { "GL_EXT_texture_lod_bias",           NULL },
     { "GL_EXT_secondary_color",            GL_EXT_secondary_color_functions },
@@ -350,7 +344,9 @@ savageCreateContext( const __GLcontextModes *mesaVis,
    ctx->Const.MaxLineWidthAA = 3.0;
    ctx->Const.LineWidthGranularity = 1.0;
 #endif
-   
+
+   ctx->Const.MaxDrawBuffers = 1;
+
    /* Dri stuff
     */
    imesa->hHWContext = driContextPriv->hHWContext;
@@ -914,7 +910,7 @@ savageFillInModes( __DRIscreenPrivate *psp,
 
     uint8_t depth_bits_array[2];
     uint8_t stencil_bits_array[2];
-
+    uint8_t msaa_samples_array[1];
 
     depth_bits_array[0] = depth_bits;
     depth_bits_array[1] = depth_bits;
@@ -926,6 +922,8 @@ savageFillInModes( __DRIscreenPrivate *psp,
     stencil_bits_array[0] = 0;
     stencil_bits_array[1] = (stencil_bits == 0) ? 8 : stencil_bits;
 
+    msaa_samples_array[0] = 0;
+
     depth_buffer_factor = ((depth_bits != 0) || (stencil_bits != 0)) ? 2 : 1;
     back_buffer_factor  = (have_back_buffer) ? 2 : 1;
 
@@ -941,7 +939,8 @@ savageFillInModes( __DRIscreenPrivate *psp,
     configs = driCreateConfigs(fb_format, fb_type,
 			       depth_bits_array, stencil_bits_array,
 			       depth_buffer_factor,
-			       back_buffer_modes, back_buffer_factor);
+			       back_buffer_modes, back_buffer_factor,
+                               msaa_samples_array, 1);
     if (configs == NULL) {
 	fprintf( stderr, "[%s:%u] Error creating FBConfig!\n",
 		 __func__, __LINE__ );
diff --git a/src/mesa/drivers/dri/sis/sis_alloc.c b/src/mesa/drivers/dri/sis/sis_alloc.c
index 4ca4052..ce34e44 100644
--- a/src/mesa/drivers/dri/sis/sis_alloc.c
+++ b/src/mesa/drivers/dri/sis/sis_alloc.c
@@ -137,7 +137,7 @@ sisAllocZStencilBuffer( sisContextPtr smesa )
 {
    int cpp = ( smesa->glCtx->Visual.depthBits +
                smesa->glCtx->Visual.stencilBits ) / 8;
-   unsigned char *addr;
+   char *addr;
 
    smesa->depth.bpp = cpp * 8;
    smesa->depth.pitch = ALIGNMENT(smesa->driDrawable->w * cpp, 4);
@@ -150,7 +150,7 @@ sisAllocZStencilBuffer( sisContextPtr smesa )
    addr = (char *)ALIGNMENT((unsigned long)addr, Z_BUFFER_HW_ALIGNMENT);
 
    smesa->depth.map = addr;
-   smesa->depth.offset = addr - smesa->FbBase;
+   smesa->depth.offset = addr - (char *)smesa->FbBase;
 
    /* stencil buffer is same as depth buffer */
    smesa->stencil.size = smesa->depth.size;
@@ -173,7 +173,7 @@ void
 sisAllocBackbuffer( sisContextPtr smesa )
 {
    int cpp = smesa->bytesPerPixel;
-   unsigned char *addr;
+   char *addr;
 
    smesa->back.bpp = smesa->bytesPerPixel * 8;
    smesa->back.pitch = ALIGNMENT(smesa->driDrawable->w * cpp, 4);
@@ -186,7 +186,7 @@ sisAllocBackbuffer( sisContextPtr smesa )
    addr = (char *)ALIGNMENT((unsigned long)addr, DRAW_BUFFER_HW_ALIGNMENT);
 
    smesa->back.map = addr;
-   smesa->back.offset = addr - smesa->FbBase;
+   smesa->back.offset = addr - (char *)smesa->FbBase;
 }
 
 void
diff --git a/src/mesa/drivers/dri/sis/sis_context.c b/src/mesa/drivers/dri/sis/sis_context.c
index 00d17da..a070fe3 100644
--- a/src/mesa/drivers/dri/sis/sis_context.c
+++ b/src/mesa/drivers/dri/sis/sis_context.c
@@ -57,9 +57,6 @@ USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "tnl/tnl.h"
 #include "tnl/t_pipeline.h"
 
-#define need_GL_ARB_multisample
-#define need_GL_ARB_texture_compression
-#define need_GL_ARB_vertex_buffer_object
 #define need_GL_EXT_fog_coord
 #define need_GL_EXT_secondary_color
 #include "extension_helper.h"
@@ -74,12 +71,9 @@ int GlobalCmdQueueLen = 0;
 
 struct dri_extension card_extensions[] =
 {
-    { "GL_ARB_multisample",                GL_ARB_multisample_functions },
     { "GL_ARB_multitexture",               NULL },
     { "GL_ARB_texture_border_clamp",       NULL },
-    { "GL_ARB_texture_compression",        GL_ARB_texture_compression_functions },
     { "GL_ARB_texture_mirrored_repeat",    NULL },
-    { "GL_ARB_vertex_buffer_object",       GL_ARB_vertex_buffer_object_functions },
     /*{ "GL_EXT_fog_coord",                  GL_EXT_fog_coord_functions },*/
     { "GL_EXT_texture_lod_bias",           NULL },
     { "GL_EXT_secondary_color",            GL_EXT_secondary_color_functions },
@@ -91,9 +85,7 @@ struct dri_extension card_extensions[] =
 
 struct dri_extension card_extensions_6326[] =
 {
-    { "GL_ARB_multisample",                GL_ARB_multisample_functions },
     /*{ "GL_ARB_texture_border_clamp",       NULL },*/
-    { "GL_ARB_texture_compression",        GL_ARB_texture_compression_functions },
     /*{ "GL_ARB_texture_mirrored_repeat",    NULL },*/
     /*{ "GL_MESA_ycbcr_texture",             NULL },*/
     { NULL,                                NULL }
diff --git a/src/mesa/drivers/dri/sis/sis_screen.c b/src/mesa/drivers/dri/sis/sis_screen.c
index b1a5d15..9eb27fe 100644
--- a/src/mesa/drivers/dri/sis/sis_screen.c
+++ b/src/mesa/drivers/dri/sis/sis_screen.c
@@ -77,6 +77,7 @@ sisFillInModes(__DRIscreenPrivate *psp, int bpp)
    };
    uint8_t depth_bits_array[4];
    uint8_t stencil_bits_array[4];
+   uint8_t msaa_samples_array[1];
 
    depth_bits_array[0] = 0;
    stencil_bits_array[0] = 0;
@@ -87,6 +88,8 @@ sisFillInModes(__DRIscreenPrivate *psp, int bpp)
    depth_bits_array[3] = 32;
    stencil_bits_array[3] = 0;
 
+   msaa_samples_array[0] = 0;
+
    depth_buffer_factor = 4;
    back_buffer_factor = 2;
 
@@ -100,7 +103,8 @@ sisFillInModes(__DRIscreenPrivate *psp, int bpp)
 
    configs = driCreateConfigs(fb_format, fb_type, depth_bits_array,
 			      stencil_bits_array, depth_buffer_factor,
-			      back_buffer_modes, back_buffer_factor);
+			      back_buffer_modes, back_buffer_factor,
+                              msaa_samples_array, 1);
    if (configs == NULL) {
       fprintf(stderr, "[%s:%u] Error creating FBConfig!\n", __func__, __LINE__);
       return NULL;
diff --git a/src/mesa/drivers/dri/sis/sis_tris.c b/src/mesa/drivers/dri/sis/sis_tris.c
index 095941a..76d12d0 100644
--- a/src/mesa/drivers/dri/sis/sis_tris.c
+++ b/src/mesa/drivers/dri/sis/sis_tris.c
@@ -994,7 +994,7 @@ sisFlushPrimsLocked(sisContextPtr smesa)
 	 MMIO(REG_3D_PrimitiveSet, smesa->dwPrimitiveSet);
       }
       while (smesa->vb_last < smesa->vb_cur) {
-	 sis_emit_func(smesa, smesa->vb_last);
+	 sis_emit_func(smesa, (char *)smesa->vb_last);
 	 smesa->vb_last += incr;
       }
       mWait3DCmdQueue(1);
diff --git a/src/mesa/drivers/dri/swrast/swrast.c b/src/mesa/drivers/dri/swrast/swrast.c
index 15b5724..2e7f113 100644
--- a/src/mesa/drivers/dri/swrast/swrast.c
+++ b/src/mesa/drivers/dri/swrast/swrast.c
@@ -72,7 +72,7 @@
 #define need_GL_EXT_framebuffer_blit
 #define need_GL_EXT_gpu_program_parameters
 #define need_GL_EXT_paletted_texture
-#define need_GL_IBM_multimode_draw_arrays
+#define need_GL_EXT_stencil_two_side
 #define need_GL_MESA_resize_buffers
 #define need_GL_NV_vertex_program
 #define need_GL_NV_fragment_program
@@ -103,7 +103,7 @@ const struct dri_extension card_extensions[] =
     { "GL_EXT_framebuffer_blit",	GL_EXT_framebuffer_blit_functions },
     { "GL_EXT_gpu_program_parameters",	GL_EXT_gpu_program_parameters_functions },
     { "GL_EXT_paletted_texture",	GL_EXT_paletted_texture_functions },
-    { "GL_IBM_multimode_draw_arrays",	GL_IBM_multimode_draw_arrays_functions },
+    { "GL_EXT_stencil_two_side",	GL_EXT_stencil_two_side_functions },
     { "GL_MESA_resize_buffers",		GL_MESA_resize_buffers_functions },
     { "GL_NV_vertex_program",		GL_NV_vertex_program_functions },
     { "GL_NV_fragment_program",		GL_NV_fragment_program_functions },
@@ -147,6 +147,7 @@ swrastFillInModes(__DRIscreen *psp,
 
     uint8_t depth_bits_array[4];
     uint8_t stencil_bits_array[4];
+    uint8_t msaa_samples_array[1];
 
     depth_bits_array[0] = 0;
     depth_bits_array[1] = 0;
@@ -161,26 +162,38 @@ swrastFillInModes(__DRIscreen *psp,
     stencil_bits_array[2] = 0;
     stencil_bits_array[3] = (stencil_bits == 0) ? 8 : stencil_bits;
 
+    msaa_samples_array[0] = 0;
+
     depth_buffer_factor = 4;
     back_buffer_factor = 2;
 
-    if (pixel_bits == 8) {
+    switch (pixel_bits) {
+    case 8:
 	fb_format = GL_RGB;
 	fb_type = GL_UNSIGNED_BYTE_2_3_3_REV;
-    }
-    else if (pixel_bits == 16) {
+	break;
+    case 16:
 	fb_format = GL_RGB;
 	fb_type = GL_UNSIGNED_SHORT_5_6_5;
-    }
-    else {
+	break;
+    case 24:
+	fb_format = GL_BGR;
+	fb_type = GL_UNSIGNED_INT_8_8_8_8_REV;
+	break;
+    case 32:
 	fb_format = GL_BGRA;
 	fb_type = GL_UNSIGNED_INT_8_8_8_8_REV;
+	break;
+    default:
+	fprintf(stderr, "[%s:%u] bad depth %d\n", __func__, __LINE__,
+		pixel_bits);
+	return NULL;
     }
 
     configs = driCreateConfigs(fb_format, fb_type,
 			       depth_bits_array, stencil_bits_array,
 			       depth_buffer_factor, back_buffer_modes,
-			       back_buffer_factor);
+			       back_buffer_factor, msaa_samples_array, 1);
     if (configs == NULL) {
 	fprintf(stderr, "[%s:%u] Error creating FBConfig!\n", __func__,
 		__LINE__);
@@ -196,7 +209,7 @@ driCreateNewScreen(int scrn, const __DRIextension **extensions,
 {
     static const __DRIextension *emptyExtensionList[] = { NULL };
     __DRIscreen *psp;
-    __DRIconfig **configs8, **configs16, **configs32;
+    __DRIconfig **configs8, **configs16, **configs24, **configs32;
 
     (void) data;
 
@@ -213,11 +226,13 @@ driCreateNewScreen(int scrn, const __DRIextension **extensions,
 
     configs8  = swrastFillInModes(psp,  8,  8, 0, 1);
     configs16 = swrastFillInModes(psp, 16, 16, 0, 1);
+    configs24 = swrastFillInModes(psp, 24, 24, 8, 1);
     configs32 = swrastFillInModes(psp, 32, 24, 8, 1);
 
-    configs16 = (__DRIconfig **)driConcatConfigs(configs8, configs16);
-
-    *driver_configs = driConcatConfigs(configs16, configs32);
+    configs16 = driConcatConfigs(configs8, configs16);
+    configs24 = driConcatConfigs(configs16, configs24);
+    *driver_configs = (const __DRIconfig **)
+       driConcatConfigs(configs24, configs32);
 
     driInitExtensions( NULL, card_extensions, GL_FALSE );
 
@@ -249,19 +264,24 @@ static GLuint
 choose_pixel_format(const GLvisual *v)
 {
     if (v->rgbMode) {
-	int bpp = v->rgbBits;
+	int depth = v->rgbBits;
 
-	if (bpp == 32
+	if (depth == 32
 	    && v->redMask   == 0xff0000
 	    && v->greenMask == 0x00ff00
 	    && v->blueMask  == 0x0000ff)
 	    return PF_A8R8G8B8;
-	else if (bpp == 16
+	else if (depth == 24
+	    && v->redMask   == 0xff0000
+	    && v->greenMask == 0x00ff00
+	    && v->blueMask  == 0x0000ff)
+	    return PF_X8R8G8B8;
+	else if (depth == 16
 	    && v->redMask   == 0xf800
 	    && v->greenMask == 0x07e0
 	    && v->blueMask  == 0x001f)
 	    return PF_R5G6B5;
-	else if (bpp == 8
+	else if (depth == 8
 	    && v->redMask   == 0x07
 	    && v->greenMask == 0x38
 	    && v->blueMask  == 0xc0)
@@ -290,7 +310,6 @@ swrast_alloc_front_storage(GLcontext *ctx, struct gl_renderbuffer *rb,
 			   GLenum internalFormat, GLuint width, GLuint height)
 {
     struct swrast_renderbuffer *xrb = swrast_renderbuffer(rb);
-    int bpp;
     unsigned mask = PITCH_ALIGN_BITS - 1;
 
     TRACE;
@@ -299,23 +318,8 @@ swrast_alloc_front_storage(GLcontext *ctx, struct gl_renderbuffer *rb,
     rb->Width = width;
     rb->Height = height;
 
-    switch (internalFormat) {
-    case GL_RGB:
-	bpp = rb->RedBits + rb->GreenBits + rb->BlueBits;
-	break;
-    case GL_RGBA:
-	bpp = rb->RedBits + rb->GreenBits + rb->BlueBits + rb->AlphaBits;
-	break;
-    case GL_COLOR_INDEX8_EXT:
-	bpp = rb->IndexBits;
-	break;
-    default:
-	_mesa_problem( NULL, "unexpected format in %s", __FUNCTION__ );
-	return GL_FALSE;
-    }
-
     /* always pad to PITCH_ALIGN_BITS */
-    xrb->pitch = ((width * bpp + mask) & ~mask) / 8;
+    xrb->pitch = ((width * xrb->bpp + mask) & ~mask) / 8;
 
     return GL_TRUE;
 }
@@ -371,6 +375,17 @@ swrast_new_renderbuffer(const GLvisual *visual, GLboolean front)
 	xrb->Base.GreenBits = 8 * sizeof(GLubyte);
 	xrb->Base.BlueBits  = 8 * sizeof(GLubyte);
 	xrb->Base.AlphaBits = 8 * sizeof(GLubyte);
+	xrb->bpp = 32;
+	break;
+    case PF_X8R8G8B8:
+	xrb->Base.InternalFormat = GL_RGB;
+	xrb->Base._BaseFormat = GL_RGB;
+	xrb->Base.DataType = GL_UNSIGNED_BYTE;
+	xrb->Base.RedBits   = 8 * sizeof(GLubyte);
+	xrb->Base.GreenBits = 8 * sizeof(GLubyte);
+	xrb->Base.BlueBits  = 8 * sizeof(GLubyte);
+	xrb->Base.AlphaBits = 0;
+	xrb->bpp = 32;
 	break;
     case PF_R5G6B5:
 	xrb->Base.InternalFormat = GL_RGB;
@@ -380,6 +395,7 @@ swrast_new_renderbuffer(const GLvisual *visual, GLboolean front)
 	xrb->Base.GreenBits = 6 * sizeof(GLubyte);
 	xrb->Base.BlueBits  = 5 * sizeof(GLubyte);
 	xrb->Base.AlphaBits = 0;
+	xrb->bpp = 16;
 	break;
     case PF_R3G3B2:
 	xrb->Base.InternalFormat = GL_RGB;
@@ -389,12 +405,14 @@ swrast_new_renderbuffer(const GLvisual *visual, GLboolean front)
 	xrb->Base.GreenBits = 3 * sizeof(GLubyte);
 	xrb->Base.BlueBits  = 2 * sizeof(GLubyte);
 	xrb->Base.AlphaBits = 0;
+	xrb->bpp = 8;
 	break;
     case PF_CI8:
 	xrb->Base.InternalFormat = GL_COLOR_INDEX8_EXT;
 	xrb->Base._BaseFormat = GL_COLOR_INDEX;
 	xrb->Base.DataType = GL_UNSIGNED_BYTE;
 	xrb->Base.IndexBits = 8 * sizeof(GLubyte);
+	xrb->bpp = 8;
 	break;
     default:
 	return NULL;
diff --git a/src/mesa/drivers/dri/swrast/swrast_priv.h b/src/mesa/drivers/dri/swrast/swrast_priv.h
index a707ffc..1a5fb31 100644
--- a/src/mesa/drivers/dri/swrast/swrast_priv.h
+++ b/src/mesa/drivers/dri/swrast/swrast_priv.h
@@ -90,6 +90,8 @@ struct swrast_renderbuffer {
 
     /* renderbuffer pitch (in bytes) */
     GLuint pitch;
+   /* bits per pixel of storage */
+    GLuint bpp;
 };
 
 static INLINE __DRIcontext *
@@ -115,10 +117,10 @@ swrast_renderbuffer(struct gl_renderbuffer *rb)
  * Pixel formats we support
  */
 #define PF_CI8        1		/**< Color Index mode */
-#define PF_A8R8G8B8   2		/**< 32-bit TrueColor:  8-A, 8-R, 8-G, 8-B bits */
-#define PF_R5G6B5     3		/**< 16-bit TrueColor:  5-R, 6-G, 5-B bits */
-#define PF_R3G3B2     4		/**<  8-bit TrueColor:  3-R, 3-G, 2-B bits */
-
+#define PF_A8R8G8B8   2		/**< 32bpp TrueColor:  8-A, 8-R, 8-G, 8-B bits */
+#define PF_R5G6B5     3		/**< 16bpp TrueColor:  5-R, 6-G, 5-B bits */
+#define PF_R3G3B2     4		/**<  8bpp TrueColor:  3-R, 3-G, 2-B bits */
+#define PF_X8R8G8B8   5		/**< 32bpp TrueColor:  8-R, 8-G, 8-B bits */
 
 /**
  * Renderbuffer pitch alignment (in bits).
diff --git a/src/mesa/drivers/dri/swrast/swrast_span.c b/src/mesa/drivers/dri/swrast/swrast_span.c
index 5e99036..2d3c25d 100644
--- a/src/mesa/drivers/dri/swrast/swrast_span.c
+++ b/src/mesa/drivers/dri/swrast/swrast_span.c
@@ -79,6 +79,24 @@ static const GLubyte kernel[16] = {
    DST[BCOMP] = SRC[0]
 
 
+/* 32-bit BGRX */
+#define STORE_PIXEL_X8R8G8B8(DST, X, Y, VALUE) \
+   DST[3] = 0xff; \
+   DST[2] = VALUE[RCOMP]; \
+   DST[1] = VALUE[GCOMP]; \
+   DST[0] = VALUE[BCOMP]
+#define STORE_PIXEL_RGB_X8R8G8B8(DST, X, Y, VALUE) \
+   DST[3] = 0xff; \
+   DST[2] = VALUE[RCOMP]; \
+   DST[1] = VALUE[GCOMP]; \
+   DST[0] = VALUE[BCOMP]
+#define FETCH_PIXEL_X8R8G8B8(DST, SRC) \
+   DST[ACOMP] = 0xff; \
+   DST[RCOMP] = SRC[2]; \
+   DST[GCOMP] = SRC[1]; \
+   DST[BCOMP] = SRC[0]
+
+
 /* 16-bit BGR */
 #define STORE_PIXEL_R5G6B5(DST, X, Y, VALUE) \
    do { \
@@ -139,6 +157,24 @@ static const GLubyte kernel[16] = {
 #include "swrast/s_spantemp.h"
 
 
+/* 32-bit BGRX */
+#define NAME(FUNC) FUNC##_X8R8G8B8
+#define RB_TYPE GLubyte
+#define SPAN_VARS \
+   struct swrast_renderbuffer *xrb = swrast_renderbuffer(rb);
+#define INIT_PIXEL_PTR(P, X, Y) \
+   GLubyte *P = (GLubyte *)xrb->Base.Data + YFLIP(xrb, Y) * xrb->pitch + (X) * 4;
+#define INC_PIXEL_PTR(P) P += 4
+#define STORE_PIXEL(DST, X, Y, VALUE) \
+   STORE_PIXEL_X8R8G8B8(DST, X, Y, VALUE)
+#define STORE_PIXEL_RGB(DST, X, Y, VALUE) \
+   STORE_PIXEL_RGB_X8R8G8B8(DST, X, Y, VALUE)
+#define FETCH_PIXEL(DST, SRC) \
+   FETCH_PIXEL_X8R8G8B8(DST, SRC)
+
+#include "swrast/s_spantemp.h"
+
+
 /* 16-bit BGR */
 #define NAME(FUNC) FUNC##_R5G6B5
 #define RB_TYPE GLubyte
@@ -210,6 +246,24 @@ static const GLubyte kernel[16] = {
 #include "swrast_spantemp.h"
 
 
+/* 32-bit BGRX */
+#define NAME(FUNC) FUNC##_X8R8G8B8_front
+#define RB_TYPE GLubyte
+#define SPAN_VARS \
+   struct swrast_renderbuffer *xrb = swrast_renderbuffer(rb);
+#define INIT_PIXEL_PTR(P, X, Y) \
+   GLubyte *P = (GLubyte *)row;
+#define INC_PIXEL_PTR(P) P += 4
+#define STORE_PIXEL(DST, X, Y, VALUE) \
+   STORE_PIXEL_X8R8G8B8(DST, X, Y, VALUE)
+#define STORE_PIXEL_RGB(DST, X, Y, VALUE) \
+   STORE_PIXEL_RGB_X8R8G8B8(DST, X, Y, VALUE)
+#define FETCH_PIXEL(DST, SRC) \
+   FETCH_PIXEL_X8R8G8B8(DST, SRC)
+
+#include "swrast_spantemp.h"
+
+
 /* 16-bit BGR */
 #define NAME(FUNC) FUNC##_R5G6B5_front
 #define RB_TYPE GLubyte
@@ -279,6 +333,15 @@ swrast_set_span_funcs_back(struct swrast_renderbuffer *xrb,
 	xrb->Base.PutValues = put_values_A8R8G8B8;
 	xrb->Base.PutMonoValues = put_mono_values_A8R8G8B8;
 	break;
+    case PF_X8R8G8B8:
+	xrb->Base.GetRow = get_row_X8R8G8B8;
+	xrb->Base.GetValues = get_values_X8R8G8B8;
+	xrb->Base.PutRow = put_row_X8R8G8B8;
+	xrb->Base.PutRowRGB = put_row_rgb_X8R8G8B8;
+	xrb->Base.PutMonoRow = put_mono_row_X8R8G8B8;
+	xrb->Base.PutValues = put_values_X8R8G8B8;
+	xrb->Base.PutMonoValues = put_mono_values_X8R8G8B8;
+	break;
     case PF_R5G6B5:
 	xrb->Base.GetRow = get_row_R5G6B5;
 	xrb->Base.GetValues = get_values_R5G6B5;
@@ -334,6 +397,15 @@ swrast_set_span_funcs_front(struct swrast_renderbuffer *xrb,
 	xrb->Base.PutValues = put_values_A8R8G8B8_front;
 	xrb->Base.PutMonoValues = put_mono_values_A8R8G8B8_front;
 	break;
+    case PF_X8R8G8B8:
+	xrb->Base.GetRow = get_row_X8R8G8B8_front;
+	xrb->Base.GetValues = get_values_X8R8G8B8_front;
+	xrb->Base.PutRow = put_row_X8R8G8B8_front;
+	xrb->Base.PutRowRGB = put_row_rgb_X8R8G8B8_front;
+	xrb->Base.PutMonoRow = put_mono_row_X8R8G8B8_front;
+	xrb->Base.PutValues = put_values_X8R8G8B8_front;
+	xrb->Base.PutMonoValues = put_mono_values_X8R8G8B8_front;
+	break;
     case PF_R5G6B5:
 	xrb->Base.GetRow = get_row_R5G6B5_front;
 	xrb->Base.GetValues = get_values_R5G6B5_front;
diff --git a/src/mesa/drivers/dri/tdfx/tdfx_context.c b/src/mesa/drivers/dri/tdfx/tdfx_context.c
index ef688d1..20046fc 100644
--- a/src/mesa/drivers/dri/tdfx/tdfx_context.c
+++ b/src/mesa/drivers/dri/tdfx/tdfx_context.c
@@ -58,20 +58,15 @@
 
 #include "utils.h"
 
-#define need_GL_ARB_multisample
 /* #define need_GL_ARB_point_parameters */
 #define need_GL_ARB_occlusion_query
-#define need_GL_ARB_texture_compression
-#define need_GL_ARB_vertex_buffer_object
 /* #define need_GL_ARB_vertex_program */
 #define need_GL_EXT_blend_equation_separate
 #define need_GL_EXT_blend_func_separate
 #define need_GL_EXT_blend_minmax
 #define need_GL_EXT_fog_coord
-#define need_GL_EXT_multi_draw_arrays
 #define need_GL_EXT_paletted_texture
 /* #define need_GL_EXT_secondary_color */
-#define need_GL_IBM_multimode_draw_arrays
 /* #define need_GL_MESA_program_debug */
 /* #define need_GL_NV_vertex_program */
 #include "extension_helper.h"
@@ -82,20 +77,16 @@
  */
 const struct dri_extension card_extensions[] =
 {
-    { "GL_ARB_multisample",                GL_ARB_multisample_functions },
     { "GL_ARB_occlusion_query",            GL_ARB_occlusion_query_functions },
     { "GL_ARB_texture_mirrored_repeat",    NULL },
-    { "GL_ARB_vertex_buffer_object",       GL_ARB_vertex_buffer_object_functions },
 
     { "GL_EXT_blend_func_separate",        GL_EXT_blend_func_separate_functions },
     { "GL_EXT_fog_coord",                  GL_EXT_fog_coord_functions },
-    { "GL_EXT_multi_draw_arrays",          GL_EXT_multi_draw_arrays_functions },
     { "GL_EXT_paletted_texture",           GL_EXT_paletted_texture_functions },
     { "GL_EXT_shared_texture_palette",     NULL },
     { "GL_EXT_stencil_wrap",               NULL },
     { "GL_EXT_texture_env_add",            NULL },
     { "GL_EXT_texture_lod_bias",           NULL },
-    { "GL_IBM_multimode_draw_arrays",      GL_IBM_multimode_draw_arrays_functions },
 
 #ifdef need_GL_ARB_point_parameters
     { "GL_ARB_point_parameters",           GL_ARB_point_parameters_functions },
@@ -122,7 +113,6 @@ const struct dri_extension card_extensions[] =
  */
 const struct dri_extension napalm_extensions[] =
 {
-    { "GL_ARB_texture_compression",        GL_ARB_texture_compression_functions },
     { "GL_ARB_texture_env_combine",        NULL },
     { "GL_EXT_blend_equation_separate",    GL_EXT_blend_equation_separate_functions },
     { "GL_EXT_blend_subtract",             GL_EXT_blend_minmax_functions },
@@ -319,6 +309,8 @@ GLboolean tdfxCreateContext( const __GLcontextModes *mesaVis,
    ctx->Const.MaxLineWidthAA = 1.0;
    ctx->Const.LineWidthGranularity = 1.0;
 
+   ctx->Const.MaxDrawBuffers = 1;
+
    /* Initialize the software rasterizer and helper modules.
     */
    _swrast_CreateContext( ctx );
diff --git a/src/mesa/drivers/dri/tdfx/tdfx_dd.c b/src/mesa/drivers/dri/tdfx/tdfx_dd.c
index 2cef079..8472df6 100644
--- a/src/mesa/drivers/dri/tdfx/tdfx_dd.c
+++ b/src/mesa/drivers/dri/tdfx/tdfx_dd.c
@@ -110,13 +110,13 @@ static const GLubyte *tdfxDDGetString( GLcontext *ctx, GLenum name )
 
 
 static void
-tdfxBeginQuery(GLcontext *ctx, GLenum target, struct gl_query_object *q)
+tdfxBeginQuery(GLcontext *ctx, struct gl_query_object *q)
 {
    tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
 
    (void) q;
 
-   if (target == GL_SAMPLES_PASSED_ARB) {
+   if (q->Target == GL_SAMPLES_PASSED_ARB) {
       LOCK_HARDWARE(fxMesa);
       fxMesa->Glide.grFinish();
       fxMesa->Glide.grReset(GR_STATS_PIXELS);
@@ -126,14 +126,14 @@ tdfxBeginQuery(GLcontext *ctx, GLenum target, struct gl_query_object *q)
 
 
 static void
-tdfxEndQuery(GLcontext *ctx, GLenum target, struct gl_query_object *q)
+tdfxEndQuery(GLcontext *ctx, struct gl_query_object *q)
 {
    tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
    FxI32 total_pixels;
    FxI32 z_fail_pixels;
 
 
-   if (target == GL_SAMPLES_PASSED_ARB) {
+   if (q->Target == GL_SAMPLES_PASSED_ARB) {
       LOCK_HARDWARE(fxMesa);
       fxMesa->Glide.grFinish();
 
diff --git a/src/mesa/drivers/dri/tdfx/tdfx_screen.c b/src/mesa/drivers/dri/tdfx/tdfx_screen.c
index cd22b84..5f2f5cf 100644
--- a/src/mesa/drivers/dri/tdfx/tdfx_screen.c
+++ b/src/mesa/drivers/dri/tdfx/tdfx_screen.c
@@ -361,6 +361,7 @@ tdfxFillInModes(__DRIscreenPrivate *psp,
 	static const GLenum db_modes[2] = { GLX_NONE, GLX_SWAP_UNDEFINED_OML };
 	uint8_t depth_bits_array[4];
 	uint8_t stencil_bits_array[4];
+        uint8_t msaa_samples_array[1];
 	if(deep) {
 		depth_bits_array[0] = 0;
 		depth_bits_array[1] = 24;
@@ -377,13 +378,17 @@ tdfxFillInModes(__DRIscreenPrivate *psp,
 		stencil_bits_array[3] = 8;
 	}
 
-	return driCreateConfigs(
-		deep ? GL_RGBA : GL_RGB,
-		deep ? GL_UNSIGNED_INT_8_8_8_8 : GL_UNSIGNED_SHORT_5_6_5,
-		depth_bits_array,
-		stencil_bits_array,
-		deep ? 2 : 4,
-		db_modes, 2);
+	msaa_samples_array[0] = 0;
+
+	return (const __DRIconfig **)
+	   driCreateConfigs(deep ? GL_RGBA : GL_RGB,
+			    deep ? GL_UNSIGNED_INT_8_8_8_8 :
+				   GL_UNSIGNED_SHORT_5_6_5,
+			    depth_bits_array,
+			    stencil_bits_array,
+			    deep ? 2 : 4,
+			    db_modes, 2,
+			    msaa_samples_array, 1);
 }
 
 /**
diff --git a/src/mesa/drivers/dri/trident/trident_context.c b/src/mesa/drivers/dri/trident/trident_context.c
index e134cfc..aefd8a2 100644
--- a/src/mesa/drivers/dri/trident/trident_context.c
+++ b/src/mesa/drivers/dri/trident/trident_context.c
@@ -128,6 +128,8 @@ tridentCreateContext( const __GLcontextModes *glVisual,
    ctx->Const.MaxPointSizeAA = 16.0; 
    ctx->Const.PointSizeGranularity = 0.25;
 
+   ctx->Const.MaxDrawBuffers = 1;
+
 #if 0
    tmesa->texHeap = mmInit( 0, tmesa->tridentScreen->textureSize );
 
diff --git a/src/mesa/drivers/dri/trident/trident_vb.c b/src/mesa/drivers/dri/trident/trident_vb.c
index b231f5e..055a914 100644
--- a/src/mesa/drivers/dri/trident/trident_vb.c
+++ b/src/mesa/drivers/dri/trident/trident_vb.c
@@ -402,7 +402,7 @@ void tridentInitVB( GLcontext *ctx )
    tridentContextPtr tmesa = TRIDENT_CONTEXT(ctx);
    GLuint size = TNL_CONTEXT(ctx)->vb.Size;
 
-   tmesa->verts = (char *)ALIGN_MALLOC( size * 16 * 4, 32 );
+   tmesa->verts = (GLubyte *)ALIGN_MALLOC( size * 16 * 4, 32 );
 
    {
       static int firsttime = 1;
diff --git a/src/mesa/drivers/dri/unichrome/via_context.c b/src/mesa/drivers/dri/unichrome/via_context.c
index f5bdb65..6eb19ac 100644
--- a/src/mesa/drivers/dri/unichrome/via_context.c
+++ b/src/mesa/drivers/dri/unichrome/via_context.c
@@ -62,9 +62,7 @@
 #include "main/macros.h"
 #include "drirenderbuffer.h"
 
-#define need_GL_ARB_multisample
 #define need_GL_ARB_point_parameters
-#define need_GL_ARB_vertex_buffer_object
 #define need_GL_EXT_fog_coord
 #define need_GL_EXT_secondary_color
 #include "extension_helper.h"
@@ -366,14 +364,12 @@ void viaReAllocateBuffers(GLcontext *ctx, GLframebuffer *drawbuffer,
  */
 const struct dri_extension card_extensions[] =
 {
-    { "GL_ARB_multisample",                GL_ARB_multisample_functions },
     { "GL_ARB_multitexture",               NULL },
     { "GL_ARB_point_parameters",           GL_ARB_point_parameters_functions },
     { "GL_ARB_texture_env_add",            NULL },
     { "GL_ARB_texture_env_combine",        NULL },
 /*    { "GL_ARB_texture_env_dot3",           NULL }, */
     { "GL_ARB_texture_mirrored_repeat",    NULL },
-    { "GL_ARB_vertex_buffer_object",       GL_ARB_vertex_buffer_object_functions },
     { "GL_EXT_fog_coord",                  GL_EXT_fog_coord_functions },
     { "GL_EXT_secondary_color",            GL_EXT_secondary_color_functions },
     { "GL_EXT_stencil_wrap",               NULL },
@@ -577,6 +573,8 @@ viaCreateContext(const __GLcontextModes *visual,
     ctx->Const.MaxPointSizeAA = 1.0;
     ctx->Const.PointSizeGranularity = 1.0;
 
+    ctx->Const.MaxDrawBuffers = 1;
+
     ctx->Driver.GetString = viaGetString;
 
     ctx->DriverCtx = (void *)vmesa;
diff --git a/src/mesa/drivers/dri/unichrome/via_screen.c b/src/mesa/drivers/dri/unichrome/via_screen.c
index 988f993..e9f5661 100644
--- a/src/mesa/drivers/dri/unichrome/via_screen.c
+++ b/src/mesa/drivers/dri/unichrome/via_screen.c
@@ -342,6 +342,7 @@ viaFillInModes( __DRIscreenPrivate *psp,
      */
     static const uint8_t depth_bits_array[4]   = { 0, 16, 24, 32 };
     static const uint8_t stencil_bits_array[4] = { 0,  0,  8,  0 };
+    uint8_t msaa_samples_array[1] = { 0 };
     const unsigned depth_buffer_factor = 3;
 
     if ( pixel_bits == 16 ) {
@@ -356,7 +357,8 @@ viaFillInModes( __DRIscreenPrivate *psp,
     configs = driCreateConfigs(fb_format, fb_type,
 			       depth_bits_array, stencil_bits_array,
 			       depth_buffer_factor, back_buffer_modes,
-			       back_buffer_factor);
+			       back_buffer_factor,
+                               msaa_samples_array, 1);
     if (configs == NULL) {
 	fprintf(stderr, "[%s:%u] Error creating FBConfig!\n", __func__,
 		__LINE__);
