diff --git a/src/mesa/drivers/dri/r200/r200_state_init.c b/src/mesa/drivers/dri/r200/r200_state_init.c
index 013064d..b40690e 100644
--- a/src/mesa/drivers/dri/r200/r200_state_init.c
+++ b/src/mesa/drivers/dri/r200/r200_state_init.c
@@ -342,6 +342,7 @@ static void mtl_emit(GLcontext *ctx, struct radeon_state_atom *atom)
    BATCH_LOCALS(&r200->radeon);
    uint32_t dwords = atom->cmd_size;
 
+   dwords += 6;
    BEGIN_BATCH_NO_AUTOSTATE(dwords);
    OUT_VEC(atom->cmd[MTL_CMD_0], (atom->cmd+1));
    OUT_SCL2(atom->cmd[MTL_CMD_1], (atom->cmd + 18));
@@ -354,6 +355,7 @@ static void lit_emit(GLcontext *ctx, struct radeon_state_atom *atom)
    BATCH_LOCALS(&r200->radeon);
    uint32_t dwords = atom->cmd_size;
 
+   dwords += 8;
    BEGIN_BATCH_NO_AUTOSTATE(dwords);
    OUT_VEC(atom->cmd[LIT_CMD_0], atom->cmd+1);
    OUT_VEC(atom->cmd[LIT_CMD_1], atom->cmd+LIT_CMD_1+1);
@@ -366,6 +368,7 @@ static void ptp_emit(GLcontext *ctx, struct radeon_state_atom *atom)
    BATCH_LOCALS(&r200->radeon);
    uint32_t dwords = atom->cmd_size;
 
+   dwords += 8;
    BEGIN_BATCH_NO_AUTOSTATE(dwords);
    OUT_VEC(atom->cmd[PTP_CMD_0], atom->cmd+1);
    OUT_VEC(atom->cmd[PTP_CMD_1], atom->cmd+PTP_CMD_1+1);
@@ -378,6 +381,7 @@ static void veclinear_emit(GLcontext *ctx, struct radeon_state_atom *atom)
    BATCH_LOCALS(&r200->radeon);
    uint32_t dwords = atom->cmd_size;
 
+   dwords += 4;
    BEGIN_BATCH_NO_AUTOSTATE(dwords);
    OUT_VECLINEAR(atom->cmd[0], atom->cmd+1);
    END_BATCH();
@@ -389,6 +393,7 @@ static void scl_emit(GLcontext *ctx, struct radeon_state_atom *atom)
    BATCH_LOCALS(&r200->radeon);
    uint32_t dwords = atom->cmd_size;
 
+   dwords += 2;
    BEGIN_BATCH_NO_AUTOSTATE(dwords);
    OUT_SCL(atom->cmd[0], atom->cmd+1);
    END_BATCH();
@@ -401,6 +406,7 @@ static void vec_emit(GLcontext *ctx, struct radeon_state_atom *atom)
    BATCH_LOCALS(&r200->radeon);
    uint32_t dwords = atom->cmd_size;
 
+   dwords += 4;
    BEGIN_BATCH_NO_AUTOSTATE(dwords);
    OUT_VEC(atom->cmd[0], atom->cmd+1);
    END_BATCH();
@@ -412,36 +418,47 @@ static void ctx_emit(GLcontext *ctx, struct radeon_state_atom *atom)
    BATCH_LOCALS(&r200->radeon);
    struct radeon_renderbuffer *rrb;
    uint32_t cbpitch;
-   uint32_t zbpitch;
+   uint32_t zbpitch, depth_fmt;
    uint32_t dwords = atom->cmd_size;
-   GLframebuffer *fb = r200->radeon.dri.drawable->driverPrivate;
 
    /* output the first 7 bytes of context */
    BEGIN_BATCH_NO_AUTOSTATE(dwords+2+2);
    OUT_BATCH_TABLE(atom->cmd, 5);
 
-   rrb = r200->radeon.state.depth.rrb;
+   rrb = radeon_get_depthbuffer(&r200->radeon);
    if (!rrb) {
      OUT_BATCH(0);
      OUT_BATCH(0);
    } else {
      zbpitch = (rrb->pitch / rrb->cpp);
+     if (r200->using_hyperz)
+       zbpitch |= RADEON_DEPTH_HYPERZ;
      OUT_BATCH_RELOC(0, rrb->bo, 0, 0, RADEON_GEM_DOMAIN_VRAM, 0);
      OUT_BATCH(zbpitch);
+     if (rrb->cpp == 4) 
+       depth_fmt = RADEON_DEPTH_FORMAT_24BIT_INT_Z; 
+     else 
+       depth_fmt = RADEON_DEPTH_FORMAT_16BIT_INT_Z; 
+     atom->cmd[CTX_RB3D_ZSTENCILCNTL] &= ~RADEON_DEPTH_FORMAT_MASK; 
+     atom->cmd[CTX_RB3D_ZSTENCILCNTL] |= depth_fmt; 
    }
      
    OUT_BATCH(atom->cmd[CTX_RB3D_ZSTENCILCNTL]);
    OUT_BATCH(atom->cmd[CTX_CMD_1]);
    OUT_BATCH(atom->cmd[CTX_PP_CNTL]);
-   OUT_BATCH(atom->cmd[CTX_RB3D_CNTL]);
 
-   rrb = r200->radeon.state.color.rrb;
-   if (r200->radeon.radeonScreen->driScreen->dri2.enabled) {
-      rrb = (struct radeon_renderbuffer *)fb->Attachment[BUFFER_BACK_LEFT].Renderbuffer;
-   }
+   rrb = radeon_get_colorbuffer(&r200->radeon);
    if (!rrb || !rrb->bo) {
+     OUT_BATCH(atom->cmd[CTX_RB3D_CNTL]);
      OUT_BATCH(atom->cmd[CTX_RB3D_COLOROFFSET]);
    } else {
+     atom->cmd[CTX_RB3D_CNTL] &= ~(0xf << 10); 
+     if (rrb->cpp == 4) 
+       atom->cmd[CTX_RB3D_CNTL] |= RADEON_COLOR_FORMAT_ARGB8888; 
+     else 
+       atom->cmd[CTX_RB3D_CNTL] |= RADEON_COLOR_FORMAT_RGB565; 
+ 
+     OUT_BATCH(atom->cmd[CTX_RB3D_CNTL]); 
      OUT_BATCH_RELOC(0, rrb->bo, 0, 0, RADEON_GEM_DOMAIN_VRAM, 0);
    }
 
@@ -451,11 +468,7 @@ static void ctx_emit(GLcontext *ctx, struct radeon_state_atom *atom)
      OUT_BATCH(atom->cmd[CTX_RB3D_COLORPITCH]);
    } else {
      cbpitch = (rrb->pitch / rrb->cpp);
-     if (rrb->cpp == 4)
-       ;
-     else
-       ;
-     if (r200->radeon.sarea->tiling_enabled)
+     if (rrb->bo->flags & RADEON_BO_FLAGS_MACRO_TILE)
        cbpitch |= R200_COLOR_TILE_ENABLE;
      OUT_BATCH(cbpitch);
    }
@@ -474,22 +487,38 @@ static void ctx_emit_cs(GLcontext *ctx, struct radeon_state_atom *atom)
    uint32_t cbpitch = 0;
    uint32_t zbpitch = 0;
    uint32_t dwords = atom->cmd_size;
-   GLframebuffer *fb = r200->radeon.dri.drawable->driverPrivate;
+   uint32_t depth_fmt;
 
-   rrb = r200->radeon.state.color.rrb;
-   if (r200->radeon.radeonScreen->driScreen->dri2.enabled) {
-      rrb = (struct radeon_renderbuffer *)fb->Attachment[BUFFER_BACK_LEFT].Renderbuffer;
+   rrb = radeon_get_colorbuffer(&r200->radeon);
+   if (!rrb || !rrb->bo) {
+      return;
    }
-   if (rrb) {
-     assert(rrb->bo != NULL);
-     cbpitch = (rrb->pitch / rrb->cpp);
-     if (r200->radeon.sarea->tiling_enabled)
+
+   atom->cmd[CTX_RB3D_CNTL] &= ~(0xf << 10);
+   if (rrb->cpp == 4)
+	atom->cmd[CTX_RB3D_CNTL] |= RADEON_COLOR_FORMAT_ARGB8888;
+   else
+	atom->cmd[CTX_RB3D_CNTL] |= RADEON_COLOR_FORMAT_RGB565;
+
+   cbpitch = (rrb->pitch / rrb->cpp);
+   if (rrb->bo->flags & RADEON_BO_FLAGS_MACRO_TILE)
        cbpitch |= R200_COLOR_TILE_ENABLE;
+
+   drb = radeon_get_depthbuffer(&r200->radeon);
+   if (drb) {
+     zbpitch = (drb->pitch / drb->cpp);
+     if (drb->cpp == 4)
+        depth_fmt = RADEON_DEPTH_FORMAT_24BIT_INT_Z;
+     else
+        depth_fmt = RADEON_DEPTH_FORMAT_16BIT_INT_Z;
+     atom->cmd[CTX_RB3D_ZSTENCILCNTL] &= ~RADEON_DEPTH_FORMAT_MASK;
+     atom->cmd[CTX_RB3D_ZSTENCILCNTL] |= depth_fmt;
    }
 
-   drb = r200->radeon.state.depth.rrb;
    if (drb)
-     zbpitch = (drb->pitch / drb->cpp);
+     dwords += 4;
+   if (rrb)
+     dwords += 4;
 
    /* output the first 7 bytes of context */
    BEGIN_BATCH_NO_AUTOSTATE(dwords);
@@ -519,10 +548,6 @@ static void ctx_emit_cs(GLcontext *ctx, struct radeon_state_atom *atom)
    }
 
    if (rrb) {
-     if (rrb->cpp == 4)
-       ;
-     else
-       ;
      OUT_BATCH(CP_PACKET0(RADEON_RB3D_COLORPITCH, 0));
      OUT_BATCH(cbpitch);
    }
@@ -586,20 +611,7 @@ static void cube_emit(GLcontext *ctx, struct radeon_state_atom *atom)
 void r200InitState( r200ContextPtr rmesa )
 {
    GLcontext *ctx = rmesa->radeon.glCtx;
-   GLuint color_fmt, depth_fmt, i;
-   GLint drawPitch, drawOffset;
-
-   switch ( rmesa->radeon.radeonScreen->cpp ) {
-   case 2:
-      color_fmt = R200_COLOR_FORMAT_RGB565;
-      break;
-   case 4:
-      color_fmt = R200_COLOR_FORMAT_ARGB8888;
-      break;
-   default:
-      fprintf( stderr, "Error: Unsupported pixel depth... exiting\n" );
-      exit( -1 );
-   }
+   GLuint i;
 
    rmesa->radeon.state.color.clear = 0x00000000;
 
@@ -607,13 +619,11 @@ void r200InitState( r200ContextPtr rmesa )
    case 16:
       rmesa->radeon.state.depth.clear = 0x0000ffff;
       rmesa->radeon.state.depth.scale = 1.0 / (GLfloat)0xffff;
-      depth_fmt = R200_DEPTH_FORMAT_16BIT_INT_Z;
       rmesa->radeon.state.stencil.clear = 0x00000000;
       break;
    case 24:
       rmesa->radeon.state.depth.clear = 0x00ffffff;
       rmesa->radeon.state.depth.scale = 1.0 / (GLfloat)0xffffff;
-      depth_fmt = R200_DEPTH_FORMAT_24BIT_INT_Z;
       rmesa->radeon.state.stencil.clear = 0xffff0000;
       break;
    default:
@@ -628,26 +638,6 @@ void r200InitState( r200ContextPtr rmesa )
 
    rmesa->radeon.Fallback = 0;
 
-   if ( ctx->Visual.doubleBufferMode && rmesa->radeon.sarea->pfCurrentPage == 0 ) {
-      drawOffset = rmesa->radeon.radeonScreen->backOffset;
-      drawPitch  = rmesa->radeon.radeonScreen->backPitch;
-   } else {
-      drawOffset = rmesa->radeon.radeonScreen->frontOffset;
-      drawPitch  = rmesa->radeon.radeonScreen->frontPitch;
-   }
-#if 000
-   if ( ctx->Visual.doubleBufferMode && rmesa->sarea->pfCurrentPage == 0 ) {
-      rmesa->radeon.state.color.drawOffset = rmesa->radeon.radeonScreen->backOffset;
-      rmesa->radeon.state.color.drawPitch  = rmesa->radeon.radeonScreen->backPitch;
-   } else {
-      rmesa->radeon.state.color.drawOffset = rmesa->radeon.radeonScreen->frontOffset;
-      rmesa->radeon.state.color.drawPitch  = rmesa->radeon.radeonScreen->frontPitch;
-   }
-
-   rmesa->state.pixel.readOffset = rmesa->radeon.state.color.drawOffset;
-   rmesa->state.pixel.readPitch  = rmesa->radeon.state.color.drawPitch;
-#endif
-
    rmesa->radeon.hw.max_state_size = 0;
 
 #define ALLOC_STATE( ATOM, CHK, SZ, NM, IDX )				\
@@ -1025,8 +1015,7 @@ void r200InitState( r200ContextPtr rmesa )
    if (rmesa->using_hyperz)
       rmesa->hw.ctx.cmd[CTX_RB3D_DEPTHPITCH] |= R200_DEPTH_HYPERZ;
 
-   rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] = (depth_fmt |
-					       R200_Z_TEST_LESS |
+   rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] = (R200_Z_TEST_LESS |
 					       R200_STENCIL_TEST_ALWAYS |
 					       R200_STENCIL_FAIL_KEEP |
 					       R200_STENCIL_ZPASS_KEEP |
@@ -1043,7 +1032,6 @@ void r200InitState( r200ContextPtr rmesa )
    rmesa->hw.ctx.cmd[CTX_PP_CNTL] = (R200_ANTI_ALIAS_NONE 
  				     | R200_TEX_BLEND_0_ENABLE);
 
-   rmesa->hw.ctx.cmd[CTX_RB3D_CNTL] = color_fmt;
    switch ( driQueryOptioni( &rmesa->radeon.optionCache, "dither_mode" ) ) {
    case DRI_CONF_DITHER_XERRORDIFFRESET:
       rmesa->hw.ctx.cmd[CTX_RB3D_CNTL] |= R200_DITHER_INIT;
@@ -1063,28 +1051,6 @@ void r200InitState( r200ContextPtr rmesa )
    else
       rmesa->hw.ctx.cmd[CTX_RB3D_CNTL] |= rmesa->radeon.state.color.roundEnable;
 
-#if 000
-   rmesa->hw.ctx.cmd[CTX_RB3D_COLOROFFSET] = ((rmesa->radeon.state.color.drawOffset +
-					       rmesa->radeon.radeonScreen->fbLocation)
-					      & R200_COLOROFFSET_MASK);
-
-   rmesa->hw.ctx.cmd[CTX_RB3D_COLORPITCH] = ((rmesa->radeon.state.color.drawPitch &
-					      R200_COLORPITCH_MASK) |
-					     R200_COLOR_ENDIAN_NO_SWAP);
-#else
-   rmesa->hw.ctx.cmd[CTX_RB3D_COLOROFFSET] = ((drawOffset +
-					       rmesa->radeon.radeonScreen->fbLocation)
-					      & R200_COLOROFFSET_MASK);
-
-   rmesa->hw.ctx.cmd[CTX_RB3D_COLORPITCH] = ((drawPitch &
-					      R200_COLORPITCH_MASK) |
-					     R200_COLOR_ENDIAN_NO_SWAP);
-#endif
-   /* (fixed size) sarea is initialized to zero afaics so can omit version check. Phew! */
-   if (rmesa->radeon.sarea->tiling_enabled) {
-      rmesa->hw.ctx.cmd[CTX_RB3D_COLORPITCH] |= R200_COLOR_TILE_ENABLE;
-   }
-
    rmesa->hw.prf.cmd[PRF_PP_TRI_PERF] = R200_TRI_CUTOFF_MASK - R200_TRI_CUTOFF_MASK * 
 			driQueryOptionf (&rmesa->radeon.optionCache,"texture_blend_quality");
    rmesa->hw.prf.cmd[PRF_PP_PERF_CNTL] = 0;
diff --git a/src/mesa/drivers/dri/r300/r300_cmdbuf.c b/src/mesa/drivers/dri/r300/r300_cmdbuf.c
index ac1c128..231576f 100644
--- a/src/mesa/drivers/dri/r300/r300_cmdbuf.c
+++ b/src/mesa/drivers/dri/r300/r300_cmdbuf.c
@@ -97,14 +97,20 @@ void emit_vpu(GLcontext *ctx, struct radeon_state_atom * atom)
 	addr = (cmd.vpu.adrhi << 8) | cmd.vpu.adrlo;
 	ndw = cmd.vpu.count * 4;
 	if (ndw) {
-		BEGIN_BATCH_NO_AUTOSTATE(13 + ndw);
-
-		/* flush processing vertices */
-		OUT_BATCH_REGVAL(R300_SC_SCREENDOOR, 0);
-		OUT_BATCH_REGVAL(R300_RB3D_DSTCACHE_CTLSTAT, R300_RB3D_DSTCACHE_CTLSTAT_DC_FLUSH_FLUSH_DIRTY_3D);
-		OUT_BATCH_REGVAL(RADEON_WAIT_UNTIL, RADEON_WAIT_3D_IDLECLEAN);
-		OUT_BATCH_REGVAL(R300_SC_SCREENDOOR, 0xffffff);
-		OUT_BATCH_REGVAL(R300_VAP_PVS_STATE_FLUSH_REG, 1);
+
+		if (r300->vap_flush_needed) {
+			BEGIN_BATCH_NO_AUTOSTATE(15 + ndw);
+
+			/* flush processing vertices */
+			OUT_BATCH_REGVAL(R300_SC_SCREENDOOR, 0);
+			OUT_BATCH_REGVAL(R300_RB3D_DSTCACHE_CTLSTAT, R300_RB3D_DSTCACHE_CTLSTAT_DC_FLUSH_FLUSH_DIRTY_3D);
+			OUT_BATCH_REGVAL(RADEON_WAIT_UNTIL, RADEON_WAIT_3D_IDLECLEAN);
+			OUT_BATCH_REGVAL(R300_SC_SCREENDOOR, 0xffffff);
+			OUT_BATCH_REGVAL(R300_VAP_PVS_STATE_FLUSH_REG, 0);
+			r300->vap_flush_needed = GL_FALSE;
+		} else {
+			BEGIN_BATCH_NO_AUTOSTATE(5 + ndw);
+		}
 		OUT_BATCH_REGVAL(R300_VAP_PVS_UPLOAD_ADDRESS, addr);
 		OUT_BATCH(CP_PACKET0(R300_VAP_PVS_UPLOAD_DATA, ndw-1) | RADEON_ONE_REG_WR);
 		for (i = 0; i < ndw; i++) {
@@ -162,39 +168,42 @@ static void emit_tex_offsets(GLcontext *ctx, struct radeon_state_atom * atom)
 	r300ContextPtr r300 = R300_CONTEXT(ctx);
 	BATCH_LOCALS(&r300->radeon);
 	int numtmus = packet0_count(r300, r300->hw.tex.offset.cmd);
+	int notexture = 0;
 
 	if (numtmus) {
 		int i;
 
 		for(i = 0; i < numtmus; ++i) {
 		    radeonTexObj *t = r300->hw.textures[i];
+		
+		    if (!t)
+			notexture = 1;
+		}
+
+		if (r300->radeon.radeonScreen->kernel_mm && notexture) {
+			return;
+		}
+		BEGIN_BATCH_NO_AUTOSTATE(4 * numtmus);
+		for(i = 0; i < numtmus; ++i) {
+		    radeonTexObj *t = r300->hw.textures[i];
+		    OUT_BATCH_REGSEQ(R300_TX_OFFSET_0 + (i * 4), 1);
 		    if (t && !t->image_override) {
-		            BEGIN_BATCH_NO_AUTOSTATE(4);
-		            OUT_BATCH_REGSEQ(R300_TX_OFFSET_0 + (i * 4), 1);
 			    OUT_BATCH_RELOC(t->tile_bits, t->mt->bo, 0,
 					    RADEON_GEM_DOMAIN_VRAM, 0, 0);
-		            END_BATCH();
 		    } else if (!t) {
-			    //assert(0);
-		            BEGIN_BATCH_NO_AUTOSTATE(4);
-		            OUT_BATCH_REGSEQ(R300_TX_OFFSET_0 + (i * 4), 1);
 			    OUT_BATCH(r300->radeon.radeonScreen->texOffset[0]);
-			    END_BATCH();
-		    } else {
+		    } else { /* override cases */
 			    if (t->bo) {
-		            	    BEGIN_BATCH_NO_AUTOSTATE(4);
-		                    OUT_BATCH_REGSEQ(R300_TX_OFFSET_0 + (i * 4), 1);
 				    OUT_BATCH_RELOC(t->tile_bits, t->bo, 0,
 						    RADEON_GEM_DOMAIN_VRAM, 0, 0);
-		                    END_BATCH();
 			    } else if (!r300->radeon.radeonScreen->kernel_mm) {
-		            	    BEGIN_BATCH_NO_AUTOSTATE(2);
-		                    OUT_BATCH_REGSEQ(R300_TX_OFFSET_0 + (i * 4), 1);
 				    OUT_BATCH(t->override_offset);
-				    END_BATCH();
 			    }
+			    else
+			    	OUT_BATCH(r300->radeon.radeonScreen->texOffset[0]);
 		    }
 		}
+		END_BATCH();
 	}
 }
 
@@ -254,6 +263,33 @@ static void emit_zb_offset(GLcontext *ctx, struct radeon_state_atom * atom)
 	END_BATCH();
 }
 
+static void emit_zstencil_format(GLcontext *ctx, struct radeon_state_atom * atom)
+{
+	r300ContextPtr r300 = R300_CONTEXT(ctx);
+	BATCH_LOCALS(&r300->radeon);
+	struct radeon_renderbuffer *rrb;
+	uint32_t zbpitch;
+	uint32_t format;
+
+	rrb = radeon_get_depthbuffer(&r300->radeon);
+	if (!rrb)
+	  format = 0;
+	else {
+	  if (rrb->cpp == 2)
+	    format = R300_DEPTHFORMAT_16BIT_INT_Z;
+	  else if (rrb->cpp == 4)
+	    format = R300_DEPTHFORMAT_24BIT_INT_Z_8BIT_STENCIL;
+	}
+
+	OUT_BATCH(atom->cmd[0]);
+	atom->cmd[1] &= ~(3 << 0);
+	atom->cmd[1] |= format;
+	OUT_BATCH(atom->cmd[1]);
+	OUT_BATCH(atom->cmd[2]);
+	OUT_BATCH(atom->cmd[3]);
+	OUT_BATCH(atom->cmd[4]);
+}
+
 static int check_always(GLcontext *ctx, struct radeon_state_atom *atom)
 {
 	return atom->cmd_size;
@@ -512,9 +548,12 @@ void r300InitCmdBuf(r300ContextPtr r300)
 	ALLOC_STATE(zs, always, R300_ZS_CMDSIZE, 0);
 	r300->hw.zs.cmd[R300_ZS_CMD_0] =
 	    cmdpacket0(r300->radeon.radeonScreen, R300_ZB_CNTL, 3);
+
 	ALLOC_STATE(zstencil_format, always, 5, 0);
 	r300->hw.zstencil_format.cmd[0] =
 	    cmdpacket0(r300->radeon.radeonScreen, R300_ZB_FORMAT, 4);
+	r300->hw.zstencil_format.emit = emit_zstencil_format;
+
 	ALLOC_STATE(zb, always, R300_ZB_CMDSIZE, 0);
 	r300->hw.zb.emit = emit_zb_offset;
 	ALLOC_STATE(zb_depthclearvalue, always, 2, 0);
diff --git a/src/mesa/drivers/dri/r300/r300_context.c b/src/mesa/drivers/dri/r300/r300_context.c
index dd63add..5d497ef 100644
--- a/src/mesa/drivers/dri/r300/r300_context.c
+++ b/src/mesa/drivers/dri/r300/r300_context.c
@@ -235,7 +235,11 @@ static void r300_vtbl_emit_cs_header(struct radeon_cs *cs, radeonContextPtr rmes
 
 static void r300_vtbl_pre_emit_atoms(radeonContextPtr radeon)
 {
+   r300ContextPtr r300 = (r300ContextPtr)radeon;
    BATCH_LOCALS(radeon);
+
+   r300->vap_flush_needed = GL_TRUE;
+
    cp_wait(radeon, R300_WAIT_3D | R300_WAIT_3D_CLEAN);
    BEGIN_BATCH_NO_AUTOSTATE(2);
    OUT_BATCH_REGVAL(R300_TX_INVALTAGS, R300_TX_FLUSH);
diff --git a/src/mesa/drivers/dri/r300/r300_context.h b/src/mesa/drivers/dri/r300/r300_context.h
index 6d34727..37718f5 100644
--- a/src/mesa/drivers/dri/r300/r300_context.h
+++ b/src/mesa/drivers/dri/r300/r300_context.h
@@ -683,7 +683,9 @@ struct r300_context {
 	GLboolean disable_lowimpact_fallback;
 
 	DECLARE_RENDERINPUTS(tnl_index_bitset);	/* index of bits for last tnl_install_attrs */
+	
 	struct r300_swtcl_info swtcl;
+	GLboolean vap_flush_needed;
 };
 
 struct r300_buffer_object {
diff --git a/src/mesa/drivers/dri/r300/r300_ioctl.c b/src/mesa/drivers/dri/r300/r300_ioctl.c
index 90b85f0..619d268 100644
--- a/src/mesa/drivers/dri/r300/r300_ioctl.c
+++ b/src/mesa/drivers/dri/r300/r300_ioctl.c
@@ -528,6 +528,8 @@ static void r300EmitClearState(GLcontext * ctx)
                                       PVS_SRC_SELECT_FORCE_0,
                                       PVS_SRC_REG_INPUT, VSF_FLAG_NONE);
 		vpu.cmd[8] = 0x0;
+
+		r300->vap_flush_needed = GL_TRUE;
 		emit_vpu(ctx, &vpu);
 	}
 }
@@ -612,25 +614,9 @@ static void r300Clear(GLcontext * ctx, GLbitfield mask)
 	COMMIT_BATCH();
 }
 
-void r300Flush(GLcontext * ctx)
-{
-	r300ContextPtr rmesa = R300_CONTEXT(ctx);
-
-	if (RADEON_DEBUG & DEBUG_IOCTL)
-		fprintf(stderr, "%s\n", __FUNCTION__);
-
-	if (rmesa->radeon.dma.flush) {
-		rmesa->radeon.dma.flush(ctx);
-	}
-	
-	if (rmesa->radeon.cmdbuf.cs->cdw) {
-		rcommonFlushCmdBuf(&rmesa->radeon, __FUNCTION__);
-	}
-}
-
 void r300InitIoctlFuncs(struct dd_function_table *functions)
 {
 	functions->Clear = r300Clear;
 	functions->Finish = radeonFinish;
-	functions->Flush = r300Flush;
+	functions->Flush = radeonFlush;
 }
diff --git a/src/mesa/drivers/dri/r300/r300_ioctl.h b/src/mesa/drivers/dri/r300/r300_ioctl.h
index 5f00264..3abfa71 100644
--- a/src/mesa/drivers/dri/r300/r300_ioctl.h
+++ b/src/mesa/drivers/dri/r300/r300_ioctl.h
@@ -39,13 +39,6 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "r300_context.h"
 #include "radeon_drm.h"
 
-extern void r300Flush(GLcontext * ctx);
-
-extern void r300AllocDmaRegion(r300ContextPtr rmesa,
-			       struct radeon_bo **pbo, int *poffset,
-			       int bytes, int alignment);
-
 extern void r300InitIoctlFuncs(struct dd_function_table *functions);
 
-extern void r300RefillCurrentDmaRegion(r300ContextPtr rmesa, int size);
 #endif				/* __R300_IOCTL_H__ */
diff --git a/src/mesa/drivers/dri/r300/r300_state.c b/src/mesa/drivers/dri/r300/r300_state.c
index 93ef06f..59728a0 100644
--- a/src/mesa/drivers/dri/r300/r300_state.c
+++ b/src/mesa/drivers/dri/r300/r300_state.c
@@ -2367,18 +2367,6 @@ static void r300ResetHwState(r300ContextPtr r300)
 
 	r300->hw.zb_depthclearvalue.cmd[1] = 0;
 
-	switch (ctx->Visual.depthBits) {
-	case 16:
-		r300->hw.zstencil_format.cmd[1] = R300_DEPTHFORMAT_16BIT_INT_Z;
-		break;
-	case 24:
-		r300->hw.zstencil_format.cmd[1] = R300_DEPTHFORMAT_24BIT_INT_Z_8BIT_STENCIL;
-		break;
-	default:
-		fprintf(stderr, "Error: Unsupported depth %d... exiting\n", ctx->Visual.depthBits);
-		_mesa_exit(-1);
-	}
-
 	r300->hw.zstencil_format.cmd[2] = R300_ZTOP_DISABLE;
 	r300->hw.zstencil_format.cmd[3] = 0x00000003;
 	r300->hw.zstencil_format.cmd[4] = 0x00000000;
@@ -2683,21 +2671,6 @@ void r300InitState(r300ContextPtr r300)
 	GLcontext *ctx = r300->radeon.glCtx;
 	GLuint depth_fmt;
 
-	switch (ctx->Visual.depthBits) {
-	case 16:
-		r300->radeon.state.depth.scale = 1.0 / (GLfloat) 0xffff;
-		depth_fmt = R300_DEPTHFORMAT_16BIT_INT_Z;
-		break;
-	case 24:
-		r300->radeon.state.depth.scale = 1.0 / (GLfloat) 0xffffff;
-		depth_fmt = R300_DEPTHFORMAT_24BIT_INT_Z_8BIT_STENCIL;
-		break;
-	default:
-		fprintf(stderr, "Error: Unsupported depth %d... exiting\n",
-			ctx->Visual.depthBits);
-		_mesa_exit(-1);
-	}
-
 	/* Only have hw stencil when depth buffer is 24 bits deep */
 	r300->radeon.state.stencil.hwBuffer = (ctx->Visual.stencilBits > 0 &&
 					       ctx->Visual.depthBits == 24);
@@ -2742,7 +2715,8 @@ static void r300DrawBuffer( GLcontext *ctx, GLenum mode )
 	radeon_firevertices(&rmesa->radeon);	/* don't pipeline cliprect changes */
 
 	radeonSetCliprects( &rmesa->radeon );
-	radeonUpdatePageFlipping(&rmesa->radeon);
+        if (!rmesa->radeon.radeonScreen->driScreen->dri2.enabled) 
+		radeonUpdatePageFlipping(&rmesa->radeon);
 }
 
 static void r300ReadBuffer( GLcontext *ctx, GLenum mode )
diff --git a/src/mesa/drivers/dri/r300/r300_tex.c b/src/mesa/drivers/dri/r300/r300_tex.c
index 27b9070..0f5afbf 100644
--- a/src/mesa/drivers/dri/r300/r300_tex.c
+++ b/src/mesa/drivers/dri/r300/r300_tex.c
@@ -270,6 +270,11 @@ static void r300DeleteTexture(GLcontext * ctx, struct gl_texture_object *texObj)
 				rmesa->hw.textures[i] = 0;
 	}
 
+	if (t->bo) {
+		radeon_bo_unref(t->bo);
+		t->bo = NULL;
+	}
+
 	if (t->mt) {
 		radeon_miptree_unreference(t->mt);
 		t->mt = 0;
diff --git a/src/mesa/drivers/dri/r300/r300_texstate.c b/src/mesa/drivers/dri/r300/r300_texstate.c
index 25cd4d8..8a90069 100644
--- a/src/mesa/drivers/dri/r300/r300_texstate.c
+++ b/src/mesa/drivers/dri/r300/r300_texstate.c
@@ -216,7 +216,7 @@ static void setup_hardware_state(r300ContextPtr rmesa, radeonTexObj *t)
 		return;
 	}
 
-	if (t->image_override)
+	if (t->image_override && t->bo)
 		return;
 
 	t->pp_txsize = (((firstImage->Width - 1) << R300_TX_WIDTHMASK_SHIFT)
@@ -330,7 +330,7 @@ again:
 	if (ret == RADEON_CS_SPACE_OP_TO_BIG)
 		return GL_FALSE;
 	if (ret == RADEON_CS_SPACE_FLUSH) {
-		r300Flush(ctx);
+		radeonFlush(ctx);
 		if (flushed)
 			return GL_FALSE;
 		flushed = 1;
@@ -433,9 +433,15 @@ void r300SetTexBuffer(__DRIcontext *pDRICtx, GLint target, __DRIdrawable *dPriv)
 	
 	_mesa_lock_texture(radeon->glCtx, texObj);
 	if (t->bo) {
+		radeon_bo_unref(t->bo);
 		t->bo = NULL;
 	}
+	if (rImage->bo) {
+		radeon_bo_unref(rImage->bo);
+		rImage->bo = NULL;
+	}
 	if (t->mt) {
+		radeon_miptree_unreference(t->mt);
 		t->mt = NULL;
 	}
 	if (rImage->mt) {
@@ -447,7 +453,7 @@ void r300SetTexBuffer(__DRIcontext *pDRICtx, GLint target, __DRIdrawable *dPriv)
 				   rb->width, rb->height, 1, 0, rb->cpp);
 	texImage->TexFormat = &_mesa_texformat_rgba8888_rev;
 	rImage->bo = rb->bo;
-	
+	radeon_bo_ref(rImage->bo);
 	t->bo = rb->bo;
 	radeon_bo_ref(t->bo);
 	t->tile_bits = 0;
@@ -478,6 +484,13 @@ void r300SetTexBuffer(__DRIcontext *pDRICtx, GLint target, __DRIdrawable *dPriv)
               ((rb->height - 1) << R300_TX_HEIGHTMASK_SHIFT);
 	t->pp_txsize |= R300_TX_SIZE_TXPITCH_EN;
 	t->pp_txpitch |= pitch_val;
+
+	if (rmesa->radeon.radeonScreen->chip_family >= CHIP_FAMILY_RV515) {
+	    if (rb->width > 2048)
+		t->pp_txpitch |= R500_TXWIDTH_BIT11;
+	    if (rb->height > 2048)
+		t->pp_txpitch |= R500_TXHEIGHT_BIT11;
+	}
 	t->validated = GL_TRUE;
 	_mesa_unlock_texture(radeon->glCtx, texObj);
 	return;
diff --git a/src/mesa/drivers/dri/radeon/radeon_ioctl.c b/src/mesa/drivers/dri/radeon/radeon_ioctl.c
index fb3a236..b5ab923 100644
--- a/src/mesa/drivers/dri/radeon/radeon_ioctl.c
+++ b/src/mesa/drivers/dri/radeon/radeon_ioctl.c
@@ -116,13 +116,26 @@ extern void radeonEmitVbufPrim( r100ContextPtr rmesa,
 #if RADEON_OLD_PACKETS
    BEGIN_BATCH(8);
    OUT_BATCH_PACKET3_CLIP(RADEON_CP_PACKET3_3D_RNDR_GEN_INDX_PRIM, 3);
-   OUT_BATCH_RELOC(rmesa->ioctl.vertex_offset, rmesa->ioctl.bo, rmesa->ioctl.vertex_offset, RADEON_GEM_DOMAIN_GTT, 0, 0);
+   if (!rmesa->radeon.radeonScreen->kernel_mm) {
+     OUT_BATCH_RELOC(rmesa->ioctl.vertex_offset, rmesa->ioctl.bo, rmesa->ioctl.vertex_offset, RADEON_GEM_DOMAIN_GTT, 0, 0);
+   } else {
+     OUT_BATCH(rmesa->ioctl.vertex_offset);
+   }
+    
    OUT_BATCH(vertex_nr);
    OUT_BATCH(vertex_format);
    OUT_BATCH(primitive |  RADEON_CP_VC_CNTL_PRIM_WALK_LIST |
 	     RADEON_CP_VC_CNTL_COLOR_ORDER_RGBA |
 	     RADEON_CP_VC_CNTL_VTX_FMT_RADEON_MODE |
 	     (vertex_nr << RADEON_CP_VC_CNTL_NUM_SHIFT));
+
+   if (rmesa->radeon.radeonScreen->kernel_mm) {
+     radeon_cs_write_reloc(rmesa->radeon.cmdbuf.cs,
+			   rmesa->ioctl.bo,
+			   RADEON_GEM_DOMAIN_GTT,
+			   0, 0);
+   }
+   
    END_BATCH();
    
 #else   
@@ -155,7 +168,11 @@ void radeonFlushElts( GLcontext *ctx )
 
    nr = rmesa->tcl.elt_used;
 
-   rmesa->radeon.cmdbuf.cs->cdw += dwords;
+#if RADEON_OLD_PACKETS
+   if (rmesa->radeon.radeonScreen->kernel_mm) {
+     dwords -= 2;
+   }
+#endif
 
 #if RADEON_OLD_PACKETS
    cmd[1] |= (dwords + 3) << 16;
@@ -165,7 +182,18 @@ void radeonFlushElts( GLcontext *ctx )
    cmd[3] |= nr << RADEON_CP_VC_CNTL_NUM_SHIFT;
 #endif
 
+   rmesa->radeon.cmdbuf.cs->cdw += dwords;
    rmesa->radeon.cmdbuf.cs->section_cdw += dwords;
+
+#if RADEON_OLD_PACKETS
+   if (rmesa->radeon.radeonScreen->kernel_mm) {
+      radeon_cs_write_reloc(rmesa->radeon.cmdbuf.cs,
+			    rmesa->ioctl.bo,
+			    RADEON_GEM_DOMAIN_GTT,
+			    0, 0);
+   }
+#endif
+
    END_BATCH();
 
    if (RADEON_DEBUG & DEBUG_SYNC) {
@@ -199,7 +227,11 @@ GLushort *radeonAllocEltsOpenEnded( r100ContextPtr rmesa,
 #if RADEON_OLD_PACKETS
    BEGIN_BATCH_NO_AUTOSTATE(2+ELTS_BUFSZ(align_min_nr)/4);
    OUT_BATCH_PACKET3_CLIP(RADEON_CP_PACKET3_3D_RNDR_GEN_INDX_PRIM, 0);
-   OUT_BATCH_RELOC(rmesa->ioctl.vertex_offset, rmesa->ioctl.bo, rmesa->ioctl.vertex_offset, RADEON_GEM_DOMAIN_GTT, 0, 0);
+   if (!rmesa->radeon.radeonScreen->kernel_mm) {
+     OUT_BATCH_RELOC(rmesa->ioctl.vertex_offset, rmesa->ioctl.bo, rmesa->ioctl.vertex_offset, RADEON_GEM_DOMAIN_GTT, 0, 0);
+   } else {
+     OUT_BATCH(rmesa->ioctl.vertex_offset);
+   }
    OUT_BATCH(0xffff);
    OUT_BATCH(vertex_format);
    OUT_BATCH(primitive | 
diff --git a/src/mesa/drivers/dri/radeon/radeon_screen.c b/src/mesa/drivers/dri/radeon/radeon_screen.c
index 086a268..c591e9f 100644
--- a/src/mesa/drivers/dri/radeon/radeon_screen.c
+++ b/src/mesa/drivers/dri/radeon/radeon_screen.c
@@ -983,20 +983,22 @@ radeonCreateScreen( __DRIscreenPrivate *sPriv )
        screen->extensions[i++] = &driMediaStreamCounterExtension.base;
    }
 
+   if (!screen->kernel_mm) {
 #if !RADEON_COMMON
-   screen->extensions[i++] = &radeonTexOffsetExtension.base;
+   	screen->extensions[i++] = &radeonTexOffsetExtension.base;
 #endif
 
 #if RADEON_COMMON && defined(RADEON_COMMON_FOR_R200)
-   if (IS_R200_CLASS(screen))
-       screen->extensions[i++] = &r200AllocateExtension.base;
+        if (IS_R200_CLASS(screen))
+            screen->extensions[i++] = &r200AllocateExtension.base;
 
-   screen->extensions[i++] = &r200texOffsetExtension.base;
+        screen->extensions[i++] = &r200texOffsetExtension.base;
 #endif
 
 #if RADEON_COMMON && defined(RADEON_COMMON_FOR_R300)
-   //screen->extensions[i++] = &r300texOffsetExtension.base;
+        screen->extensions[i++] = &r300texOffsetExtension.base;
 #endif
+   }
 
    screen->extensions[i++] = NULL;
    sPriv->extensions = screen->extensions;
@@ -1090,7 +1092,7 @@ radeonCreateScreen2(__DRIscreenPrivate *sPriv)
 #endif
 
 #if RADEON_COMMON && defined(RADEON_COMMON_FOR_R300)
-   screen->extensions[i++] = &r300texOffsetExtension.base;
+   //screen->extensions[i++] = &r300texOffsetExtension.base;
    screen->extensions[i++] = &r300TexBufferExtension.base;
 #endif
 
@@ -1436,6 +1438,7 @@ radeonInitScreen(__DRIscreenPrivate *psp)
 			     (dri_priv->bpp == 16) ? 16 : 24,
 			     (dri_priv->bpp == 16) ? 0  : 8, 1);
 }
+#define ARRAY_SIZE(a) (sizeof (a) / sizeof ((a)[0]))
 
 /**
  * This is the driver specific part of the createNewScreen entry point.
@@ -1446,6 +1449,18 @@ radeonInitScreen(__DRIscreenPrivate *psp)
 static const
 __DRIconfig **radeonInitScreen2(__DRIscreenPrivate *psp)
 {
+   GLenum fb_format[3];
+   GLenum fb_type[3];
+   /* GLX_SWAP_COPY_OML is only supported because the Intel driver doesn't
+    * support pageflipping at all.
+    */
+   static const GLenum back_buffer_modes[] = {
+     GLX_NONE, GLX_SWAP_UNDEFINED_OML, /*, GLX_SWAP_COPY_OML*/
+   };
+   uint8_t depth_bits[4], stencil_bits[4], msaa_samples_array[1];
+   int color;
+   __DRIconfig **configs = NULL;
+
    /* Calling driInitExtensions here, with a NULL context pointer,
     * does not actually enable the extensions.  It just makes sure
     * that all the dispatch offsets for all the extensions that
@@ -1468,9 +1483,50 @@ __DRIconfig **radeonInitScreen2(__DRIscreenPrivate *psp)
    if (!radeonInitDriver(psp)) {
        return NULL;
     }
+   depth_bits[0] = 0;
+   stencil_bits[0] = 0;
+   depth_bits[1] = 16;
+   stencil_bits[1] = 0;
+   depth_bits[2] = 24;
+   stencil_bits[2] = 0;
+   depth_bits[3] = 24;
+   stencil_bits[3] = 8;
+
+   msaa_samples_array[0] = 0;
+
+   fb_format[0] = GL_RGB;
+   fb_type[0] = GL_UNSIGNED_SHORT_5_6_5;
+
+   fb_format[1] = GL_BGR;
+   fb_type[1] = GL_UNSIGNED_INT_8_8_8_8_REV;
+
+   fb_format[2] = GL_BGRA;
+   fb_type[2] = GL_UNSIGNED_INT_8_8_8_8_REV;
+
+   for (color = 0; color < ARRAY_SIZE(fb_format); color++) {
+      __DRIconfig **new_configs;
+
+      new_configs = driCreateConfigs(fb_format[color], fb_type[color],
+				     depth_bits,
+				     stencil_bits,
+				     ARRAY_SIZE(depth_bits),
+				     back_buffer_modes,
+				     ARRAY_SIZE(back_buffer_modes),
+				     msaa_samples_array,
+				     ARRAY_SIZE(msaa_samples_array));
+      if (configs == NULL)
+	 configs = new_configs;
+      else
+	 configs = driConcatConfigs(configs, new_configs);
+   }
 
-   /* for now fill in all modes */
-   return radeonFillInModes( psp, 24, 24, 8, 1);
+   if (configs == NULL) {
+      fprintf(stderr, "[%s:%u] Error creating FBConfig!\n", __func__,
+              __LINE__);
+      return NULL;
+   }
+
+   return (const __DRIconfig **)configs;
 }
 
 /**
@@ -1536,6 +1592,7 @@ const struct __DriverAPIRec driDriverAPI = {
    .WaitForSBC      = NULL,
    .SwapBuffersMSC  = NULL,
    .CopySubBuffer   = radeonCopySubBuffer,
+   .InitScreen2     = radeonInitScreen2,
 };
 #endif
 
diff --git a/src/mesa/drivers/dri/radeon/radeon_state.c b/src/mesa/drivers/dri/radeon/radeon_state.c
index 86d8720..5fffa28 100644
--- a/src/mesa/drivers/dri/radeon/radeon_state.c
+++ b/src/mesa/drivers/dri/radeon/radeon_state.c
@@ -1563,7 +1563,8 @@ static void radeonDrawBuffer( GLcontext *ctx, GLenum mode )
    }
 
    radeonSetCliprects( &rmesa->radeon );
-   radeonUpdatePageFlipping(&rmesa->radeon);
+   if (!rmesa->radeon.radeonScreen->driScreen->dri2.enabled)
+      radeonUpdatePageFlipping(&rmesa->radeon);
    /* We'll set the drawing engine's offset/pitch parameters later
     * when we update other state.
     */
diff --git a/src/mesa/drivers/dri/radeon/radeon_state_init.c b/src/mesa/drivers/dri/radeon/radeon_state_init.c
index 617e731..7ff0eb4 100644
--- a/src/mesa/drivers/dri/radeon/radeon_state_init.c
+++ b/src/mesa/drivers/dri/radeon/radeon_state_init.c
@@ -288,7 +288,8 @@ static void scl_emit(GLcontext *ctx, struct radeon_state_atom *atom)
    r100ContextPtr r100 = R100_CONTEXT(ctx);
    BATCH_LOCALS(&r100->radeon);
    uint32_t dwords = atom->cmd_size;
-
+   
+   dwords += 2;
    BEGIN_BATCH_NO_AUTOSTATE(dwords);
    OUT_SCL(atom->cmd[0], atom->cmd+1);
    END_BATCH();
@@ -301,48 +302,75 @@ static void vec_emit(GLcontext *ctx, struct radeon_state_atom *atom)
    BATCH_LOCALS(&r100->radeon);
    uint32_t dwords = atom->cmd_size;
 
+   dwords += 4;
    BEGIN_BATCH_NO_AUTOSTATE(dwords);
    OUT_VEC(atom->cmd[0], atom->cmd+1);
    END_BATCH();
 }
 
+
+static void lit_emit(GLcontext *ctx, struct radeon_state_atom *atom)
+{
+   r100ContextPtr r100 = R100_CONTEXT(ctx);
+   BATCH_LOCALS(&r100->radeon);
+   uint32_t dwords = atom->cmd_size;
+
+   dwords += 6;
+   BEGIN_BATCH_NO_AUTOSTATE(dwords);
+   OUT_VEC(atom->cmd[LIT_CMD_0], atom->cmd+1);
+   OUT_SCL(atom->cmd[LIT_CMD_1], atom->cmd+LIT_CMD_1+1);
+   END_BATCH();
+}
+
 static void ctx_emit(GLcontext *ctx, struct radeon_state_atom *atom)
 {
    r100ContextPtr r100 = R100_CONTEXT(ctx);
    BATCH_LOCALS(&r100->radeon);
    struct radeon_renderbuffer *rrb;
    uint32_t cbpitch;
-   uint32_t zbpitch;
+   uint32_t zbpitch, depth_fmt;
    uint32_t dwords = atom->cmd_size;
-   GLframebuffer *fb = r100->radeon.dri.drawable->driverPrivate;
 
    /* output the first 7 bytes of context */
    BEGIN_BATCH_NO_AUTOSTATE(dwords + 4);
    OUT_BATCH_TABLE(atom->cmd, 5);
 
-   rrb = r100->radeon.state.depth.rrb;
+   rrb = radeon_get_depthbuffer(&r100->radeon);
    if (!rrb) {
      OUT_BATCH(0);
      OUT_BATCH(0);
    } else {
      zbpitch = (rrb->pitch / rrb->cpp);
+     if (r100->using_hyperz)
+       zbpitch |= RADEON_DEPTH_HYPERZ;
+
      OUT_BATCH_RELOC(0, rrb->bo, 0, 0, RADEON_GEM_DOMAIN_VRAM, 0);
      OUT_BATCH(zbpitch);
+     if (rrb->cpp == 4)
+        depth_fmt = RADEON_DEPTH_FORMAT_24BIT_INT_Z;
+     else
+        depth_fmt = RADEON_DEPTH_FORMAT_16BIT_INT_Z;
+     atom->cmd[CTX_RB3D_ZSTENCILCNTL] &= ~RADEON_DEPTH_FORMAT_MASK;
+     atom->cmd[CTX_RB3D_ZSTENCILCNTL] |= depth_fmt;
    }
      
    OUT_BATCH(atom->cmd[CTX_RB3D_ZSTENCILCNTL]);
    OUT_BATCH(atom->cmd[CTX_CMD_1]);
    OUT_BATCH(atom->cmd[CTX_PP_CNTL]);
-   OUT_BATCH(atom->cmd[CTX_RB3D_CNTL]);
 
-   rrb = r100->radeon.state.color.rrb;
-   if (r100->radeon.radeonScreen->driScreen->dri2.enabled) {
-      rrb = (struct radeon_renderbuffer *)fb->Attachment[BUFFER_BACK_LEFT].Renderbuffer;
-   }
+   rrb = radeon_get_colorbuffer(&r100->radeon);
    if (!rrb || !rrb->bo) {
-     OUT_BATCH(atom->cmd[CTX_RB3D_COLOROFFSET]);
+      OUT_BATCH(atom->cmd[CTX_RB3D_CNTL]);
+      OUT_BATCH(atom->cmd[CTX_RB3D_COLOROFFSET]);
    } else {
-     OUT_BATCH_RELOC(0, rrb->bo, 0, 0, RADEON_GEM_DOMAIN_VRAM, 0);
+      atom->cmd[CTX_RB3D_CNTL] &= ~(0xf << 10);
+      if (rrb->cpp == 4)
+         atom->cmd[CTX_RB3D_CNTL] |= RADEON_COLOR_FORMAT_ARGB8888;
+      else
+         atom->cmd[CTX_RB3D_CNTL] |= RADEON_COLOR_FORMAT_RGB565;
+
+      OUT_BATCH(atom->cmd[CTX_RB3D_CNTL]);
+      OUT_BATCH_RELOC(0, rrb->bo, 0, 0, RADEON_GEM_DOMAIN_VRAM, 0);
    }
 
    OUT_BATCH(atom->cmd[CTX_CMD_2]);
@@ -351,12 +379,8 @@ static void ctx_emit(GLcontext *ctx, struct radeon_state_atom *atom)
      OUT_BATCH(atom->cmd[CTX_RB3D_COLORPITCH]);
    } else {
      cbpitch = (rrb->pitch / rrb->cpp);
-     if (rrb->cpp == 4)
-       ;
-     else
-       ;
-     if (r100->radeon.sarea->tiling_enabled)
-       cbpitch |= R200_COLOR_TILE_ENABLE;
+     if (rrb->bo->flags & RADEON_BO_FLAGS_MACRO_TILE)
+       cbpitch |= RADEON_COLOR_TILE_ENABLE;
      OUT_BATCH(cbpitch);
    }
 
@@ -371,24 +395,41 @@ static void ctx_emit_cs(GLcontext *ctx, struct radeon_state_atom *atom)
    uint32_t cbpitch = 0;
    uint32_t zbpitch = 0;
    uint32_t dwords = atom->cmd_size;
-   GLframebuffer *fb = r100->radeon.dri.drawable->driverPrivate;
+   uint32_t depth_fmt;
 
-   rrb = r100->radeon.state.color.rrb;
-   if (r100->radeon.radeonScreen->driScreen->dri2.enabled) {
-      rrb = (struct radeon_renderbuffer *)fb->Attachment[BUFFER_BACK_LEFT].Renderbuffer;
+   rrb = radeon_get_colorbuffer(&r100->radeon);
+   if (!rrb || !rrb->bo) {
+      fprintf(stderr, "no rrb\n");
+      return;
    }
-   if (rrb) {
-     assert(rrb->bo != NULL);
-     cbpitch = (rrb->pitch / rrb->cpp);
-     if (r100->radeon.sarea->tiling_enabled)
+
+   atom->cmd[CTX_RB3D_CNTL] &= ~(0xf << 10);
+   if (rrb->cpp == 4)
+	atom->cmd[CTX_RB3D_CNTL] |= RADEON_COLOR_FORMAT_ARGB8888;
+   else
+	atom->cmd[CTX_RB3D_CNTL] |= RADEON_COLOR_FORMAT_RGB565;
+
+   cbpitch = (rrb->pitch / rrb->cpp);
+   if (rrb->bo->flags & RADEON_BO_FLAGS_MACRO_TILE)
        cbpitch |= R200_COLOR_TILE_ENABLE;
-   }
 
-   drb = r100->radeon.state.depth.rrb;
-   if (drb)
+   drb = radeon_get_depthbuffer(&r100->radeon);
+   if (drb) {
      zbpitch = (drb->pitch / drb->cpp);
+     if (drb->cpp == 4)
+        depth_fmt = RADEON_DEPTH_FORMAT_24BIT_INT_Z;
+     else
+        depth_fmt = RADEON_DEPTH_FORMAT_16BIT_INT_Z;
+     atom->cmd[CTX_RB3D_ZSTENCILCNTL] &= ~RADEON_DEPTH_FORMAT_MASK;
+     atom->cmd[CTX_RB3D_ZSTENCILCNTL] |= depth_fmt;
+     
+   }
 
    /* output the first 7 bytes of context */
+   if (drb)
+     dwords += 4;
+   if (rrb)
+     dwords += 4;
    BEGIN_BATCH_NO_AUTOSTATE(dwords);
 
    /* In the CS case we need to split this up */
@@ -409,17 +450,12 @@ static void ctx_emit_cs(GLcontext *ctx, struct radeon_state_atom *atom)
    OUT_BATCH(atom->cmd[CTX_PP_CNTL]);
    OUT_BATCH(atom->cmd[CTX_RB3D_CNTL]);
 
-
    if (rrb) {
      OUT_BATCH(CP_PACKET0(RADEON_RB3D_COLOROFFSET, 0));
      OUT_BATCH_RELOC(0, rrb->bo, 0, 0, RADEON_GEM_DOMAIN_VRAM, 0);
    }
 
    if (rrb) {
-     if (rrb->cpp == 4)
-       ;
-     else
-       ;
      OUT_BATCH(CP_PACKET0(RADEON_RB3D_COLORPITCH, 0));
      OUT_BATCH(cbpitch);
    }
@@ -497,20 +533,7 @@ static void tex_emit(GLcontext *ctx, struct radeon_state_atom *atom)
 void radeonInitState( r100ContextPtr rmesa )
 {
    GLcontext *ctx = rmesa->radeon.glCtx;
-   GLuint color_fmt, depth_fmt, i;
-   GLint drawPitch, drawOffset;
-
-   switch ( rmesa->radeon.radeonScreen->cpp ) {
-   case 2:
-      color_fmt = RADEON_COLOR_FORMAT_RGB565;
-      break;
-   case 4:
-      color_fmt = RADEON_COLOR_FORMAT_ARGB8888;
-      break;
-   default:
-      fprintf( stderr, "Error: Unsupported pixel depth... exiting\n" );
-      exit( -1 );
-   }
+   GLuint i;
 
    rmesa->radeon.state.color.clear = 0x00000000;
 
@@ -518,13 +541,11 @@ void radeonInitState( r100ContextPtr rmesa )
    case 16:
       rmesa->radeon.state.depth.clear = 0x0000ffff;
       rmesa->radeon.state.depth.scale = 1.0 / (GLfloat)0xffff;
-      depth_fmt = RADEON_DEPTH_FORMAT_16BIT_INT_Z;
       rmesa->radeon.state.stencil.clear = 0x00000000;
       break;
    case 24:
       rmesa->radeon.state.depth.clear = 0x00ffffff;
       rmesa->radeon.state.depth.scale = 1.0 / (GLfloat)0xffffff;
-      depth_fmt = RADEON_DEPTH_FORMAT_24BIT_INT_Z;
       rmesa->radeon.state.stencil.clear = 0xffff0000;
       break;
    default:
@@ -539,13 +560,6 @@ void radeonInitState( r100ContextPtr rmesa )
 
    rmesa->radeon.Fallback = 0;
 
-   if ( ctx->Visual.doubleBufferMode && rmesa->radeon.sarea->pfCurrentPage == 0 ) {
-      drawOffset = rmesa->radeon.radeonScreen->backOffset;
-      drawPitch  = rmesa->radeon.radeonScreen->backPitch;
-   } else {
-      drawOffset = rmesa->radeon.radeonScreen->frontOffset;
-      drawPitch  = rmesa->radeon.radeonScreen->frontPitch;
-   }
 
    rmesa->radeon.hw.max_state_size = 0;
 
@@ -687,6 +701,22 @@ void radeonInitState( r100ContextPtr rmesa )
 	 cmdvec( RADEON_VS_UCP_ADDR + i, 1, 4 );
    }
 
+   if (rmesa->radeon.radeonScreen->kernel_mm) {
+      rmesa->hw.grd.emit = scl_emit;
+      rmesa->hw.fog.emit = vec_emit;
+      rmesa->hw.glt.emit = vec_emit;
+      rmesa->hw.eye.emit = vec_emit;
+      
+      for (i = 0; i <= 6; i++)
+	 rmesa->hw.mat[i].emit = vec_emit;
+
+      for (i = 0; i < 8; i++)
+	 rmesa->hw.lit[i].emit = lit_emit;
+
+      for (i = 0; i < 6; i++)
+	 rmesa->hw.ucp[i].emit = vec_emit;
+   }
+
    rmesa->last_ReallyEnabled = -1;
 
    /* Initial Harware state:
@@ -708,19 +738,7 @@ void radeonInitState( r100ContextPtr rmesa )
 					    RADEON_SRC_BLEND_GL_ONE |
 					    RADEON_DST_BLEND_GL_ZERO );
 
-   rmesa->hw.ctx.cmd[CTX_RB3D_DEPTHOFFSET] =
-      rmesa->radeon.radeonScreen->depthOffset + rmesa->radeon.radeonScreen->fbLocation;
-
-   rmesa->hw.ctx.cmd[CTX_RB3D_DEPTHPITCH] = 
-      ((rmesa->radeon.radeonScreen->depthPitch &
-	RADEON_DEPTHPITCH_MASK) |
-       RADEON_DEPTH_ENDIAN_NO_SWAP);
-       
-   if (rmesa->using_hyperz)
-       rmesa->hw.ctx.cmd[CTX_RB3D_DEPTHPITCH] |= RADEON_DEPTH_HYPERZ;
-
-   rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] = (depth_fmt |
-					       RADEON_Z_TEST_LESS |
+   rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] = (RADEON_Z_TEST_LESS |
 					       RADEON_STENCIL_TEST_ALWAYS |
 					       RADEON_STENCIL_FAIL_KEEP |
 					       RADEON_STENCIL_ZPASS_KEEP |
@@ -742,7 +760,6 @@ void radeonInitState( r100ContextPtr rmesa )
 				     RADEON_ANTI_ALIAS_NONE);
 
    rmesa->hw.ctx.cmd[CTX_RB3D_CNTL] = (RADEON_PLANE_MASK_ENABLE |
-				       color_fmt |
 				       RADEON_ZBLOCK16);
 
    switch ( driQueryOptioni( &rmesa->radeon.optionCache, "dither_mode" ) ) {
@@ -764,19 +781,6 @@ void radeonInitState( r100ContextPtr rmesa )
    else
       rmesa->hw.ctx.cmd[CTX_RB3D_CNTL] |= rmesa->radeon.state.color.roundEnable;
 
-   rmesa->hw.ctx.cmd[CTX_RB3D_COLOROFFSET] = ((drawOffset +
-					       rmesa->radeon.radeonScreen->fbLocation)
-					      & RADEON_COLOROFFSET_MASK);
-
-   rmesa->hw.ctx.cmd[CTX_RB3D_COLORPITCH] = ((drawPitch &
-					      RADEON_COLORPITCH_MASK) |
-					     RADEON_COLOR_ENDIAN_NO_SWAP);
-
-
-   /* (fixed size) sarea is initialized to zero afaics so can omit version check. Phew! */
-   if (rmesa->radeon.sarea->tiling_enabled) {
-      rmesa->hw.ctx.cmd[CTX_RB3D_COLORPITCH] |= RADEON_COLOR_TILE_ENABLE;
-   }
 
    rmesa->hw.set.cmd[SET_SE_CNTL] = (RADEON_FFACE_CULL_CCW |
 				     RADEON_BFACE_SOLID |
