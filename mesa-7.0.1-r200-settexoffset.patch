4f96000e294fa0d6ba6f5915ff508017d9c26d50
diff --git a/src/mesa/drivers/dri/r200/r200_context.h b/src/mesa/drivers/dri/r200/r200_context.h
index bec09e8..c80180b 100644
--- a/src/mesa/drivers/dri/r200/r200_context.h
+++ b/src/mesa/drivers/dri/r200/r200_context.h
@@ -179,6 +179,7 @@ struct r200_tex_obj {
 
    drm_radeon_tex_image_t image[6][RADEON_MAX_TEXTURE_LEVELS];
 					/* Six, for the cube faces */
+   GLboolean image_override;		/* Image overridden by GLX_EXT_tfp */
 
    GLuint pp_txfilter;		        /* hardware register values */
    GLuint pp_txformat;
diff --git a/src/mesa/drivers/dri/r200/r200_tex.h b/src/mesa/drivers/dri/r200/r200_tex.h
index e6c0e00..10ff8e8 100644
--- a/src/mesa/drivers/dri/r200/r200_tex.h
+++ b/src/mesa/drivers/dri/r200/r200_tex.h
@@ -35,6 +35,10 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #ifndef __R200_TEX_H__
 #define __R200_TEX_H__
 
+extern void r200SetTexOffset(__DRIcontext *pDRICtx, GLint texname,
+			     unsigned long long offset, GLint depth,
+			     GLuint pitch);
+
 extern void r200UpdateTextureState( GLcontext *ctx );
 
 extern int r200UploadTexImages( r200ContextPtr rmesa, r200TexObjPtr t, GLuint face );
diff --git a/src/mesa/drivers/dri/r200/r200_texmem.c b/src/mesa/drivers/dri/r200/r200_texmem.c
index d926313..183c4ca 100644
--- a/src/mesa/drivers/dri/r200/r200_texmem.c
+++ b/src/mesa/drivers/dri/r200/r200_texmem.c
@@ -181,7 +181,8 @@ static void r200UploadRectSubImage( r200ContextPtr rmesa,
       /* In this case, could also use GART texturing.  This is
        * currently disabled, but has been tested & works.
        */
-      t->pp_txoffset = r200GartOffsetFromVirtual( rmesa, texImage->Data );
+      if ( !t->image_override )
+         t->pp_txoffset = r200GartOffsetFromVirtual( rmesa, texImage->Data );
       t->pp_txpitch = texImage->RowStride * texFormat->TexelBytes - 32;
 
       if (R200_DEBUG & DEBUG_TEXTURE)
@@ -467,7 +468,7 @@ int r200UploadTexImages( r200ContextPtr rmesa, r200TexObjPtr t, GLuint face )
 	       t->base.firstLevel, t->base.lastLevel );
    }
 
-   if ( !t || t->base.totalSize == 0 )
+   if ( !t || t->base.totalSize == 0 || t->image_override )
       return 0;
 
    if (R200_DEBUG & DEBUG_SYNC) {
diff --git a/src/mesa/drivers/dri/r200/r200_texstate.c b/src/mesa/drivers/dri/r200/r200_texstate.c
index ae02ec4..93c0fb7 100644
--- a/src/mesa/drivers/dri/r200/r200_texstate.c
+++ b/src/mesa/drivers/dri/r200/r200_texstate.c
@@ -37,6 +37,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "context.h"
 #include "macros.h"
 #include "texformat.h"
+#include "texobj.h"
 #include "enums.h"
 
 #include "r200_context.h"
@@ -72,10 +73,11 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define VALID_FORMAT(f) ( ((f) <= MESA_FORMAT_RGBA_DXT5) \
 			     && (tx_table_le[f].format != 0xffffffff) )
 
-static const struct {
+struct tx_table {
    GLuint format, filter;
-}
-tx_table_be[] =
+};
+
+static const struct tx_table tx_table_be[] =
 {
    [ MESA_FORMAT_RGBA8888 ] = { R200_TXFORMAT_ABGR8888 | R200_TXFORMAT_ALPHA_IN_MAP, 0 },
    _ALPHA_REV(RGBA8888),
@@ -104,16 +106,13 @@ tx_table_be[] =
    _ALPHA(RGBA_DXT5),
 };
 
-static const struct {
-   GLuint format, filter;
-}
-tx_table_le[] =
+static const struct tx_table tx_table_le[] =
 {
    _ALPHA(RGBA8888),
    [ MESA_FORMAT_RGBA8888_REV ] = { R200_TXFORMAT_ABGR8888 | R200_TXFORMAT_ALPHA_IN_MAP, 0 },
    _ALPHA(ARGB8888),
    _ALPHA_REV(ARGB8888),
-   _INVALID(RGB888),
+   [ MESA_FORMAT_RGB888 ] = { R200_TXFORMAT_ARGB8888, 0 },
    _COLOR(RGB565),
    _COLOR_REV(RGB565),
    _ALPHA(ARGB4444),
@@ -160,30 +159,23 @@ static void r200SetTexImages( r200ContextPtr rmesa,
    GLint i, texelBytes;
    GLint numLevels;
    GLint log2Width, log2Height, log2Depth;
-   const GLuint ui = 1;
-   const GLubyte littleEndian = *((const GLubyte *) &ui);
 
    /* Set the hardware texture format
     */
+   if ( !t->image_override ) {
+      if ( VALID_FORMAT( baseImage->TexFormat->MesaFormat ) ) {
+         t->pp_txformat &= ~(R200_TXFORMAT_FORMAT_MASK |
+                             R200_TXFORMAT_ALPHA_IN_MAP);
+         t->pp_txfilter &= ~R200_YUV_TO_RGB;
 
-   t->pp_txformat &= ~(R200_TXFORMAT_FORMAT_MASK |
-		       R200_TXFORMAT_ALPHA_IN_MAP);
-   t->pp_txfilter &= ~R200_YUV_TO_RGB;
-
-   if ( VALID_FORMAT( baseImage->TexFormat->MesaFormat ) ) {
-      if (littleEndian) {
 	 t->pp_txformat |= tx_table_le[ baseImage->TexFormat->MesaFormat ].format;
 	 t->pp_txfilter |= tx_table_le[ baseImage->TexFormat->MesaFormat ].filter;
       }
       else {
-	 t->pp_txformat |= tx_table_be[ baseImage->TexFormat->MesaFormat ].format;
-	 t->pp_txfilter |= tx_table_be[ baseImage->TexFormat->MesaFormat ].filter;
+         _mesa_problem(NULL, "unexpected texture format in %s", __FUNCTION__);
+         return;
       }
    }
-   else {
-      _mesa_problem(NULL, "unexpected texture format in %s", __FUNCTION__);
-      return;
-   }
 
    texelBytes = baseImage->TexFormat->TexelBytes;
 
@@ -380,11 +372,13 @@ static void r200SetTexImages( r200ContextPtr rmesa,
     * requires 64-byte aligned pitches, and we may/may not need the
     * blitter.   NPOT only!
     */
-   if (baseImage->IsCompressed)
-      t->pp_txpitch = (tObj->Image[0][t->base.firstLevel]->Width + 63) & ~(63);
-   else
-      t->pp_txpitch = ((tObj->Image[0][t->base.firstLevel]->Width * texelBytes) + 63) & ~(63);
-   t->pp_txpitch -= 32;
+   if ( !t->image_override ) {
+      if (baseImage->IsCompressed)
+         t->pp_txpitch = (tObj->Image[0][t->base.firstLevel]->Width + 63) & ~(63);
+      else
+         t->pp_txpitch = ((tObj->Image[0][t->base.firstLevel]->Width * texelBytes) + 63) & ~(63);
+      t->pp_txpitch -= 32;
+   }
 
    t->dirty_state = TEX_ALL;
 
@@ -979,6 +973,46 @@ static GLboolean r200UpdateTextureEnv( GLcontext *ctx, int unit, int slot, GLuin
    return GL_TRUE;
 }
 
+void r200SetTexOffset(__DRIcontext * pDRICtx, GLint texname,
+		      unsigned long long offset, GLint depth, GLuint pitch)
+{
+	r200ContextPtr rmesa =
+	    (r200ContextPtr) ((__DRIcontextPrivate *) pDRICtx->private)->
+	    driverPrivate;
+	struct gl_texture_object *tObj =
+	    _mesa_lookup_texture(rmesa->glCtx, texname);
+	r200TexObjPtr t;
+
+	if (!tObj)
+		return;
+
+	t = (r200TexObjPtr) tObj->DriverData;
+
+	t->image_override = GL_TRUE;
+
+	if (!offset)
+		return;
+
+	t->pp_txoffset = offset;
+	t->pp_txpitch = pitch - 32;
+
+	switch (depth) {
+	case 32:
+		t->pp_txformat = tx_table_le[2].format;
+		t->pp_txfilter |= tx_table_le[2].filter;
+		break;
+	case 24:
+	default:
+		t->pp_txformat = tx_table_le[4].format;
+		t->pp_txfilter |= tx_table_le[4].filter;
+		break;
+	case 16:
+		t->pp_txformat = tx_table_le[5].format;
+		t->pp_txfilter |= tx_table_le[5].filter;
+		break;
+	}
+}
+
 #define REF_COLOR 1
 #define REF_ALPHA 2
 
@@ -1560,7 +1594,7 @@ static GLboolean enable_tex_2d( GLcontext *ctx, int unit )
       R200_FIREVERTICES( rmesa );
       r200SetTexImages( rmesa, tObj );
       r200UploadTexImages( rmesa, (r200TexObjPtr) tObj->DriverData, 0 );
-      if ( !t->base.memBlock ) 
+      if ( !t->base.memBlock && !t->image_override ) 
 	 return GL_FALSE;
    }
 
@@ -1668,7 +1702,9 @@ static GLboolean enable_tex_rect( GLcontext *ctx, int unit )
       R200_FIREVERTICES( rmesa );
       r200SetTexImages( rmesa, tObj );
       r200UploadTexImages( rmesa, (r200TexObjPtr) tObj->DriverData, 0 );
-      if ( !t->base.memBlock && !rmesa->prefer_gart_client_texturing ) 
+      if ( !t->base.memBlock &&
+           !t->image_override &&
+           !rmesa->prefer_gart_client_texturing ) 
 	 return GL_FALSE;
    }
 
diff --git a/src/mesa/drivers/dri/radeon/radeon_screen.c b/src/mesa/drivers/dri/radeon/radeon_screen.c
index aa7fb63..682cf3a 100644
--- a/src/mesa/drivers/dri/radeon/radeon_screen.c
+++ b/src/mesa/drivers/dri/radeon/radeon_screen.c
@@ -53,6 +53,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "r200_context.h"
 #include "r200_ioctl.h"
 #include "r200_span.h"
+#include "r200_tex.h"
 #elif RADEON_COMMON && defined(RADEON_COMMON_FOR_R300)
 #include "r300_context.h"
 #include "r300_fragprog.h"
@@ -973,7 +974,8 @@ static const struct __DriverAPIRec r200API = {
    .WaitForMSC      = driWaitForMSC32,
    .WaitForSBC      = NULL,
    .SwapBuffersMSC  = NULL,
-   .CopySubBuffer   = r200CopySubBuffer
+   .CopySubBuffer   = r200CopySubBuffer,
+   .setTexOffset    = r200SetTexOffset
 };
 #endif
 
