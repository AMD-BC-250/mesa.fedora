diff --git a/src/gallium/drivers/crocus/crocus_draw.c b/src/gallium/drivers/crocus/crocus_draw.c
index cdfe6a63b26..b64bb0d46cb 100644
--- a/src/gallium/drivers/crocus/crocus_draw.c
+++ b/src/gallium/drivers/crocus/crocus_draw.c
@@ -407,7 +407,7 @@ crocus_draw_vbo(struct pipe_context *ctx,
     * write offsets, changing the behavior.
     */
    if (unlikely(INTEL_DEBUG & DEBUG_REEMIT)) {
-      ice->state.dirty |= CROCUS_ALL_DIRTY_FOR_RENDER & ~CROCUS_DIRTY_GEN7_SO_BUFFERS;
+      ice->state.dirty |= CROCUS_ALL_DIRTY_FOR_RENDER & ~(CROCUS_DIRTY_GEN7_SO_BUFFERS | CROCUS_DIRTY_GEN6_SVBI);
       ice->state.stage_dirty |= CROCUS_ALL_STAGE_DIRTY_FOR_RENDER;
    }
 
diff --git a/src/gallium/drivers/crocus/crocus_program_cache.c b/src/gallium/drivers/crocus/crocus_program_cache.c
index d2d4b821754..52d8bbf0b4c 100644
--- a/src/gallium/drivers/crocus/crocus_program_cache.c
+++ b/src/gallium/drivers/crocus/crocus_program_cache.c
@@ -155,10 +155,11 @@ crocus_cache_new_bo(struct crocus_context *ice,
    ice->shaders.cache_bo = new_bo;
    ice->shaders.cache_bo_map = map;
 
-   if (screen->devinfo.ver == 4) {
+   if (screen->devinfo.ver <= 5) {
       /* reemit all shaders on GEN4 only. */
       ice->state.dirty |= CROCUS_DIRTY_CLIP | CROCUS_DIRTY_RASTER |
          CROCUS_DIRTY_WM;
+      ice->state.stage_dirty |= CROCUS_STAGE_DIRTY_VS;
    }
    ice->batches[CROCUS_BATCH_RENDER].state_base_address_emitted = false;
    ice->batches[CROCUS_BATCH_COMPUTE].state_base_address_emitted = false;
diff --git a/src/gallium/drivers/crocus/crocus_query.c b/src/gallium/drivers/crocus/crocus_query.c
index df3f3103647..6bc8aeeef14 100644
--- a/src/gallium/drivers/crocus/crocus_query.c
+++ b/src/gallium/drivers/crocus/crocus_query.c
@@ -678,8 +678,12 @@ crocus_get_query_result(struct pipe_context *ctx,
       }
       assert(READ_ONCE(q->map->snapshots_landed));
 #else
-      if (crocus_wait_syncobj(ctx->screen, q->syncobj, wait ? INT64_MAX : 0))
+      if (crocus_wait_syncobj(ctx->screen, q->syncobj, wait ? INT64_MAX : 0)) {
+         /* if we've waited and timedout, just set the query to ready to avoid infinite loop */
+         if (wait)
+            q->ready = true;
          return false;
+      }
 #endif
       calculate_result_on_cpu(devinfo, q);
    }
diff --git a/src/gallium/drivers/crocus/crocus_resource.c b/src/gallium/drivers/crocus/crocus_resource.c
index 2c8ea3a6529..56b517a28b6 100644
--- a/src/gallium/drivers/crocus/crocus_resource.c
+++ b/src/gallium/drivers/crocus/crocus_resource.c
@@ -162,7 +162,7 @@ pipe_bind_to_isl_usage(unsigned bindings)
    if (bindings & (PIPE_BIND_SHADER_IMAGE | PIPE_BIND_SHADER_BUFFER))
       usage |= ISL_SURF_USAGE_STORAGE_BIT;
 
-   if (bindings & PIPE_BIND_DISPLAY_TARGET)
+   if (bindings & PIPE_BIND_SCANOUT)
       usage |= ISL_SURF_USAGE_DISPLAY_BIT;
    return usage;
 }
diff --git a/src/gallium/drivers/crocus/crocus_state.c b/src/gallium/drivers/crocus/crocus_state.c
index 9dbe0a49e2d..4160b6260c6 100644
--- a/src/gallium/drivers/crocus/crocus_state.c
+++ b/src/gallium/drivers/crocus/crocus_state.c
@@ -5861,8 +5861,10 @@ crocus_upload_dirty_render_state(struct crocus_context *ice,
      bool ret = crocus_calculate_urb_fence(batch, ice->curbe.total_size,
                                            brw_vue_prog_data(ice->shaders.prog[MESA_SHADER_VERTEX]->prog_data)->urb_entry_size,
                                            ((struct brw_sf_prog_data *)ice->shaders.sf_prog->prog_data)->urb_entry_size);
-     if (ret)
-        dirty |= CROCUS_DIRTY_GEN5_PIPELINED_POINTERS;
+     if (ret) {
+	dirty |= CROCUS_DIRTY_GEN5_PIPELINED_POINTERS | CROCUS_DIRTY_RASTER | CROCUS_DIRTY_CLIP;
+	stage_dirty |= CROCUS_STAGE_DIRTY_GS | CROCUS_STAGE_DIRTY_VS;
+     }
    }
 #endif
    if (dirty & CROCUS_DIRTY_CC_VIEWPORT) {
